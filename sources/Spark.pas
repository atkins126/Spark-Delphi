{==============================================================================
  ____                   _
 / ___| _ __   __ _ _ __| | __
 \___ \| '_ \ / _` | '__| |/ /
  ___) | |_) | (_| | |  |   <
 |____/| .__/ \__,_|_|  |_|\_\
       |_|   Game Toolkit™

 Copyright © 2022 tinyBigGAMES™ LLC
 All Rights Reserved.

 Website: https://tinybiggames.com
 Email  : support@tinybiggames.com

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software in
   a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

2. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.

3. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in
   the documentation and/or other materials provided with the
   distribution.

4. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

5. All video, audio, graphics and other content accessed through the
   software in this distro is the property of the applicable content owner
   and may be protected by applicable copyright law. This License gives
   Customer no rights to such content, and Company disclaims any liability
   for misuse of content.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
============================================================================= }

{$WARN SYMBOL_DEPRECATED OFF}
{$WARN SYMBOL_PLATFORM OFF}

{$WARN UNIT_PLATFORM OFF}
{$WARN UNIT_DEPRECATED OFF}

{$Z4}
{$A8}

{$INLINE AUTO}

{$IFNDEF WIN64}
  {$MESSAGE Error 'Unsupported platform'}
{$ENDIF}

unit Spark;

interface

{$REGION 'Spark.WinApi'}
const
  MAX_PATH                 = 260;
  RT_RCDATA                = PChar(10);
  SM_CXFULLSCREEN          = $10;
  SM_CYFULLSCREEN          = 17;
  GWL_STYLE                = -16;
  WS_MAXIMIZEBOX           = $10000;
  PM_REMOVE                = 1;
  FILE_ATTRIBUTE_DIRECTORY = $00000010;
  FILE_ATTRIBUTE_ARCHIVE   = $00000020;
  INVALID_HANDLE_VALUE     = THandle(-1);
  STD_OUTPUT_HANDLE        = System.FixedUInt(-11);
  INVALID_FILE_ATTRIBUTES  = System.FixedUInt($FFFFFFFF);
  ERROR_FILE_NOT_FOUND     = 2;
  CP_UTF8                  = 65001; { UTF-8 translation }
  DISPLAY_DEFAULT_DPI      = 96;

type
  BOOL     = System.LongBool;
  DWORD    = System.FixedUInt;
  HWND     = System.NativeUInt;
  LPCWSTR  = System.PWideChar;
  LPWSTR   = System.PWideChar;
  HGLOBAL  = System.THandle;
  HINST    = System.HINST;
  UINT     = System.LongWord;
  HMODULE  = HINST;
  FARPROC  = Pointer;
  LPCSTR   = PAnsiChar;
  LONG_PTR = NativeInt;
  WPARAM   = NativeUInt;
  LPARAM   = NativeInt;

  { TPoint }
  PPoint = ^TPoint;
  TPoint = record
    X: LongInt;
    Y: LongInt;
  end;

  { TMsg }
  PMsg = ^TMsg;
  TMsg = record
    hwnd: HWND;
    message: UINT;
    wParam: WPARAM;
    lParam: LPARAM;
    time: DWORD;
    pt: TPoint;
  end;

  { TFileTime }
  TFileTime = record
    dwLowDateTime: DWORD;
    dwHighDateTime: DWORD;
  end;

  { TFindDataW }
  TFindDataW = record
    dwFileAttributes: DWORD;
    ftCreationTime: TFileTime;
    ftLastAccessTime: TFileTime;
    ftLastWriteTime: TFileTime;
    nFileSizeHigh: DWORD;
    nFileSizeLow: DWORD;
    dwReserved0: DWORD;
    dwReserved1: DWORD;
    cFileName: array[0..MAX_PATH - 1] of WideChar;
    cAlternateFileName: array[0..13] of WideChar;
  end;

  { TSecurityAttributes }
  PSecurityAttributes = ^TSecurityAttributes;
  TSecurityAttributes = record
    nLength: DWORD;
    lpSecurityDescriptor: Pointer;
    bInheritHandle: BOOL;
  end;

// --- kernel32 -------------------------------------------------------------
function  LoadLibraryW(lpLibFileName: LPCWSTR): HMODULE; stdcall; external 'kernel32';
function  FreeLibrary(hLibModule: HMODULE): BOOL; stdcall; external 'kernel32';
function  GetProcAddress(hModule: HMODULE; lpProcName: LPCSTR): FARPROC; stdcall; external 'kernel32';
function  FindResourceW(hModule: HMODULE; lpName, lpType: LPCWSTR): HRSRC; stdcall; external 'kernel32';
function  LoadResource(hModule: HINST; hResInfo: HRSRC): HGLOBAL; stdcall; stdcall; external 'kernel32';
function  SizeofResource(hModule: HINST; hResInfo: HRSRC): DWORD; stdcall; stdcall; external 'kernel32';
function  LockResource(hResData: HGLOBAL): Pointer; stdcall; stdcall; external 'kernel32';
function  FreeResource(hResData: HGLOBAL): BOOL; stdcall; stdcall; external 'kernel32';
function  GetTempFileNameW(lpPathName, lpPrefixString: LPCWSTR; uUnique: UINT; lpTempFileName: LPWSTR): UINT; stdcall; external 'kernel32';
function  GetTempPathW(nBufferLength: DWORD; lpBuffer: LPWSTR): DWORD; stdcall; external 'kernel32';
function  GetLongPathNameW(lpszShortPath: LPCWSTR; lpszLongPath: LPWSTR; cchBuffer: DWORD): DWORD; stdcall; external 'kernel32';
function  MulDiv(nNumber, nNumerator, nDenominator: Integer): Integer; stdcall; external 'kernel32';
procedure Sleep(dwMilliseconds: DWORD); stdcall; external 'kernel32';
function  FindFirstFileW(lpFileName: LPCWSTR; var lpFindFileData: TFindDataW): THandle; stdcall; external 'kernel32';
function  FindNextFileW(hFindFile: THandle; var lpFindFileData: TFindDataW): BOOL; stdcall; external 'kernel32';
function  FindClose(hFindFile: THandle): BOOL; stdcall; external 'kernel32';
function  GetStdHandle(nStdHandle: DWORD): THandle; stdcall; external 'kernel32';
function  GetFileAttributesW(lpFileName: LPCWSTR): DWORD; stdcall; external 'kernel32';
function  GetConsoleOutputCP: UINT; stdcall; external 'kernel32';
function  SetConsoleOutputCP(wCodePageID: UINT): BOOL; stdcall; external 'kernel32';
function  GetFullPathNameW(lpFileName: LPCWSTR; nBufferLength: DWORD; lpBuffer: LPWSTR; var lpFilePart: LPWSTR): DWORD; stdcall; external 'kernel32';
function  CreateDirectoryW(lpPathName: LPCWSTR; lpSecurityAttributes: PSecurityAttributes): BOOL; stdcall; external 'kernel32';

// --- user32 ---------------------------------------------------------------
function  GetSystemMetrics(nIndex: Integer): Integer; stdcall; external 'user32';
function  SetWindowLongPtrW(hWnd: HWND; nIndex: Integer; dwNewLong: LONG_PTR): LONG_PTR; stdcall; external 'user32';
function  GetWindowLongPtrW(hWnd: HWND; nIndex: Integer): LONG_PTR; stdcall; external 'user32';
function  PeekMessageW(var lpMsg: TMsg; hWnd: HWND; wMsgFilterMin, wMsgFilterMax, wRemoveMsg: UINT): BOOL; stdcall; external 'user32';
function  TranslateMessage(const lpMsg: TMsg): BOOL; stdcall; external 'user32';
function  DispatchMessageW(const lpMsg: TMsg): Longint; stdcall; external 'user32';

{$ENDREGION}

{$REGION 'Spark.Allegro'}
const
  SPARK_DLL = 'Spark.dll';

  INT32_MIN = (-2147483647-1);

  _ALLEGRO_UNSTABLE_BIT_SET = INT32_MIN;
  ALLEGRO_VERSION = 5;
  ALLEGRO_SUB_VERSION = 2;
  ALLEGRO_WIP_VERSION = 8;
  ALLEGRO_UNSTABLE_BIT = _ALLEGRO_UNSTABLE_BIT_SET;
  ALLEGRO_RELEASE_NUMBER = 0;
  ALLEGRO_VERSION_STR = '5.2.8 (GIT)';
  ALLEGRO_DATE_STR = '2021';
  ALLEGRO_DATE = 20210307;
  ALLEGRO_VERSION_INT = ((ALLEGRO_VERSION shl 24) or (ALLEGRO_SUB_VERSION shl 16) or (ALLEGRO_WIP_VERSION shl 8) or ALLEGRO_RELEASE_NUMBER or ALLEGRO_UNSTABLE_BIT);
  ALLEGRO_PI = 3.14159265358979323846;
  ALLEGRO_NATIVE_PATH_SEP = '\';
  ALLEGRO_NATIVE_DRIVE_SEP = ':';
  ALLEGRO_NEW_WINDOW_TITLE_MAX_SIZE = 255;

  EOF = (-1);

  // Joystick
  _AL_MAX_JOYSTICK_AXES = 3;
  _AL_MAX_JOYSTICK_STICKS = 16;
  _AL_MAX_JOYSTICK_BUTTONS = 32;

  ALLEGRO_MOUSE_MAX_EXTRA_AXES = 4;
  ALLEGRO_TOUCH_INPUT_MAX_TOUCH_COUNT = 16;

  // Shader
  ALLEGRO_SHADER_VAR_COLOR = 'al_color';
  ALLEGRO_SHADER_VAR_POS = 'al_pos';
  ALLEGRO_SHADER_VAR_PROJVIEW_MATRIX = 'al_projview_matrix';
  ALLEGRO_SHADER_VAR_TEX = 'al_tex';
  ALLEGRO_SHADER_VAR_TEXCOORD = 'al_texcoord';
  ALLEGRO_SHADER_VAR_TEX_MATRIX = 'al_tex_matrix';
  ALLEGRO_SHADER_VAR_USER_ATTR = 'al_user_attr_';
  ALLEGRO_SHADER_VAR_USE_TEX = 'al_use_tex';
  ALLEGRO_SHADER_VAR_USE_TEX_MATRIX = 'al_use_tex_matrix';
  ALLEGRO_SHADER_VAR_ALPHA_TEST = 'al_alpha_test';
  ALLEGRO_SHADER_VAR_ALPHA_FUNCTION = 'al_alpha_func';
  ALLEGRO_SHADER_VAR_ALPHA_TEST_VALUE = 'al_alpha_test_val';

  ALLEGRO_MAX_CHANNELS = 8;
  ALLEGRO_AUDIO_PAN_NONE = (-1000.0);

  ALLEGRO_VERTEX_CACHE_SIZE = 256;

  ALLEGRO_PRIM_QUALITY = 10;

  // TTF
  ALLEGRO_TTF_NO_KERNING = 1;
  ALLEGRO_TTF_MONOCHROME = 2;
  ALLEGRO_TTF_NO_AUTOHINT = 4;

  // Pixel format
  ALLEGRO_PIXEL_FORMAT_ANY = 0;
  ALLEGRO_PIXEL_FORMAT_ANY_NO_ALPHA = 1;
  ALLEGRO_PIXEL_FORMAT_ANY_WITH_ALPHA = 2;
  ALLEGRO_PIXEL_FORMAT_ANY_15_NO_ALPHA = 3;
  ALLEGRO_PIXEL_FORMAT_ANY_16_NO_ALPHA = 4;
  ALLEGRO_PIXEL_FORMAT_ANY_16_WITH_ALPHA = 5;
  ALLEGRO_PIXEL_FORMAT_ANY_24_NO_ALPHA = 6;
  ALLEGRO_PIXEL_FORMAT_ANY_32_NO_ALPHA = 7;
  ALLEGRO_PIXEL_FORMAT_ANY_32_WITH_ALPHA = 8;
  ALLEGRO_PIXEL_FORMAT_ARGB_8888 = 9;
  ALLEGRO_PIXEL_FORMAT_RGBA_8888 = 10;
  ALLEGRO_PIXEL_FORMAT_ARGB_4444 = 11;
  ALLEGRO_PIXEL_FORMAT_RGB_888 = 12;
  ALLEGRO_PIXEL_FORMAT_RGB_565 = 13;
  ALLEGRO_PIXEL_FORMAT_RGB_555 = 14;
  ALLEGRO_PIXEL_FORMAT_RGBA_5551 = 15;
  ALLEGRO_PIXEL_FORMAT_ARGB_1555 = 16;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888 = 17;
  ALLEGRO_PIXEL_FORMAT_XBGR_8888 = 18;
  ALLEGRO_PIXEL_FORMAT_BGR_888 = 19;
  ALLEGRO_PIXEL_FORMAT_BGR_565 = 20;
  ALLEGRO_PIXEL_FORMAT_BGR_555 = 21;
  ALLEGRO_PIXEL_FORMAT_RGBX_8888 = 22;
  ALLEGRO_PIXEL_FORMAT_XRGB_8888 = 23;
  ALLEGRO_PIXEL_FORMAT_ABGR_F32 = 24;
  ALLEGRO_PIXEL_FORMAT_ABGR_8888_LE = 25;
  ALLEGRO_PIXEL_FORMAT_RGBA_4444 = 26;
  ALLEGRO_PIXEL_FORMAT_SINGLE_CHANNEL_8 = 27;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT1 = 28;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT3 = 29;
  ALLEGRO_PIXEL_FORMAT_COMPRESSED_RGBA_DXT5 = 30;
  ALLEGRO_NUM_PIXEL_FORMATS = 31;

  // Bitmap
  ALLEGRO_BITMAP_WRAP_DEFAULT = 0;
  ALLEGRO_BITMAP_WRAP_REPEAT = 1;
  ALLEGRO_BITMAP_WRAP_CLAMP = 2;
  ALLEGRO_BITMAP_WRAP_MIRROR = 3;

  ALLEGRO_MEMORY_BITMAP = 1;
  _ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_FORCE_LOCKING = 4;
  ALLEGRO_NO_PRESERVE_TEXTURE = 8;
  _ALLEGRO_ALPHA_TEST = 16;
  _ALLEGRO_INTERNAL_OPENGL = 32;
  ALLEGRO_MIN_LINEAR = 64;
  ALLEGRO_MAG_LINEAR = 128;
  ALLEGRO_MIPMAP = 256;
  _ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_VIDEO_BITMAP = 1024;
  ALLEGRO_CONVERT_BITMAP = 4096;

  ALLEGRO_FLIP_HORIZONTAL = 1;
  ALLEGRO_FLIP_VERTICAL = 2;

  // Seek
  ALLEGRO_SEEK_SET = 0;
  ALLEGRO_SEEK_CUR = 1;
  ALLEGRO_SEEK_END = 2;

  ALLEGRO_KEEP_BITMAP_FORMAT = 2;
  ALLEGRO_NO_PREMULTIPLIED_ALPHA = 512;
  ALLEGRO_KEEP_INDEX = 2048;

  ALLEGRO_LOCK_READWRITE = 0;
  ALLEGRO_LOCK_READONLY = 1;
  ALLEGRO_LOCK_WRITEONLY = 2;

  ALLEGRO_ZERO = 0;
  ALLEGRO_ONE = 1;
  ALLEGRO_ALPHA = 2;
  ALLEGRO_INVERSE_ALPHA = 3;
  ALLEGRO_SRC_COLOR = 4;
  ALLEGRO_DEST_COLOR = 5;
  ALLEGRO_INVERSE_SRC_COLOR = 6;
  ALLEGRO_INVERSE_DEST_COLOR = 7;
  ALLEGRO_CONST_COLOR = 8;
  ALLEGRO_INVERSE_CONST_COLOR = 9;
  ALLEGRO_NUM_BLEND_MODES = 10; 

  ALLEGRO_ADD = 0;
  ALLEGRO_SRC_MINUS_DEST = 1;
  ALLEGRO_DEST_MINUS_SRC = 2;
  ALLEGRO_NUM_BLEND_OPERATIONS = 3;  

  // Event
  ALLEGRO_EVENT_JOYSTICK_AXIS = 1;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN = 2;
  ALLEGRO_EVENT_JOYSTICK_BUTTON_UP = 3;
  ALLEGRO_EVENT_JOYSTICK_CONFIGURATION = 4;
  ALLEGRO_EVENT_KEY_DOWN = 10;
  ALLEGRO_EVENT_KEY_CHAR = 11;
  ALLEGRO_EVENT_KEY_UP = 12;
  ALLEGRO_EVENT_MOUSE_AXES = 20;
  ALLEGRO_EVENT_MOUSE_BUTTON_DOWN = 21;
  ALLEGRO_EVENT_MOUSE_BUTTON_UP = 22;
  ALLEGRO_EVENT_MOUSE_ENTER_DISPLAY = 23;
  ALLEGRO_EVENT_MOUSE_LEAVE_DISPLAY = 24;
  ALLEGRO_EVENT_MOUSE_WARPED = 25;
  ALLEGRO_EVENT_TIMER = 30;
  ALLEGRO_EVENT_DISPLAY_EXPOSE = 40;
  ALLEGRO_EVENT_DISPLAY_RESIZE = 41;
  ALLEGRO_EVENT_DISPLAY_CLOSE = 42;
  ALLEGRO_EVENT_DISPLAY_LOST = 43;
  ALLEGRO_EVENT_DISPLAY_FOUND = 44;
  ALLEGRO_EVENT_DISPLAY_SWITCH_IN = 45;
  ALLEGRO_EVENT_DISPLAY_SWITCH_OUT = 46;
  ALLEGRO_EVENT_DISPLAY_ORIENTATION = 47;
  ALLEGRO_EVENT_DISPLAY_HALT_DRAWING = 48;
  ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING = 49;
  ALLEGRO_EVENT_TOUCH_BEGIN = 50;
  ALLEGRO_EVENT_TOUCH_END = 51;
  ALLEGRO_EVENT_TOUCH_MOVE = 52;
  ALLEGRO_EVENT_TOUCH_CANCEL = 53;
  ALLEGRO_EVENT_DISPLAY_CONNECTED = 60;
  ALLEGRO_EVENT_DISPLAY_DISCONNECTED = 61;

  ALLEGRO_WINDOWED = 1;
  ALLEGRO_FULLSCREEN = 2;
  ALLEGRO_OPENGL = 4;
  ALLEGRO_DIRECT3D_INTERNAL = 8;
  ALLEGRO_RESIZABLE = 16;
  ALLEGRO_FRAMELESS = 32;
  ALLEGRO_NOFRAME = 32;
  ALLEGRO_GENERATE_EXPOSE_EVENTS = 64;
  ALLEGRO_OPENGL_3_0 = 128;
  ALLEGRO_OPENGL_FORWARD_COMPATIBLE = 256;
  ALLEGRO_FULLSCREEN_WINDOW = 512;
  ALLEGRO_MINIMIZED = 1024;
  ALLEGRO_PROGRAMMABLE_PIPELINE = 2048;
  ALLEGRO_GTK_TOPLEVEL_INTERNAL = 4096;
  ALLEGRO_MAXIMIZED = 8192;
  ALLEGRO_OPENGL_ES_PROFILE = 16384;
  ALLEGRO_OPENGL_CORE_PROFILE = 32768;

  ALLEGRO_DONTCARE = 0;
  ALLEGRO_REQUIRE = 1;
  ALLEGRO_SUGGEST = 2;

  // Display orientation
  ALLEGRO_DISPLAY_ORIENTATION_UNKNOWN = 0;
  ALLEGRO_DISPLAY_ORIENTATION_0_DEGREES = 1;
  ALLEGRO_DISPLAY_ORIENTATION_90_DEGREES = 2;
  ALLEGRO_DISPLAY_ORIENTATION_180_DEGREES = 4;
  ALLEGRO_DISPLAY_ORIENTATION_270_DEGREES = 8;
  ALLEGRO_DISPLAY_ORIENTATION_PORTRAIT = 5;
  ALLEGRO_DISPLAY_ORIENTATION_LANDSCAPE = 10;
  ALLEGRO_DISPLAY_ORIENTATION_ALL = 15;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_UP = 16;
  ALLEGRO_DISPLAY_ORIENTATION_FACE_DOWN = 32;

  _ALLEGRO_PRIM_MAX_USER_ATTR = 10;

  // Filemode
  ALLEGRO_FILEMODE_READ = 1;
  ALLEGRO_FILEMODE_WRITE = 2;
  ALLEGRO_FILEMODE_EXECUTE = 4;
  ALLEGRO_FILEMODE_HIDDEN = 8;
  ALLEGRO_FILEMODE_ISFILE = 16;
  ALLEGRO_FILEMODE_ISDIR = 32;

  ALLEGRO_FOR_EACH_FS_ENTRY_ERROR = -1;
  ALLEGRO_FOR_EACH_FS_ENTRY_OK = 0;
  ALLEGRO_FOR_EACH_FS_ENTRY_SKIP = 1;
  ALLEGRO_FOR_EACH_FS_ENTRY_STOP = 2;

  ALLEGRO_JOYFLAG_DIGITAL = 1;
  ALLEGRO_JOYFLAG_ANALOGUE = 2;

  // Keyboard constants
  ALLEGRO_KEY_A = 1;
  ALLEGRO_KEY_B = 2;
  ALLEGRO_KEY_C = 3;
  ALLEGRO_KEY_D = 4;
  ALLEGRO_KEY_E = 5;
  ALLEGRO_KEY_F = 6;
  ALLEGRO_KEY_G = 7;
  ALLEGRO_KEY_H = 8;
  ALLEGRO_KEY_I = 9;
  ALLEGRO_KEY_J = 10;
  ALLEGRO_KEY_K = 11;
  ALLEGRO_KEY_L = 12;
  ALLEGRO_KEY_M = 13;
  ALLEGRO_KEY_N = 14;
  ALLEGRO_KEY_O = 15;
  ALLEGRO_KEY_P = 16;
  ALLEGRO_KEY_Q = 17;
  ALLEGRO_KEY_R = 18;
  ALLEGRO_KEY_S = 19;
  ALLEGRO_KEY_T = 20;
  ALLEGRO_KEY_U = 21;
  ALLEGRO_KEY_V = 22;
  ALLEGRO_KEY_W = 23;
  ALLEGRO_KEY_X = 24;
  ALLEGRO_KEY_Y = 25;
  ALLEGRO_KEY_Z = 26;
  ALLEGRO_KEY_0 = 27;
  ALLEGRO_KEY_1 = 28;
  ALLEGRO_KEY_2 = 29;
  ALLEGRO_KEY_3 = 30;
  ALLEGRO_KEY_4 = 31;
  ALLEGRO_KEY_5 = 32;
  ALLEGRO_KEY_6 = 33;
  ALLEGRO_KEY_7 = 34;
  ALLEGRO_KEY_8 = 35;
  ALLEGRO_KEY_9 = 36;
  ALLEGRO_KEY_PAD_0 = 37;
  ALLEGRO_KEY_PAD_1 = 38;
  ALLEGRO_KEY_PAD_2 = 39;
  ALLEGRO_KEY_PAD_3 = 40;
  ALLEGRO_KEY_PAD_4 = 41;
  ALLEGRO_KEY_PAD_5 = 42;
  ALLEGRO_KEY_PAD_6 = 43;
  ALLEGRO_KEY_PAD_7 = 44;
  ALLEGRO_KEY_PAD_8 = 45;
  ALLEGRO_KEY_PAD_9 = 46;
  ALLEGRO_KEY_F1 = 47;
  ALLEGRO_KEY_F2 = 48;
  ALLEGRO_KEY_F3 = 49;
  ALLEGRO_KEY_F4 = 50;
  ALLEGRO_KEY_F5 = 51;
  ALLEGRO_KEY_F6 = 52;
  ALLEGRO_KEY_F7 = 53;
  ALLEGRO_KEY_F8 = 54;
  ALLEGRO_KEY_F9 = 55;
  ALLEGRO_KEY_F10 = 56;
  ALLEGRO_KEY_F11 = 57;
  ALLEGRO_KEY_F12 = 58;
  ALLEGRO_KEY_ESCAPE = 59;
  ALLEGRO_KEY_TILDE = 60;
  ALLEGRO_KEY_MINUS = 61;
  ALLEGRO_KEY_EQUALS = 62;
  ALLEGRO_KEY_BACKSPACE = 63;
  ALLEGRO_KEY_TAB = 64;
  ALLEGRO_KEY_OPENBRACE = 65;
  ALLEGRO_KEY_CLOSEBRACE = 66;
  ALLEGRO_KEY_ENTER = 67;
  ALLEGRO_KEY_SEMICOLON = 68;
  ALLEGRO_KEY_QUOTE = 69;
  ALLEGRO_KEY_BACKSLASH = 70;
  ALLEGRO_KEY_BACKSLASH2 = 71;
  ALLEGRO_KEY_COMMA = 72;
  ALLEGRO_KEY_FULLSTOP = 73;
  ALLEGRO_KEY_SLASH = 74;
  ALLEGRO_KEY_SPACE = 75;
  ALLEGRO_KEY_INSERT = 76;
  ALLEGRO_KEY_DELETE = 77;
  ALLEGRO_KEY_HOME = 78;
  ALLEGRO_KEY_END = 79;
  ALLEGRO_KEY_PGUP = 80;
  ALLEGRO_KEY_PGDN = 81;
  ALLEGRO_KEY_LEFT = 82;
  ALLEGRO_KEY_RIGHT = 83;
  ALLEGRO_KEY_UP = 84;
  ALLEGRO_KEY_DOWN = 85;
  ALLEGRO_KEY_PAD_SLASH = 86;
  ALLEGRO_KEY_PAD_ASTERISK = 87;
  ALLEGRO_KEY_PAD_MINUS = 88;
  ALLEGRO_KEY_PAD_PLUS = 89;
  ALLEGRO_KEY_PAD_DELETE = 90;
  ALLEGRO_KEY_PAD_ENTER = 91;
  ALLEGRO_KEY_PRINTSCREEN = 92;
  ALLEGRO_KEY_PAUSE = 93;
  ALLEGRO_KEY_ABNT_C1 = 94;
  ALLEGRO_KEY_YEN = 95;
  ALLEGRO_KEY_KANA = 96;
  ALLEGRO_KEY_CONVERT = 97;
  ALLEGRO_KEY_NOCONVERT = 98;
  ALLEGRO_KEY_AT = 99;
  ALLEGRO_KEY_CIRCUMFLEX = 100;
  ALLEGRO_KEY_COLON2 = 101;
  ALLEGRO_KEY_KANJI = 102;
  ALLEGRO_KEY_PAD_EQUALS = 103;
  ALLEGRO_KEY_BACKQUOTE = 104;
  ALLEGRO_KEY_SEMICOLON2 = 105;
  ALLEGRO_KEY_COMMAND = 106;
  ALLEGRO_KEY_BACK = 107;
  ALLEGRO_KEY_VOLUME_UP = 108;
  ALLEGRO_KEY_VOLUME_DOWN = 109;
  ALLEGRO_KEY_SEARCH = 110;
  ALLEGRO_KEY_DPAD_CENTER = 111;
  ALLEGRO_KEY_BUTTON_X = 112;
  ALLEGRO_KEY_BUTTON_Y = 113;
  ALLEGRO_KEY_DPAD_UP = 114;
  ALLEGRO_KEY_DPAD_DOWN = 115;
  ALLEGRO_KEY_DPAD_LEFT = 116;
  ALLEGRO_KEY_DPAD_RIGHT = 117;
  ALLEGRO_KEY_SELECT = 118;
  ALLEGRO_KEY_START = 119;
  ALLEGRO_KEY_BUTTON_L1 = 120;
  ALLEGRO_KEY_BUTTON_R1 = 121;
  ALLEGRO_KEY_BUTTON_L2 = 122;
  ALLEGRO_KEY_BUTTON_R2 = 123;
  ALLEGRO_KEY_BUTTON_A = 124;
  ALLEGRO_KEY_BUTTON_B = 125;
  ALLEGRO_KEY_THUMBL = 126;
  ALLEGRO_KEY_THUMBR = 127;
  ALLEGRO_KEY_UNKNOWN = 128;
  ALLEGRO_KEY_MODIFIERS = 215;
  ALLEGRO_KEY_LSHIFT = 215;
  ALLEGRO_KEY_RSHIFT = 216;
  ALLEGRO_KEY_LCTRL = 217;
  ALLEGRO_KEY_RCTRL = 218;
  ALLEGRO_KEY_ALT = 219;
  ALLEGRO_KEY_ALTGR = 220;
  ALLEGRO_KEY_LWIN = 221;
  ALLEGRO_KEY_RWIN = 222;
  ALLEGRO_KEY_MENU = 223;
  ALLEGRO_KEY_SCROLLLOCK = 224;
  ALLEGRO_KEY_NUMLOCK = 225;
  ALLEGRO_KEY_CAPSLOCK = 226;
  ALLEGRO_KEY_MAX = 227;

  ALLEGRO_KEYMOD_SHIFT = 1;
  ALLEGRO_KEYMOD_CTRL = 2;
  ALLEGRO_KEYMOD_ALT = 4;
  ALLEGRO_KEYMOD_LWIN = 8;
  ALLEGRO_KEYMOD_RWIN = 16;
  ALLEGRO_KEYMOD_MENU = 32;
  ALLEGRO_KEYMOD_ALTGR = 64;
  ALLEGRO_KEYMOD_COMMAND = 128;
  ALLEGRO_KEYMOD_SCROLLLOCK = 256;
  ALLEGRO_KEYMOD_NUMLOCK = 512;
  ALLEGRO_KEYMOD_CAPSLOCK = 1024;
  ALLEGRO_KEYMOD_INALTSEQ = 2048;
  ALLEGRO_KEYMOD_ACCENT1 = 4096;
  ALLEGRO_KEYMOD_ACCENT2 = 8192;
  ALLEGRO_KEYMOD_ACCENT3 = 16384;
  ALLEGRO_KEYMOD_ACCENT4 = 32768;

  ALLEGRO_MOUSE_EMULATION_NONE = 0;
  ALLEGRO_MOUSE_EMULATION_TRANSPARENT = 1;
  ALLEGRO_MOUSE_EMULATION_INCLUSIVE = 2;
  ALLEGRO_MOUSE_EMULATION_EXCLUSIVE = 3;
  ALLEGRO_MOUSE_EMULATION_5_0_x = 4;

  // Haptic
  ALLEGRO_HAPTIC_RUMBLE = 1;
  ALLEGRO_HAPTIC_PERIODIC = 2;
  ALLEGRO_HAPTIC_CONSTANT = 4;
  ALLEGRO_HAPTIC_SPRING = 8;
  ALLEGRO_HAPTIC_FRICTION = 16;
  ALLEGRO_HAPTIC_DAMPER = 32;
  ALLEGRO_HAPTIC_INERTIA = 64;
  ALLEGRO_HAPTIC_RAMP = 128;
  ALLEGRO_HAPTIC_SQUARE = 256;
  ALLEGRO_HAPTIC_TRIANGLE = 512;
  ALLEGRO_HAPTIC_SINE = 1024;
  ALLEGRO_HAPTIC_SAW_UP = 2048;
  ALLEGRO_HAPTIC_SAW_DOWN = 4096;
  ALLEGRO_HAPTIC_CUSTOM = 8192;
  ALLEGRO_HAPTIC_GAIN = 16384;
  ALLEGRO_HAPTIC_ANGLE = 32768;
  ALLEGRO_HAPTIC_RADIUS = 65536;
  ALLEGRO_HAPTIC_AZIMUTH = 131072;
  ALLEGRO_HAPTIC_AUTOCENTER = 262144;

  ALLEGRO_DEFAULT_DISPLAY_ADAPTER = -1;

  // Mouse cursor
  ALLEGRO_SYSTEM_MOUSE_CURSOR_NONE = 0;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_DEFAULT = 1;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ARROW = 2;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_BUSY = 3;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_QUESTION = 4;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_EDIT = 5;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_MOVE = 6;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_N = 7;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_W = 8;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_S = 9;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_E = 10;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NW = 11;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SW = 12;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_SE = 13;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_RESIZE_NE = 14;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PROGRESS = 15;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_PRECISION = 16;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_LINK = 17;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_ALT_SELECT = 18;
  ALLEGRO_SYSTEM_MOUSE_CURSOR_UNAVAILABLE = 19;
  ALLEGRO_NUM_SYSTEM_MOUSE_CURSORS = 20;

  // Color Mask
  ALLEGRO_MASK_RED = 1;
  ALLEGRO_MASK_GREEN = 2;
  ALLEGRO_MASK_BLUE = 4;
  ALLEGRO_MASK_ALPHA = 8;
  ALLEGRO_MASK_DEPTH = 16;
  ALLEGRO_MASK_RGB = 7;
  ALLEGRO_MASK_RGBA = 15;

  // Render
  ALLEGRO_RENDER_NEVER = 0;
  ALLEGRO_RENDER_ALWAYS = 1;
  ALLEGRO_RENDER_LESS = 2;
  ALLEGRO_RENDER_EQUAL = 3;
  ALLEGRO_RENDER_LESS_EQUAL = 4;
  ALLEGRO_RENDER_GREATER = 5;
  ALLEGRO_RENDER_NOT_EQUAL = 6;
  ALLEGRO_RENDER_GREATER_EQUAL = 7;

  ALLEGRO_VERTEX_SHADER = 1;
  ALLEGRO_PIXEL_SHADER = 2;

  // Sharder
  ALLEGRO_SHADER_AUTO = 0;
  ALLEGRO_SHADER_GLSL = 1;
  ALLEGRO_SHADER_HLSL = 2;
  ALLEGRO_SHADER_AUTO_MINIMAL = 3;
  ALLEGRO_SHADER_GLSL_MINIMAL = 4;
  ALLEGRO_SHADER_HLSL_MINIMAL = 5;
  ALLEGRO_SHADER_HLSL_SM_3_0 = 6;

  // System Id
  ALLEGRO_SYSTEM_ID_UNKNOWN = 0;
  ALLEGRO_SYSTEM_ID_XGLX = 1481067608;
  ALLEGRO_SYSTEM_ID_WINDOWS = 1464421956;
  ALLEGRO_SYSTEM_ID_MACOSX = 1330862112;
  ALLEGRO_SYSTEM_ID_ANDROID = 1095648338;
  ALLEGRO_SYSTEM_ID_IPHONE = 1229998159;
  ALLEGRO_SYSTEM_ID_GP2XWIZ = 1464424992;
  ALLEGRO_SYSTEM_ID_RASPBERRYPI = 1380012880;
  ALLEGRO_SYSTEM_ID_SDL = 1396984882;

  // System Paths
  ALLEGRO_RESOURCES_PATH = 0;
  ALLEGRO_TEMP_PATH = 1;
  ALLEGRO_USER_DATA_PATH = 2;
  ALLEGRO_USER_HOME_PATH = 3;
  ALLEGRO_USER_SETTINGS_PATH = 4;
  ALLEGRO_USER_DOCUMENTS_PATH = 5;
  ALLEGRO_EXENAME_PATH = 6;
  ALLEGRO_LAST_PATH = 7;

  // State
  ALLEGRO_STATE_NEW_DISPLAY_PARAMETERS = 1;
  ALLEGRO_STATE_NEW_BITMAP_PARAMETERS = 2;
  ALLEGRO_STATE_DISPLAY = 4;
  ALLEGRO_STATE_TARGET_BITMAP = 8;
  ALLEGRO_STATE_BLENDER = 16;
  ALLEGRO_STATE_NEW_FILE_INTERFACE = 32;
  ALLEGRO_STATE_TRANSFORM = 64;
  ALLEGRO_STATE_PROJECTION_TRANSFORM = 256;
  ALLEGRO_STATE_BITMAP = 10;
  ALLEGRO_STATE_ALL = 65535;

  _KCM_STREAM_FEEDER_QUIT_EVENT_TYPE = 512;
  ALLEGRO_EVENT_AUDIO_STREAM_FRAGMENT = 513;
  ALLEGRO_EVENT_AUDIO_STREAM_FINISHED = 514;
  ALLEGRO_EVENT_AUDIO_RECORDER_FRAGMENT = 515;

  ALLEGRO_AUDIO_DEPTH_INT8 = 0;
  ALLEGRO_AUDIO_DEPTH_INT16 = 1;
  ALLEGRO_AUDIO_DEPTH_INT24 = 2;
  ALLEGRO_AUDIO_DEPTH_FLOAT32 = 3;
  ALLEGRO_AUDIO_DEPTH_UNSIGNED = 8;
  ALLEGRO_AUDIO_DEPTH_UINT8 = 8;
  ALLEGRO_AUDIO_DEPTH_UINT16 = 9;
  ALLEGRO_AUDIO_DEPTH_UINT24 = 10;

  ALLEGRO_CHANNEL_CONF_1 = 16;
  ALLEGRO_CHANNEL_CONF_2 = 32;
  ALLEGRO_CHANNEL_CONF_3 = 48;
  ALLEGRO_CHANNEL_CONF_4 = 64;
  ALLEGRO_CHANNEL_CONF_5_1 = 81;
  ALLEGRO_CHANNEL_CONF_6_1 = 97;
  ALLEGRO_CHANNEL_CONF_7_1 = 113;

  ALLEGRO_PLAYMODE_ONCE = 256;
  ALLEGRO_PLAYMODE_LOOP = 257;
  ALLEGRO_PLAYMODE_BIDIR = 258;
  _ALLEGRO_PLAYMODE_STREAM_ONCE = 259;
  _ALLEGRO_PLAYMODE_STREAM_ONEDIR = 260;
  ALLEGRO_PLAYMODE_LOOP_ONCE = 261;
  _ALLEGRO_PLAYMODE_STREAM_LOOP_ONCE = 262;

  ALLEGRO_MIXER_QUALITY_POINT = 272;
  ALLEGRO_MIXER_QUALITY_LINEAR = 273;
  ALLEGRO_MIXER_QUALITY_CUBIC = 274;

  ALLEGRO_NO_KERNING = -1;
  ALLEGRO_ALIGN_LEFT = 0;
  ALLEGRO_ALIGN_CENTRE = 1;
  ALLEGRO_ALIGN_CENTER = 1;
  ALLEGRO_ALIGN_RIGHT = 2;
  ALLEGRO_ALIGN_INTEGER = 4;

  ALLEGRO_FILECHOOSER_FILE_MUST_EXIST = 1;
  ALLEGRO_FILECHOOSER_SAVE = 2;
  ALLEGRO_FILECHOOSER_FOLDER = 4;
  ALLEGRO_FILECHOOSER_PICTURES = 8;
  ALLEGRO_FILECHOOSER_SHOW_HIDDEN = 16;
  ALLEGRO_FILECHOOSER_MULTIPLE = 32;

  ALLEGRO_MESSAGEBOX_WARN = 1;
  ALLEGRO_MESSAGEBOX_ERROR = 2;
  ALLEGRO_MESSAGEBOX_OK_CANCEL = 4;
  ALLEGRO_MESSAGEBOX_YES_NO = 8;
  ALLEGRO_MESSAGEBOX_QUESTION = 16;

  ALLEGRO_TEXTLOG_NO_CLOSE = 1;
  ALLEGRO_TEXTLOG_MONOSPACE = 2;

  ALLEGRO_EVENT_NATIVE_DIALOG_CLOSE = 600;
  ALLEGRO_EVENT_MENU_CLICK = 601;

  ALLEGRO_MENU_ITEM_ENABLED = 0;
  ALLEGRO_MENU_ITEM_CHECKBOX = 1;
  ALLEGRO_MENU_ITEM_CHECKED = 2;
  ALLEGRO_MENU_ITEM_DISABLED = 4;

  ALLEGRO_PRIM_LINE_LIST = 0;
  ALLEGRO_PRIM_LINE_STRIP = 1;
  ALLEGRO_PRIM_LINE_LOOP = 2;
  ALLEGRO_PRIM_TRIANGLE_LIST = 3;
  ALLEGRO_PRIM_TRIANGLE_STRIP = 4;
  ALLEGRO_PRIM_TRIANGLE_FAN = 5;
  ALLEGRO_PRIM_POINT_LIST = 6;
  ALLEGRO_PRIM_NUM_TYPES = 7;

  ALLEGRO_PRIM_MAX_USER_ATTR = 10;

  ALLEGRO_PRIM_POSITION = 1;
  ALLEGRO_PRIM_COLOR_ATTR = 2;
  ALLEGRO_PRIM_TEX_COORD = 3;
  ALLEGRO_PRIM_TEX_COORD_PIXEL = 4;
  ALLEGRO_PRIM_USER_ATTR = 5;
  ALLEGRO_PRIM_ATTR_NUM = 15;

  ALLEGRO_PRIM_FLOAT_2 = 0;
  ALLEGRO_PRIM_FLOAT_3 = 1;
  ALLEGRO_PRIM_SHORT_2 = 2;
  ALLEGRO_PRIM_FLOAT_1 = 3;
  ALLEGRO_PRIM_FLOAT_4 = 4;
  ALLEGRO_PRIM_UBYTE_4 = 5;
  ALLEGRO_PRIM_SHORT_4 = 6;
  ALLEGRO_PRIM_NORMALIZED_UBYTE_4 = 7;
  ALLEGRO_PRIM_NORMALIZED_SHORT_2 = 8;
  ALLEGRO_PRIM_NORMALIZED_SHORT_4 = 9;
  ALLEGRO_PRIM_NORMALIZED_USHORT_2 = 10;
  ALLEGRO_PRIM_NORMALIZED_USHORT_4 = 11;
  ALLEGRO_PRIM_HALF_FLOAT_2 = 12;
  ALLEGRO_PRIM_HALF_FLOAT_4 = 13;

  ALLEGRO_LINE_JOIN_NONE = 0;
  ALLEGRO_LINE_JOIN_BEVEL = 1;
  ALLEGRO_LINE_JOIN_ROUND = 2;
  ALLEGRO_LINE_JOIN_MITER = 3;
  ALLEGRO_LINE_JOIN_MITRE = 3;

  ALLEGRO_LINE_CAP_NONE = 0;
  ALLEGRO_LINE_CAP_SQUARE = 1;
  ALLEGRO_LINE_CAP_ROUND = 2;
  ALLEGRO_LINE_CAP_TRIANGLE = 3;
  ALLEGRO_LINE_CAP_CLOSED = 4;

  // Primitive buffer
  ALLEGRO_PRIM_BUFFER_STREAM = 1;
  ALLEGRO_PRIM_BUFFER_STATIC = 2;
  ALLEGRO_PRIM_BUFFER_DYNAMIC = 4;
  ALLEGRO_PRIM_BUFFER_READWRITE = 8;

  // Event
  ALLEGRO_EVENT_VIDEO_FRAME_SHOW = 550;
  ALLEGRO_EVENT_VIDEO_FINISHED = 551;
  _ALLEGRO_EVENT_VIDEO_SEEK = 552;

  // Video
  ALLEGRO_VIDEO_POSITION_ACTUAL = 0;
  ALLEGRO_VIDEO_POSITION_VIDEO_DECODE = 1;
  ALLEGRO_VIDEO_POSITION_AUDIO_DECODE = 2;

  ALLEGRO_RED_SIZE = 0;
  ALLEGRO_GREEN_SIZE = 1;
  ALLEGRO_BLUE_SIZE = 2;
  ALLEGRO_ALPHA_SIZE = 3;
  ALLEGRO_RED_SHIFT = 4;
  ALLEGRO_GREEN_SHIFT = 5;
  ALLEGRO_BLUE_SHIFT = 6;
  ALLEGRO_ALPHA_SHIFT = 7;
  ALLEGRO_ACC_RED_SIZE = 8;
  ALLEGRO_ACC_GREEN_SIZE = 9;
  ALLEGRO_ACC_BLUE_SIZE = 10;
  ALLEGRO_ACC_ALPHA_SIZE = 11;
  ALLEGRO_STEREO = 12;
  ALLEGRO_AUX_BUFFERS = 13;
  ALLEGRO_COLOR_SIZE = 14;
  ALLEGRO_DEPTH_SIZE = 15;
  ALLEGRO_STENCIL_SIZE = 16;
  ALLEGRO_SAMPLE_BUFFERS = 17;
  ALLEGRO_SAMPLES = 18;
  ALLEGRO_RENDER_METHOD = 19;
  ALLEGRO_FLOAT_COLOR = 20;
  ALLEGRO_FLOAT_DEPTH = 21;
  ALLEGRO_SINGLE_BUFFER = 22;
  ALLEGRO_SWAP_METHOD = 23;
  ALLEGRO_COMPATIBLE_DISPLAY = 24;
  ALLEGRO_UPDATE_DISPLAY_REGION = 25;
  ALLEGRO_VSYNC = 26;
  ALLEGRO_MAX_BITMAP_SIZE = 27;
  ALLEGRO_SUPPORT_NPOT_BITMAP = 28;
  ALLEGRO_CAN_DRAW_INTO_BITMAP = 29;
  ALLEGRO_SUPPORT_SEPARATE_ALPHA = 30;
  ALLEGRO_AUTO_CONVERT_BITMAPS = 31;
  ALLEGRO_SUPPORTED_ORIENTATIONS = 32;
  ALLEGRO_OPENGL_MAJOR_VERSION = 33;
  ALLEGRO_OPENGL_MINOR_VERSION = 34;
  ALLEGRO_DEFAULT_SHADER_PLATFORM = 35;
  ALLEGRO_DISPLAY_OPTIONS_COUNT = 36;

  ALLEGRO_ALPHA_TEST = 16;
  ALLEGRO_WRITE_MASK = 17;
  ALLEGRO_DEPTH_TEST = 18;
  ALLEGRO_DEPTH_FUNCTION = 19;
  ALLEGRO_ALPHA_FUNCTION = 20;
  ALLEGRO_ALPHA_TEST_VALUE = 21;

  // ZLib
  Z_DEFLATED = 8;
  Z_DEFAULT_STRATEGY = 0;
  APPEND_STATUS_CREATE = 0;
  Z_OK = 0;

type

  { ALLEGRO_PIXEL_FORMAT }
  ALLEGRO_PIXEL_FORMAT = Integer;

  { PALLEGRO_PIXEL_FORMAT }
  PALLEGRO_PIXEL_FORMAT = ^ALLEGRO_PIXEL_FORMAT;

  { ALLEGRO_BITMAP_WRAP }
  ALLEGRO_BITMAP_WRAP = Integer;

  { PALLEGRO_BITMAP_WRAP }
  PALLEGRO_BITMAP_WRAP = ^ALLEGRO_BITMAP_WRAP;

  { ALLEGRO_SEEK }
  ALLEGRO_SEEK = Integer;

  { PALLEGRO_SEEK }
  PALLEGRO_SEEK = ^ALLEGRO_SEEK;

  { ALLEGRO_BLEND_MODE }
  ALLEGRO_BLEND_MODE = Integer;

  { PALLEGRO_BLEND_MODE }
  PALLEGRO_BLEND_MODE = ^ALLEGRO_BLEND_MODE;

  { ALLEGRO_BLEND_OPERATIONS }
  ALLEGRO_BLEND_OPERATIONS = Integer;

  { PALLEGRO_BLEND_OPERATIONS }
  PALLEGRO_BLEND_OPERATIONS = ^ALLEGRO_BLEND_OPERATIONS;

  { ALLEGRO_DISPLAY_OPTIONS }
  ALLEGRO_DISPLAY_OPTIONS = Integer;

  { PALLEGRO_DISPLAY_OPTIONS }
  PALLEGRO_DISPLAY_OPTIONS = ^ALLEGRO_DISPLAY_OPTIONS;

  { ALLEGRO_DISPLAY_ORIENTATION }
  ALLEGRO_DISPLAY_ORIENTATION = Integer;

  { PALLEGRO_DISPLAY_ORIENTATION }
  PALLEGRO_DISPLAY_ORIENTATION = ^ALLEGRO_DISPLAY_ORIENTATION;

  { ALLEGRO_FILE_MODE }
  ALLEGRO_FILE_MODE = Integer;

  { PALLEGRO_FILE_MODE }
  PALLEGRO_FILE_MODE = ^ALLEGRO_FILE_MODE;

  { ALLEGRO_FOR_EACH_FS_ENTRY_RESULT }
  ALLEGRO_FOR_EACH_FS_ENTRY_RESULT = Integer;

  { PALLEGRO_FOR_EACH_FS_ENTRY_RESULT }
  PALLEGRO_FOR_EACH_FS_ENTRY_RESULT = ^ALLEGRO_FOR_EACH_FS_ENTRY_RESULT;

  { ALLEGRO_JOYFLAGS }
  ALLEGRO_JOYFLAGS = Integer;

  { PALLEGRO_JOYFLAGS }
  PALLEGRO_JOYFLAGS = ^ALLEGRO_JOYFLAGS;

  { ALLEGRO_MOUSE_EMULATION_MODE }
  ALLEGRO_MOUSE_EMULATION_MODE = Integer;

  { PALLEGRO_MOUSE_EMULATION_MODE }
  PALLEGRO_MOUSE_EMULATION_MODE = ^ALLEGRO_MOUSE_EMULATION_MODE;

  { ALLEGRO_HAPTIC_CONSTANTS }
  ALLEGRO_HAPTIC_CONSTANTS = Integer;

  { PALLEGRO_HAPTIC_CONSTANTS }
  PALLEGRO_HAPTIC_CONSTANTS = ^ALLEGRO_HAPTIC_CONSTANTS;

  { ALLEGRO_SYSTEM_MOUSE_CURSOR }
  ALLEGRO_SYSTEM_MOUSE_CURSOR = Integer;

  { PALLEGRO_SYSTEM_MOUSE_CURSOR }
  PALLEGRO_SYSTEM_MOUSE_CURSOR = ^ALLEGRO_SYSTEM_MOUSE_CURSOR;

  { ALLEGRO_RENDER_STATE }
  ALLEGRO_RENDER_STATE = Integer;

  { PALLEGRO_RENDER_STATE }
  PALLEGRO_RENDER_STATE = ^ALLEGRO_RENDER_STATE;

  { ALLEGRO_RENDER_FUNCTION }
  ALLEGRO_RENDER_FUNCTION = Integer;

  { PALLEGRO_RENDER_FUNCTION }
  PALLEGRO_RENDER_FUNCTION = ^ALLEGRO_RENDER_FUNCTION;

  { ALLEGRO_WRITE_MASK_FLAGS }
  ALLEGRO_WRITE_MASK_FLAGS = Integer;

  { PALLEGRO_WRITE_MASK_FLAGS }
  PALLEGRO_WRITE_MASK_FLAGS = ^ALLEGRO_WRITE_MASK_FLAGS;

  { ALLEGRO_SHADER_TYPE }
  ALLEGRO_SHADER_TYPE = Integer;

  { PALLEGRO_SHADER_TYPE }
  PALLEGRO_SHADER_TYPE = ^ALLEGRO_SHADER_TYPE;

  { ALLEGRO_SHADER_PLATFORM }
  ALLEGRO_SHADER_PLATFORM = Integer;

  { PALLEGRO_SHADER_PLATFORM }
  PALLEGRO_SHADER_PLATFORM = ^ALLEGRO_SHADER_PLATFORM;

  { ALLEGRO_SYSTEM_ID }
  ALLEGRO_SYSTEM_ID = Integer;

  { PALLEGRO_SYSTEM_ID }
  PALLEGRO_SYSTEM_ID = ^ALLEGRO_SYSTEM_ID;

  { ALLEGRO_STATE_FLAGS }
  ALLEGRO_STATE_FLAGS = Integer;

  { PALLEGRO_STATE_FLAGS }
  PALLEGRO_STATE_FLAGS = ^ALLEGRO_STATE_FLAGS;

  { ALLEGRO_AUDIO_EVENT_TYPE }
  ALLEGRO_AUDIO_EVENT_TYPE = Integer;

  { PALLEGRO_AUDIO_EVENT_TYPE }
  PALLEGRO_AUDIO_EVENT_TYPE = ^ALLEGRO_AUDIO_EVENT_TYPE;

  { ALLEGRO_AUDIO_DEPTH }
  ALLEGRO_AUDIO_DEPTH = Integer;

  { PALLEGRO_AUDIO_DEPTH }
  PALLEGRO_AUDIO_DEPTH = ^ALLEGRO_AUDIO_DEPTH;

  { ALLEGRO_CHANNEL_CONF }
  ALLEGRO_CHANNEL_CONF = Integer;

  { PALLEGRO_CHANNEL_CONF }
  PALLEGRO_CHANNEL_CONF = ^ALLEGRO_CHANNEL_CONF;

  { ALLEGRO_PLAYMODE }
  ALLEGRO_PLAYMODE = Integer;

  { PALLEGRO_PLAYMODE }
  PALLEGRO_PLAYMODE = ^ALLEGRO_PLAYMODE;

  { ALLEGRO_MIXER_QUALITY }
  ALLEGRO_MIXER_QUALITY = Integer;

  { PALLEGRO_MIXER_QUALITY }
  PALLEGRO_MIXER_QUALITY = ^ALLEGRO_MIXER_QUALITY;

  { ALLEGRO_PRIM_TYPE }
  ALLEGRO_PRIM_TYPE = Integer;

  { PALLEGRO_PRIM_TYPE }
  PALLEGRO_PRIM_TYPE = ^ALLEGRO_PRIM_TYPE;

  { ALLEGRO_PRIM_ATTR }
  ALLEGRO_PRIM_ATTR = Integer;

  { PALLEGRO_PRIM_ATTR }
  PALLEGRO_PRIM_ATTR = ^ALLEGRO_PRIM_ATTR;

  { ALLEGRO_PRIM_STORAGE }
  ALLEGRO_PRIM_STORAGE = Integer;

  { PALLEGRO_PRIM_STORAGE }
  PALLEGRO_PRIM_STORAGE = ^ALLEGRO_PRIM_STORAGE;

  { ALLEGRO_LINE_JOIN }
  ALLEGRO_LINE_JOIN = Integer;

  { PALLEGRO_LINE_JOIN }
  PALLEGRO_LINE_JOIN = ^ALLEGRO_LINE_JOIN;

  { ALLEGRO_LINE_CAP }
  ALLEGRO_LINE_CAP = Integer;

  { PALLEGRO_LINE_CAP }
  PALLEGRO_LINE_CAP = ^ALLEGRO_LINE_CAP;

  { ALLEGRO_PRIM_BUFFER_FLAGS }
  ALLEGRO_PRIM_BUFFER_FLAGS = Integer;

  { PALLEGRO_PRIM_BUFFER_FLAGS }
  PALLEGRO_PRIM_BUFFER_FLAGS = ^ALLEGRO_PRIM_BUFFER_FLAGS;

  { ALLEGRO_VIDEO_EVENT_TYPE }
  ALLEGRO_VIDEO_EVENT_TYPE = Integer;

  { PALLEGRO_VIDEO_EVENT_TYPE }
  PALLEGRO_VIDEO_EVENT_TYPE = ^ALLEGRO_VIDEO_EVENT_TYPE;

  { ALLEGRO_VIDEO_POSITION_TYPE }
  ALLEGRO_VIDEO_POSITION_TYPE = Integer;

  { PALLEGRO_VIDEO_POSITION_TYPE }
  PALLEGRO_VIDEO_POSITION_TYPE = ^ALLEGRO_VIDEO_POSITION_TYPE;

  { PPUTF8Char }
  PPUTF8Char = ^PUTF8Char;

  { PUInt16 }
  PUInt16 = ^UInt16;

  { PALLEGRO_USER_EVENT_DESCRIPTOR }
  PALLEGRO_USER_EVENT_DESCRIPTOR = Pointer;

  { PPALLEGRO_USER_EVENT_DESCRIPTOR }
  PPALLEGRO_USER_EVENT_DESCRIPTOR = ^PALLEGRO_USER_EVENT_DESCRIPTOR;

  { PALLEGRO_JOYSTICK_DRIVER }
  PALLEGRO_JOYSTICK_DRIVER = Pointer;

  { PPALLEGRO_JOYSTICK_DRIVER }
  PPALLEGRO_JOYSTICK_DRIVER = ^PALLEGRO_JOYSTICK_DRIVER;

  { PALLEGRO_HAPTIC_DRIVER }
  PALLEGRO_HAPTIC_DRIVER = Pointer;

  { PPALLEGRO_HAPTIC_DRIVER }
  PPALLEGRO_HAPTIC_DRIVER = ^PALLEGRO_HAPTIC_DRIVER;

  { PALLEGRO_TIMEOUT }
  PALLEGRO_TIMEOUT = ^ALLEGRO_TIMEOUT;

  { PALLEGRO_COLOR }
  PALLEGRO_COLOR = ^ALLEGRO_COLOR;

  { P_al_tagbstring }
  P_al_tagbstring = ^_al_tagbstring;

  { PALLEGRO_FILE_INTERFACE }
  PALLEGRO_FILE_INTERFACE = ^ALLEGRO_FILE_INTERFACE;

  { PALLEGRO_LOCKED_REGION }
  PALLEGRO_LOCKED_REGION = ^ALLEGRO_LOCKED_REGION;

  { PALLEGRO_EVENT_SOURCE }
  PALLEGRO_EVENT_SOURCE = ^ALLEGRO_EVENT_SOURCE;

  { PALLEGRO_ANY_EVENT }
  PALLEGRO_ANY_EVENT = ^ALLEGRO_ANY_EVENT;

  { PALLEGRO_DISPLAY_EVENT }
  PALLEGRO_DISPLAY_EVENT = ^ALLEGRO_DISPLAY_EVENT;

  { PALLEGRO_JOYSTICK_EVENT }
  PALLEGRO_JOYSTICK_EVENT = ^ALLEGRO_JOYSTICK_EVENT;

  { PALLEGRO_KEYBOARD_EVENT }
  PALLEGRO_KEYBOARD_EVENT = ^ALLEGRO_KEYBOARD_EVENT;

  { PALLEGRO_MOUSE_EVENT }
  PALLEGRO_MOUSE_EVENT = ^ALLEGRO_MOUSE_EVENT;

  { PALLEGRO_TIMER_EVENT }
  PALLEGRO_TIMER_EVENT = ^ALLEGRO_TIMER_EVENT;

  { PALLEGRO_TOUCH_EVENT }
  PALLEGRO_TOUCH_EVENT = ^ALLEGRO_TOUCH_EVENT;

  { PALLEGRO_USER_EVENT }
  PALLEGRO_USER_EVENT = ^ALLEGRO_USER_EVENT;

  { PALLEGRO_FS_ENTRY }
  PALLEGRO_FS_ENTRY = ^ALLEGRO_FS_ENTRY;

  { PALLEGRO_FS_INTERFACE }
  PALLEGRO_FS_INTERFACE = ^ALLEGRO_FS_INTERFACE;

  { PALLEGRO_DISPLAY_MODE }
  PALLEGRO_DISPLAY_MODE = ^ALLEGRO_DISPLAY_MODE;

  { PALLEGRO_JOYSTICK_STATE }
  PALLEGRO_JOYSTICK_STATE = ^ALLEGRO_JOYSTICK_STATE;

  { PALLEGRO_KEYBOARD_STATE }
  PALLEGRO_KEYBOARD_STATE = ^ALLEGRO_KEYBOARD_STATE;

  { PALLEGRO_MOUSE_STATE }
  PALLEGRO_MOUSE_STATE = ^ALLEGRO_MOUSE_STATE;

  { PALLEGRO_TOUCH_STATE }
  PALLEGRO_TOUCH_STATE = ^ALLEGRO_TOUCH_STATE;
  PALLEGRO_TOUCH_INPUT_STATE = ^ALLEGRO_TOUCH_INPUT_STATE;

  { PALLEGRO_HAPTIC_DIRECTION }
  PALLEGRO_HAPTIC_DIRECTION = ^ALLEGRO_HAPTIC_DIRECTION;

  { PALLEGRO_HAPTIC_REPLAY }
  PALLEGRO_HAPTIC_REPLAY = ^ALLEGRO_HAPTIC_REPLAY;

  { PALLEGRO_HAPTIC_ENVELOPE }
  PALLEGRO_HAPTIC_ENVELOPE = ^ALLEGRO_HAPTIC_ENVELOPE;

  { PALLEGRO_HAPTIC_CONSTANT_EFFECT }
  PALLEGRO_HAPTIC_CONSTANT_EFFECT = ^ALLEGRO_HAPTIC_CONSTANT_EFFECT;

  { PALLEGRO_HAPTIC_RAMP_EFFECT }
  PALLEGRO_HAPTIC_RAMP_EFFECT = ^ALLEGRO_HAPTIC_RAMP_EFFECT;

  { PALLEGRO_HAPTIC_CONDITION_EFFECT }
  PALLEGRO_HAPTIC_CONDITION_EFFECT = ^ALLEGRO_HAPTIC_CONDITION_EFFECT;

  { PALLEGRO_HAPTIC_PERIODIC_EFFECT }
  PALLEGRO_HAPTIC_PERIODIC_EFFECT = ^ALLEGRO_HAPTIC_PERIODIC_EFFECT;

  { PALLEGRO_HAPTIC_RUMBLE_EFFECT }
  PALLEGRO_HAPTIC_RUMBLE_EFFECT = ^ALLEGRO_HAPTIC_RUMBLE_EFFECT;

  { PALLEGRO_HAPTIC_EFFECT }
  PALLEGRO_HAPTIC_EFFECT = ^ALLEGRO_HAPTIC_EFFECT;

  { PALLEGRO_HAPTIC_EFFECT_ID }
  PALLEGRO_HAPTIC_EFFECT_ID = ^ALLEGRO_HAPTIC_EFFECT_ID;

  { PALLEGRO_MEMORY_INTERFACE }
  PALLEGRO_MEMORY_INTERFACE = ^ALLEGRO_MEMORY_INTERFACE;

  { PALLEGRO_MONITOR_INFO }
  PALLEGRO_MONITOR_INFO = ^ALLEGRO_MONITOR_INFO;

  { PALLEGRO_TRANSFORM }
  PALLEGRO_TRANSFORM = ^ALLEGRO_TRANSFORM;

  { PALLEGRO_STATE }
  PALLEGRO_STATE = ^ALLEGRO_STATE;

  { PALLEGRO_AUDIO_RECORDER_EVENT }
  PALLEGRO_AUDIO_RECORDER_EVENT = ^ALLEGRO_AUDIO_RECORDER_EVENT;

  { PALLEGRO_SAMPLE_ID }
  PALLEGRO_SAMPLE_ID = ^ALLEGRO_SAMPLE_ID;

  { PALLEGRO_GLYPH }
  PALLEGRO_GLYPH = ^ALLEGRO_GLYPH;

  { PALLEGRO_MENU_INFO }
  PALLEGRO_MENU_INFO = ^ALLEGRO_MENU_INFO;

  { PALLEGRO_VERTEX_ELEMENT }
  PALLEGRO_VERTEX_ELEMENT = ^ALLEGRO_VERTEX_ELEMENT;

  { PALLEGRO_VERTEX }
  PALLEGRO_VERTEX = ^ALLEGRO_VERTEX;

  { ALLEGRO_TIMEOUT  }
  ALLEGRO_TIMEOUT = record
    __pad1__: UInt64;
    __pad2__: UInt64;
  end;

  { ALLEGRO_COLOR }
  ALLEGRO_COLOR = record
    r: Single;
    g: Single;
    b: Single;
    a: Single;
  end;

  { PALLEGRO_BITMAP }
  PALLEGRO_BITMAP = Pointer;
  PPALLEGRO_BITMAP = ^PALLEGRO_BITMAP;

  { PALLEGRO_USTR }
  PALLEGRO_USTR = ^ALLEGRO_USTR;

  { _al_tagbstring }
  _al_tagbstring = record
    mlen: Integer;
    slen: Integer;
    data: PByte;
  end;

  { PALLEGRO_USTR_INFO }
  PALLEGRO_USTR_INFO = ^ALLEGRO_USTR_INFO;

  { ALLEGRO_USTR_INFO }
  ALLEGRO_USTR_INFO = _al_tagbstring;

  { ALLEGRO_USTR }
  ALLEGRO_USTR = _al_tagbstring;

  { PALLEGRO_PATH }
  PALLEGRO_PATH = Pointer;

  { PPALLEGRO_PATH }
  PPALLEGRO_PATH = ^PALLEGRO_PATH;

  { PALLEGRO_FILE }
  PALLEGRO_FILE = Pointer;

  { PPALLEGRO_FILE }
  PPALLEGRO_FILE = ^PALLEGRO_FILE;

  { off_t }
  off_t = longint;

  { ALLEGRO_FILE_INTERFACE }
  ALLEGRO_FILE_INTERFACE = record
    fi_fopen: function(const path: PUTF8Char; const mode: PUTF8Char): Pointer; cdecl;
    fi_fclose: function(handle: PALLEGRO_FILE): Boolean; cdecl;
    fi_fread: function(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fwrite: function(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl;
    fi_fflush: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ftell: function(f: PALLEGRO_FILE): Int64; cdecl;
    fi_fseek: function(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl;
    fi_feof: function(f: PALLEGRO_FILE): Boolean; cdecl;
    fi_ferror: function(f: PALLEGRO_FILE): Integer; cdecl;
    fi_ferrmsg: function(f: PALLEGRO_FILE): PUTF8Char; cdecl;
    fi_fclearerr: procedure(f: PALLEGRO_FILE); cdecl;
    fi_fungetc: function(f: PALLEGRO_FILE; c: Integer): Integer; cdecl;
    fi_fsize: function(f: PALLEGRO_FILE): off_t; cdecl;
  end;

  { ALLEGRO_IIO_LOADER_FUNCTION }
  ALLEGRO_IIO_LOADER_FUNCTION = function(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl;

  { ALLEGRO_IIO_FS_LOADER_FUNCTION }
  ALLEGRO_IIO_FS_LOADER_FUNCTION = function(fp: PALLEGRO_FILE; flags: Integer): PALLEGRO_BITMAP; cdecl;

  { ALLEGRO_IIO_SAVER_FUNCTION }
  ALLEGRO_IIO_SAVER_FUNCTION = function(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;

  { ALLEGRO_IIO_FS_SAVER_FUNCTION }
  ALLEGRO_IIO_FS_SAVER_FUNCTION = function(fp: PALLEGRO_FILE; bitmap: PALLEGRO_BITMAP): Boolean; cdecl;

  { ALLEGRO_IIO_IDENTIFIER_FUNCTION }
  ALLEGRO_IIO_IDENTIFIER_FUNCTION = function(f: PALLEGRO_FILE): Boolean; cdecl;

  { ALLEGRO_LOCKED_REGION }
  ALLEGRO_LOCKED_REGION = record
    data: Pointer;
    format: Integer;
    pitch: Integer;
    pixel_size: Integer;
  end;

  { ALLEGRO_EVENT_TYPE }
  ALLEGRO_EVENT_TYPE = Cardinal;

  { ALLEGRO_EVENT_SOURCE }
  ALLEGRO_EVENT_SOURCE = record
    __pad: array [0..31] of Integer;
  end;

  { ALLEGRO_ANY_EVENT }
  ALLEGRO_ANY_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
  end;

  { PALLEGRO_DISPLAY }
  PALLEGRO_DISPLAY = Pointer;
  PPALLEGRO_DISPLAY = ^PALLEGRO_DISPLAY;

  { PALLEGRO_JOYSTICK }
  PALLEGRO_JOYSTICK = Pointer;

  { PPALLEGRO_JOYSTICK }
  PPALLEGRO_JOYSTICK = ^PALLEGRO_JOYSTICK;

  { PALLEGRO_KEYBOARD }
  PALLEGRO_KEYBOARD = Pointer;

  { PPALLEGRO_KEYBOARD }
  PPALLEGRO_KEYBOARD = ^PALLEGRO_KEYBOARD;

  { PALLEGRO_MOUSE }
  PALLEGRO_MOUSE = Pointer;

  { PPALLEGRO_MOUSE }
  PPALLEGRO_MOUSE = ^PALLEGRO_MOUSE;

  { PALLEGRO_TIMER }
  PALLEGRO_TIMER = Pointer;

  { PPALLEGRO_TIMER }
  PPALLEGRO_TIMER = ^PALLEGRO_TIMER;

  { PALLEGRO_TOUCH_INPUT }
  PALLEGRO_TOUCH_INPUT = Pointer;

  { PPALLEGRO_TOUCH_INPUT }
  PPALLEGRO_TOUCH_INPUT = ^PALLEGRO_TOUCH_INPUT;

  { ALLEGRO_DISPLAY_EVENT }
  ALLEGRO_DISPLAY_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_DISPLAY;
    timestamp: Double;
    x: Integer;
    y: Integer;
    width: Integer;
    height: Integer;
    orientation: Integer;
  end;

  { ALLEGRO_JOYSTICK_EVENT }
  ALLEGRO_JOYSTICK_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_JOYSTICK;
    timestamp: Double;
    id: PALLEGRO_JOYSTICK;
    stick: Integer;
    axis: Integer;
    pos: Single;
    button: Integer;
  end;

  { ALLEGRO_KEYBOARD_EVENT }
  ALLEGRO_KEYBOARD_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_KEYBOARD;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    keycode: Integer;
    unichar: Integer;
    modifiers: Cardinal;
    repeat_: Boolean;
  end;

  { ALLEGRO_MOUSE_EVENT }
  ALLEGRO_MOUSE_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_MOUSE;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    dx: Integer;
    dy: Integer;
    dz: Integer;
    dw: Integer;
    button: Cardinal;
    pressure: Single;
  end;

  { ALLEGRO_TIMER_EVENT }
  ALLEGRO_TIMER_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TIMER;
    timestamp: Double;
    count: Int64;
    error: Double;
  end;

  { ALLEGRO_TOUCH_EVENT }
  ALLEGRO_TOUCH_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_TOUCH_INPUT;
    timestamp: Double;
    display: PALLEGRO_DISPLAY;
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
  end;

  { ALLEGRO_USER_EVENT }
  ALLEGRO_USER_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_EVENT_SOURCE;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    data1: IntPtr;
    data2: IntPtr;
    data3: IntPtr;
    data4: IntPtr;
  end;

  { PALLEGRO_EVENT }
  PALLEGRO_EVENT = ^ALLEGRO_EVENT;

  { ALLEGRO_EVENT }
  ALLEGRO_EVENT = record
    case Integer of
      0: (type_: ALLEGRO_EVENT_TYPE);
      1: (any: ALLEGRO_ANY_EVENT);
      2: (display: ALLEGRO_DISPLAY_EVENT);
      3: (joystick: ALLEGRO_JOYSTICK_EVENT);
      4: (keyboard: ALLEGRO_KEYBOARD_EVENT);
      5: (mouse: ALLEGRO_MOUSE_EVENT);
      6: (timer: ALLEGRO_TIMER_EVENT);
      7: (touch: ALLEGRO_TOUCH_EVENT);
      8: (user: ALLEGRO_USER_EVENT);
  end;

  { PALLEGRO_EVENT_QUEUE }
  PALLEGRO_EVENT_QUEUE = Pointer;

  { PPALLEGRO_EVENT_QUEUE }
  PPALLEGRO_EVENT_QUEUE = ^PALLEGRO_EVENT_QUEUE;

  { PALLEGRO_CONFIG }
  PALLEGRO_CONFIG = Pointer;

  { PPALLEGRO_CONFIG }
  PPALLEGRO_CONFIG = ^PALLEGRO_CONFIG;

  { PALLEGRO_CONFIG_SECTION }
  PALLEGRO_CONFIG_SECTION = Pointer;

  { PPALLEGRO_CONFIG_SECTION }
  PPALLEGRO_CONFIG_SECTION = ^PALLEGRO_CONFIG_SECTION;

  { PALLEGRO_CONFIG_ENTRY }
  PALLEGRO_CONFIG_ENTRY = Pointer;

  { PPALLEGRO_CONFIG_ENTRY }
  PPALLEGRO_CONFIG_ENTRY = ^PALLEGRO_CONFIG_ENTRY;

  { al_fixed }
  al_fixed = Int32;

  { ALLEGRO_FS_ENTRY }
  ALLEGRO_FS_ENTRY = record
    vtable: PALLEGRO_FS_INTERFACE;
  end;

  { ALLEGRO_FS_INTERFACE }
  ALLEGRO_FS_INTERFACE = record
    fs_create_entry: function(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl;
    fs_destroy_entry: procedure(e: PALLEGRO_FS_ENTRY); cdecl;
    fs_entry_name: function(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl;
    fs_update_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_entry_mode: function(e: PALLEGRO_FS_ENTRY): UInt32; cdecl;
    fs_entry_atime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_mtime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_ctime: function(e: PALLEGRO_FS_ENTRY): Longint; cdecl;
    fs_entry_size: function(e: PALLEGRO_FS_ENTRY): off_t; cdecl;
    fs_entry_exists: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_remove_entry: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_open_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_read_directory: function(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl;
    fs_close_directory: function(e: PALLEGRO_FS_ENTRY): Boolean; cdecl;
    fs_filename_exists: function(const path: PUTF8Char): Boolean; cdecl;
    fs_remove_filename: function(const path: PUTF8Char): Boolean; cdecl;
    fs_get_current_directory: function(): PUTF8Char; cdecl;
    fs_change_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_make_directory: function(const path: PUTF8Char): Boolean; cdecl;
    fs_open_file: function(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl;
  end;

  { ALLEGRO_DISPLAY_MODE }
  ALLEGRO_DISPLAY_MODE = record
    width: Integer;
    height: Integer;
    format: Integer;
    refresh_rate: Integer;
  end;

  { ALLEGRO_JOYSTICK_STATE_AXIS }
  ALLEGRO_JOYSTICK_STATE_AXIS = record
    axis: array [0..2] of Single;
  end;

  { ALLEGRO_JOYSTICK_STATE }
  ALLEGRO_JOYSTICK_STATE = record
    stick: array [0..15] of ALLEGRO_JOYSTICK_STATE_AXIS;
    button: array [0..31] of Integer;
  end;

  { ALLEGRO_KEYBOARD_STATE }
  ALLEGRO_KEYBOARD_STATE = record
    display: PALLEGRO_DISPLAY;
    __key_down__internal__: array [0..7] of Cardinal;
  end;

  { ALLEGRO_MOUSE_STATE }
  ALLEGRO_MOUSE_STATE = record
    x: Integer;
    y: Integer;
    z: Integer;
    w: Integer;
    more_axes: array [0..3] of Integer;
    buttons: Integer;
    pressure: Single;
    display: PALLEGRO_DISPLAY;
  end;

  { ALLEGRO_TOUCH_STATE }
  ALLEGRO_TOUCH_STATE = record
    id: Integer;
    x: Single;
    y: Single;
    dx: Single;
    dy: Single;
    primary: Boolean;
    display: PALLEGRO_DISPLAY;
  end;

  { ALLEGRO_TOUCH_INPUT_STATE }
  ALLEGRO_TOUCH_INPUT_STATE = record
    touches: array [0..15] of ALLEGRO_TOUCH_STATE;
  end;

  { PALLEGRO_HAPTIC }
  PALLEGRO_HAPTIC = Pointer;

  { PPALLEGRO_HAPTIC }
  PPALLEGRO_HAPTIC = ^PALLEGRO_HAPTIC;

  { ALLEGRO_HAPTIC_DIRECTION }
  ALLEGRO_HAPTIC_DIRECTION = record
    angle: Double;
    radius: Double;
    azimuth: Double;
  end;

  { ALLEGRO_HAPTIC_REPLAY }
  ALLEGRO_HAPTIC_REPLAY = record
    length: Double;
    delay: Double;
  end;

  { ALLEGRO_HAPTIC_ENVELOPE }
  ALLEGRO_HAPTIC_ENVELOPE = record
    attack_length: Double;
    attack_level: Double;
    fade_length: Double;
    fade_level: Double;
  end;

  { ALLEGRO_HAPTIC_CONSTANT_EFFECT }
  ALLEGRO_HAPTIC_CONSTANT_EFFECT = record
    level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  { ALLEGRO_HAPTIC_RAMP_EFFECT }
  ALLEGRO_HAPTIC_RAMP_EFFECT = record
    start_level: Double;
    end_level: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
  end;

  { ALLEGRO_HAPTIC_CONDITION_EFFECT }
  ALLEGRO_HAPTIC_CONDITION_EFFECT = record
    right_saturation: Double;
    left_saturation: Double;
    right_coeff: Double;
    left_coeff: Double;
    deadband: Double;
    center: Double;
  end;

  { ALLEGRO_HAPTIC_PERIODIC_EFFECT }
  ALLEGRO_HAPTIC_PERIODIC_EFFECT = record
    waveform: Integer;
    period: Double;
    magnitude: Double;
    offset: Double;
    phase: Double;
    envelope: ALLEGRO_HAPTIC_ENVELOPE;
    custom_len: Integer;
    custom_data: PDouble;
  end;

  { ALLEGRO_HAPTIC_RUMBLE_EFFECT }
  ALLEGRO_HAPTIC_RUMBLE_EFFECT = record
    strong_magnitude: Double;
    weak_magnitude: Double;
  end;

  { ALLEGRO_HAPTIC_EFFECT_UNION }
  ALLEGRO_HAPTIC_EFFECT_UNION = record
    case Integer of
      0: (constant: ALLEGRO_HAPTIC_CONSTANT_EFFECT);
      1: (ramp: ALLEGRO_HAPTIC_RAMP_EFFECT);
      2: (periodic: ALLEGRO_HAPTIC_PERIODIC_EFFECT);
      3: (condition: ALLEGRO_HAPTIC_CONDITION_EFFECT);
      4: (rumble: ALLEGRO_HAPTIC_RUMBLE_EFFECT);
  end;

  { ALLEGRO_HAPTIC_EFFECT }
  ALLEGRO_HAPTIC_EFFECT = record
    type_: Integer;
    direction: ALLEGRO_HAPTIC_DIRECTION;
    replay: ALLEGRO_HAPTIC_REPLAY;
    data: ALLEGRO_HAPTIC_EFFECT_UNION;
  end;

  { ALLEGRO_HAPTIC_EFFECT_ID }
  ALLEGRO_HAPTIC_EFFECT_ID = record
    _haptic: PALLEGRO_HAPTIC;
    _id: Integer;
    _handle: Integer;
    _pointer: Pointer;
    _effect_duration: Double;
    _playing: Boolean;
    _start_time: Double;
    _end_time: Double;
    driver: Pointer;
  end;

  { ALLEGRO_MEMORY_INTERFACE }
  ALLEGRO_MEMORY_INTERFACE = record
    mi_malloc: function(n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_free: procedure(ptr: Pointer; line: Integer; const file_: PUTF8Char; const func: PUTF8Char); cdecl;
    mi_realloc: function(ptr: Pointer; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
    mi_calloc: function(count: NativeUInt; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl;
  end;

  { ALLEGRO_MONITOR_INFO }
  ALLEGRO_MONITOR_INFO = record
    x1: Integer;
    y1: Integer;
    x2: Integer;
    y2: Integer;
  end;

  { PALLEGRO_MOUSE_CURSOR }
  PALLEGRO_MOUSE_CURSOR = Pointer;

  { PPALLEGRO_MOUSE_CURSOR }
  PPALLEGRO_MOUSE_CURSOR = ^PALLEGRO_MOUSE_CURSOR;

  { ALLEGRO_TRANSFORM }
  ALLEGRO_TRANSFORM = record
    m: array [0..3] of array [0..3] of Single;
  end;

  { PALLEGRO_SHADER }
  PALLEGRO_SHADER = Pointer;

  { PPALLEGRO_SHADER }
  PPALLEGRO_SHADER = ^PALLEGRO_SHADER;

  { PALLEGRO_SYSTEM }
  PALLEGRO_SYSTEM = Pointer;

  { PPALLEGRO_SYSTEM }
  PPALLEGRO_SYSTEM = ^PALLEGRO_SYSTEM;

  { PALLEGRO_THREAD }
  PALLEGRO_THREAD = Pointer;

  { PPALLEGRO_THREAD }
  PPALLEGRO_THREAD = ^PALLEGRO_THREAD;

  { PALLEGRO_MUTEX }
  PALLEGRO_MUTEX = Pointer;

  { PPALLEGRO_MUTEX }
  PPALLEGRO_MUTEX = ^PALLEGRO_MUTEX;

  { PALLEGRO_COND }
  PALLEGRO_COND = Pointer;

  { PPALLEGRO_COND }
  PPALLEGRO_COND = ^PALLEGRO_COND;

  { ALLEGRO_STATE }
  ALLEGRO_STATE = record
    _tls: array [0..1023] of UTF8Char;
  end;

  { PALLEGRO_AUDIO_RECORDER }
  PALLEGRO_AUDIO_RECORDER = Pointer;

  { PPALLEGRO_AUDIO_RECORDER }
  PPALLEGRO_AUDIO_RECORDER = ^PALLEGRO_AUDIO_RECORDER;

  { ALLEGRO_AUDIO_RECORDER_EVENT }
  ALLEGRO_AUDIO_RECORDER_EVENT = record
    type_: ALLEGRO_EVENT_TYPE;
    source: PALLEGRO_AUDIO_RECORDER;
    timestamp: Double;
    __internal__descr: PALLEGRO_USER_EVENT_DESCRIPTOR;
    buffer: Pointer;
    samples: Cardinal;
  end;

  { PALLEGRO_SAMPLE }
  PALLEGRO_SAMPLE = Pointer;

  { PPALLEGRO_SAMPLE }
  PPALLEGRO_SAMPLE = ^PALLEGRO_SAMPLE;

  { ALLEGRO_SAMPLE_ID }
  ALLEGRO_SAMPLE_ID = record
    _index: Integer;
    _id: Integer;
  end;

  { PALLEGRO_SAMPLE_INSTANCE }
  PALLEGRO_SAMPLE_INSTANCE = Pointer;

  { PPALLEGRO_SAMPLE_INSTANCE }
  PPALLEGRO_SAMPLE_INSTANCE = ^PALLEGRO_SAMPLE_INSTANCE;

  { PALLEGRO_AUDIO_STREAM }
  PALLEGRO_AUDIO_STREAM = Pointer;

  { PPALLEGRO_AUDIO_STREAM }
  PPALLEGRO_AUDIO_STREAM = ^PALLEGRO_AUDIO_STREAM;

  { PALLEGRO_MIXER }
  PALLEGRO_MIXER = Pointer;

  { PPALLEGRO_MIXER }
  PPALLEGRO_MIXER = ^PALLEGRO_MIXER;

  { PALLEGRO_VOICE }
  PALLEGRO_VOICE = Pointer;

  { PPALLEGRO_VOICE }
  PPALLEGRO_VOICE = ^PALLEGRO_VOICE;

  { PALLEGRO_AUDIO_DEVICE }
  PALLEGRO_AUDIO_DEVICE = Pointer;

  { PPALLEGRO_AUDIO_DEVICE }
  PPALLEGRO_AUDIO_DEVICE = ^PALLEGRO_AUDIO_DEVICE;

  { PALLEGRO_FONT }
  PALLEGRO_FONT = Pointer;

  { PPALLEGRO_FONT }
  PPALLEGRO_FONT = ^PALLEGRO_FONT;

  { ALLEGRO_GLYPH }
  ALLEGRO_GLYPH = record
    bitmap: PALLEGRO_BITMAP;
    x: Integer;
    y: Integer;
    w: Integer;
    h: Integer;
    kerning: Integer;
    offset_x: Integer;
    offset_y: Integer;
    advance: Integer;
  end;

  { PALLEGRO_FILECHOOSER }
  PALLEGRO_FILECHOOSER = Pointer;

  { PPALLEGRO_FILECHOOSER }
  PPALLEGRO_FILECHOOSER = ^PALLEGRO_FILECHOOSER;

  { PALLEGRO_TEXTLOG }
  PALLEGRO_TEXTLOG = Pointer;

  { PPALLEGRO_TEXTLOG }
  PPALLEGRO_TEXTLOG = ^PALLEGRO_TEXTLOG;

  { PALLEGRO_MENU }
  PALLEGRO_MENU = Pointer;

  { PPALLEGRO_MENU }
  PPALLEGRO_MENU = ^PALLEGRO_MENU;

  { ALLEGRO_MENU_INFO }
  ALLEGRO_MENU_INFO = record
    caption: PUTF8Char;
    id: UInt16;
    flags: Integer;
    icon: PALLEGRO_BITMAP;
  end;

  { ALLEGRO_VERTEX_ELEMENT }
  ALLEGRO_VERTEX_ELEMENT = record
    attribute: Integer;
    storage: Integer;
    offset: Integer;
  end;

  { PALLEGRO_VERTEX_DECL }
  PALLEGRO_VERTEX_DECL = Pointer;

  { PPALLEGRO_VERTEX_DECL }
  PPALLEGRO_VERTEX_DECL = ^PALLEGRO_VERTEX_DECL;

  { ALLEGRO_VERTEX }
  ALLEGRO_VERTEX = record
    x: Single;
    y: Single;
    z: Single;
    u: Single;
    v: Single;
    color: ALLEGRO_COLOR;
  end;

  { PALLEGRO_VERTEX_BUFFER }
  PALLEGRO_VERTEX_BUFFER = Pointer;

  { PPALLEGRO_VERTEX_BUFFER }
  PPALLEGRO_VERTEX_BUFFER = ^PALLEGRO_VERTEX_BUFFER;

  { PALLEGRO_INDEX_BUFFER }
  PALLEGRO_INDEX_BUFFER = Pointer;

  { PPALLEGRO_INDEX_BUFFER }
  PPALLEGRO_INDEX_BUFFER = ^PALLEGRO_INDEX_BUFFER;

  { PALLEGRO_VIDEO }
  PALLEGRO_VIDEO = Pointer;

  { PPALLEGRO_VIDEO }
  PPALLEGRO_VIDEO = ^PALLEGRO_VIDEO;

  { al_emit_user_event_dtor }
  al_emit_user_event_dtor = procedure(p1: PALLEGRO_USER_EVENT); cdecl;

  { al_register_assert_handler_handler }
  al_register_assert_handler_handler = procedure(const expr: PUTF8Char; const file_: PUTF8Char; line: Integer; const func: PUTF8Char); cdecl;

  { al_register_trace_handler_handler }
  al_register_trace_handler_handler = procedure(const p1: PUTF8Char); cdecl;

  { al_for_each_fs_entry_callback }
  al_for_each_fs_entry_callback = function(entry: PALLEGRO_FS_ENTRY; extra: Pointer): Integer; cdecl;

  { atexit_ptr_ }
  atexit_ptr_ = Pointer;

  { al_install_system_atexit_ptr }
  al_install_system_atexit_ptr = function(p1: atexit_ptr_): Integer; cdecl;

  { al_create_thread_proc }
  al_create_thread_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;

  { al_create_thread_with_stacksize_proc }
  al_create_thread_with_stacksize_proc = function(thread: PALLEGRO_THREAD; arg: Pointer): Pointer; cdecl;

  { al_run_detached_thread_proc }
  al_run_detached_thread_proc = function(arg: Pointer): Pointer; cdecl;

  { al_set_mixer_postprocess_callback_cb  }
  al_set_mixer_postprocess_callback_cb = procedure(buf: Pointer; samples: Cardinal; data: Pointer); cdecl;

  { al_register_sample_loader_loader }
  al_register_sample_loader_loader = function(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl;

  { al_register_sample_saver_saver }
  al_register_sample_saver_saver = function(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl;

  { al_register_audio_stream_loader_stream_loader }
  al_register_audio_stream_loader_stream_loader = function(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;

  { al_register_sample_loader_f_loader }
  al_register_sample_loader_f_loader = function(fp: PALLEGRO_FILE): PALLEGRO_SAMPLE; cdecl;

  { al_register_sample_saver_f_saver }
  al_register_sample_saver_f_saver = function(fp: PALLEGRO_FILE; spl: PALLEGRO_SAMPLE): Boolean; cdecl;

  { al_register_audio_stream_loader_f_stream_loader }
  al_register_audio_stream_loader_f_stream_loader = function(fp: PALLEGRO_FILE; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl;

  { al_register_sample_identifier_identifier }
  al_register_sample_identifier_identifier = function(fp: PALLEGRO_FILE): Boolean; cdecl;

  { al_register_font_loader_load }
  al_register_font_loader_load = function(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl;

  { al_do_multiline_text_cb }
  al_do_multiline_text_cb = function(line_num: Integer; const line: PUTF8Char; size: Integer; extra: Pointer): Boolean; cdecl;

  { al_do_multiline_ustr_cb }
  al_do_multiline_ustr_cb = function(line_num: Integer; const line: PALLEGRO_USTR; extra: Pointer): Boolean; cdecl;

  { al_triangulate_polygon_emit_triangle }
  al_triangulate_polygon_emit_triangle = procedure(p1: Integer; p2: Integer; p3: Integer; p4: Pointer); cdecl;

  { al_draw_soft_triangle_init }
  al_draw_soft_triangle_init = procedure(p1: UIntPtr; p2: PALLEGRO_VERTEX; p3: PALLEGRO_VERTEX; p4: PALLEGRO_VERTEX); cdecl;

  { al_draw_soft_triangle_first }
  al_draw_soft_triangle_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer; p5: Integer); cdecl;

  { al_draw_soft_triangle_step }
  al_draw_soft_triangle_step = procedure(p1: UIntPtr; p2: Integer); cdecl;

  { al_draw_soft_triangle_draw }
  al_draw_soft_triangle_draw = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: Integer); cdecl;

  { al_draw_soft_line_first }
  al_draw_soft_line_first = procedure(p1: UIntPtr; p2: Integer; p3: Integer; p4: PALLEGRO_VERTEX; p5: PALLEGRO_VERTEX); cdecl;

  { al_draw_soft_line_step }
  al_draw_soft_line_step = procedure(p1: UIntPtr; p2: Integer); cdecl;

  { al_draw_soft_line_draw }
  al_draw_soft_line_draw = procedure(p1: UIntPtr; p2: Integer; p3: Integer); cdecl;

// --- ZLib -----------------------------------------------------------------
  { Ptm_zip_s }
  Ptm_zip_s = ^tm_zip_s;

  { Pzip_fileinfo }
  Pzip_fileinfo = ^zip_fileinfo;

  { tm_zip_s }
  tm_zip_s = record
    tm_sec: Integer;
    tm_min: Integer;
    tm_hour: Integer;
    tm_mday: Integer;
    tm_mon: Integer;
    tm_year: Integer;
  end;

  { tm_zip }
  tm_zip = tm_zip_s;

  { tm_zip }
  zip_fileinfo = record
    tmz_date: tm_zip;
    dosDate: Cardinal;
    internal_fa: Cardinal;
    external_fa: Cardinal;
  end;

  { zipFile }
  zipFile = Pointer;

// --- Allegro --------------------------------------------------------------
function  al_get_allegro_version(): UInt32; cdecl; external SPARK_DLL;
function  al_get_time(): Double; cdecl; external SPARK_DLL;
procedure al_rest(seconds: Double); cdecl; external SPARK_DLL;
procedure al_init_timeout(timeout: PALLEGRO_TIMEOUT; seconds: Double); cdecl; external SPARK_DLL;
function  al_map_rgb(r: Byte; g: Byte; b: Byte): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_map_rgba(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_map_rgb_f(r: Single; g: Single; b: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_map_rgba_f(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_premul_rgba(r: Byte; g: Byte; b: Byte; a: Byte): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_premul_rgba_f(r: Single; g: Single; b: Single; a: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_unmap_rgb(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte); cdecl; external SPARK_DLL;
procedure al_unmap_rgba(color: ALLEGRO_COLOR; r: PByte; g: PByte; b: PByte; a: PByte); cdecl; external SPARK_DLL;
procedure al_unmap_rgb_f(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle); cdecl; external SPARK_DLL;
procedure al_unmap_rgba_f(color: ALLEGRO_COLOR; r: PSingle; g: PSingle; b: PSingle; a: PSingle); cdecl; external SPARK_DLL;
function  al_get_pixel_size(format: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_pixel_format_bits(format: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_pixel_block_size(format: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_pixel_block_width(format: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_pixel_block_height(format: Integer): Integer; cdecl; external SPARK_DLL;
procedure al_set_new_bitmap_format(format: Integer); cdecl; external SPARK_DLL;
procedure al_set_new_bitmap_flags(flags: Integer); cdecl; external SPARK_DLL;
function  al_get_new_bitmap_format(): Integer; cdecl; external SPARK_DLL;
function  al_get_new_bitmap_flags(): Integer; cdecl; external SPARK_DLL;
procedure al_add_new_bitmap_flag(flag: Integer); cdecl; external SPARK_DLL;
function  al_get_new_bitmap_depth(): Integer; cdecl; external SPARK_DLL;
procedure al_set_new_bitmap_depth(depth: Integer); cdecl; external SPARK_DLL;
function  al_get_new_bitmap_samples(): Integer; cdecl; external SPARK_DLL;
procedure al_set_new_bitmap_samples(samples: Integer); cdecl; external SPARK_DLL;
procedure al_get_new_bitmap_wrap(u: PALLEGRO_BITMAP_WRAP; v: PALLEGRO_BITMAP_WRAP); cdecl; external SPARK_DLL;
procedure al_set_new_bitmap_wrap(u: ALLEGRO_BITMAP_WRAP; v: ALLEGRO_BITMAP_WRAP); cdecl; external SPARK_DLL;
function  al_get_bitmap_width(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_height(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_format(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_flags(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_depth(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_samples(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_create_bitmap(w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
procedure al_destroy_bitmap(bitmap: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
procedure al_put_pixel(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_put_blended_pixel(x: Integer; y: Integer; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
function  al_get_pixel(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_convert_mask_to_alpha(bitmap: PALLEGRO_BITMAP; mask_color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
function  al_get_bitmap_blend_color(): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_get_bitmap_blender(op: PInteger; src: PInteger; dst: PInteger); cdecl; external SPARK_DLL;
procedure al_get_separate_bitmap_blender(op: PInteger; src: PInteger; dst: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dst: PInteger); cdecl; external SPARK_DLL;
procedure al_set_bitmap_blend_color(color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_set_bitmap_blender(op: Integer; src: Integer; dst: Integer); cdecl; external SPARK_DLL;
procedure al_set_separate_bitmap_blender(op: Integer; src: Integer; dst: Integer; alpha_op: Integer; alpha_src: Integer; alpha_dst: Integer); cdecl; external SPARK_DLL;
procedure al_reset_bitmap_blender(); cdecl; external SPARK_DLL;
procedure al_set_clipping_rectangle(x: Integer; y: Integer; width: Integer; height: Integer); cdecl; external SPARK_DLL;
procedure al_reset_clipping_rectangle(); cdecl; external SPARK_DLL;
procedure al_get_clipping_rectangle(x: PInteger; y: PInteger; w: PInteger; h: PInteger); cdecl; external SPARK_DLL;
function  al_create_sub_bitmap(parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_is_sub_bitmap(bitmap: PALLEGRO_BITMAP): Boolean; cdecl; external SPARK_DLL;
function  al_get_parent_bitmap(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_get_bitmap_x(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
function  al_get_bitmap_y(bitmap: PALLEGRO_BITMAP): Integer; cdecl; external SPARK_DLL;
procedure al_reparent_bitmap(bitmap: PALLEGRO_BITMAP; parent: PALLEGRO_BITMAP; x: Integer; y: Integer; w: Integer; h: Integer); cdecl; external SPARK_DLL;
function  al_clone_bitmap(bitmap: PALLEGRO_BITMAP): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
procedure al_convert_bitmap(bitmap: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
procedure al_convert_memory_bitmaps(); cdecl; external SPARK_DLL;
procedure al_backup_dirty_bitmap(bitmap: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
procedure al_draw_bitmap(bitmap: PALLEGRO_BITMAP; dx: Single; dy: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_bitmap_region(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_scaled_bitmap(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_rotated_bitmap(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_scaled_rotated_bitmap(bitmap: PALLEGRO_BITMAP; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_bitmap(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; dx: Single; dy: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_bitmap_region(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_scaled_bitmap(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; sx: Single; sy: Single; sw: Single; sh: Single; dx: Single; dy: Single; dw: Single; dh: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_rotated_bitmap(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; angle: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_scaled_rotated_bitmap(bitmap: PALLEGRO_BITMAP; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl; external SPARK_DLL;
procedure al_draw_tinted_scaled_rotated_bitmap_region(bitmap: PALLEGRO_BITMAP; sx: Single; sy: Single; sw: Single; sh: Single; tint: ALLEGRO_COLOR; cx: Single; cy: Single; dx: Single; dy: Single; xscale: Single; yscale: Single; angle: Single; flags: Integer); cdecl; external SPARK_DLL;
function  al_ustr_new(const s: PUTF8Char): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_new_from_buffer(const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_newf(const fmt: PUTF8Char): PALLEGRO_USTR varargs; cdecl; external SPARK_DLL;
procedure al_ustr_free(us: PALLEGRO_USTR); cdecl; external SPARK_DLL;
function  al_cstr(const us: PALLEGRO_USTR): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_ustr_to_buffer(const us: PALLEGRO_USTR; buffer: PUTF8Char; size: Integer); cdecl; external SPARK_DLL;
function  al_cstr_dup(const us: PALLEGRO_USTR): PUTF8Char; cdecl; external SPARK_DLL;
function  al_ustr_dup(const us: PALLEGRO_USTR): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_dup_substr(const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_empty_string(): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ref_cstr(info: PALLEGRO_USTR_INFO; const s: PUTF8Char): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ref_buffer(info: PALLEGRO_USTR_INFO; const s: PUTF8Char; size: NativeUInt): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ref_ustr(info: PALLEGRO_USTR_INFO; const us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_size(const us: PALLEGRO_USTR): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_length(const us: PALLEGRO_USTR): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_offset(const us: PALLEGRO_USTR; index: Integer): Integer; cdecl; external SPARK_DLL;
function  al_ustr_next(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_prev(const us: PALLEGRO_USTR; pos: PInteger): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_get(const us: PALLEGRO_USTR; pos: Integer): Int32; cdecl; external SPARK_DLL;
function  al_ustr_get_next(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl; external SPARK_DLL;
function  al_ustr_prev_get(const us: PALLEGRO_USTR; pos: PInteger): Int32; cdecl; external SPARK_DLL;
function  al_ustr_insert(us1: PALLEGRO_USTR; pos: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_insert_cstr(us: PALLEGRO_USTR; pos: Integer; const us2: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_insert_chr(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_append(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_append_cstr(us: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_append_chr(us: PALLEGRO_USTR; c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_appendf(us: PALLEGRO_USTR; const fmt: PUTF8Char): Boolean varargs; cdecl; external SPARK_DLL;
function  al_ustr_vappendf(us: PALLEGRO_USTR; const fmt: PUTF8Char; ap: Pointer): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_remove_chr(us: PALLEGRO_USTR; pos: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_remove_range(us: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_truncate(us: PALLEGRO_USTR; start_pos: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_ltrim_ws(us: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_rtrim_ws(us: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_trim_ws(us: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_assign(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_assign_substr(us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; start_pos: Integer; end_pos: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_assign_cstr(us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_set_chr(us: PALLEGRO_USTR; pos: Integer; c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_replace_range(us1: PALLEGRO_USTR; start_pos1: Integer; end_pos1: Integer; const us2: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_find_chr(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl; external SPARK_DLL;
function  al_ustr_rfind_chr(const us: PALLEGRO_USTR; start_pos: Integer; c: Int32): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_set(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_set_cstr(const us: PALLEGRO_USTR; start_pos: Integer; const accept: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_cset(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_cset_cstr(const us: PALLEGRO_USTR; start_pos: Integer; const reject: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_str(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_cstr(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_ustr_rfind_str(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_ustr_rfind_cstr(const haystack: PALLEGRO_USTR; start_pos: Integer; const needle: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_ustr_find_replace(us: PALLEGRO_USTR; start_pos: Integer; const find: PALLEGRO_USTR; const replace: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_find_replace_cstr(us: PALLEGRO_USTR; start_pos: Integer; const find: PUTF8Char; const replace: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_equal(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_compare(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_ustr_ncompare(const us1: PALLEGRO_USTR; const us2: PALLEGRO_USTR; n: Integer): Integer; cdecl; external SPARK_DLL;
function  al_ustr_has_prefix(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_has_prefix_cstr(const u: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_has_suffix(const u: PALLEGRO_USTR; const v: PALLEGRO_USTR): Boolean; cdecl; external SPARK_DLL;
function  al_ustr_has_suffix_cstr(const us1: PALLEGRO_USTR; const s: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_utf8_width(c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_utf8_encode(s: PUTF8Char; c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_new_from_utf16(const s: PUInt16): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_ustr_size_utf16(const us: PALLEGRO_USTR): NativeUInt; cdecl; external SPARK_DLL;
function  al_ustr_encode_utf16(const us: PALLEGRO_USTR; s: PUInt16; n: NativeUInt): NativeUInt; cdecl; external SPARK_DLL;
function  al_utf16_width(c: Integer): NativeUInt; cdecl; external SPARK_DLL;
function  al_utf16_encode(s: PUInt16; c: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_create_path(const str: PUTF8Char): PALLEGRO_PATH; cdecl; external SPARK_DLL;
function  al_create_path_for_directory(const str: PUTF8Char): PALLEGRO_PATH; cdecl; external SPARK_DLL;
function  al_clone_path(const path: PALLEGRO_PATH): PALLEGRO_PATH; cdecl; external SPARK_DLL;
function  al_get_path_num_components(const path: PALLEGRO_PATH): Integer; cdecl; external SPARK_DLL;
function  al_get_path_component(const path: PALLEGRO_PATH; i: Integer): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_replace_path_component(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_remove_path_component(path: PALLEGRO_PATH; i: Integer); cdecl; external SPARK_DLL;
procedure al_insert_path_component(path: PALLEGRO_PATH; i: Integer; const s: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_path_tail(const path: PALLEGRO_PATH): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_drop_path_tail(path: PALLEGRO_PATH); cdecl; external SPARK_DLL;
procedure al_append_path_component(path: PALLEGRO_PATH; const s: PUTF8Char); cdecl; external SPARK_DLL;
function  al_join_paths(path: PALLEGRO_PATH; const tail: PALLEGRO_PATH): Boolean; cdecl; external SPARK_DLL;
function  al_rebase_path(const head: PALLEGRO_PATH; tail: PALLEGRO_PATH): Boolean; cdecl; external SPARK_DLL;
function  al_path_cstr(const path: PALLEGRO_PATH; delim: UTF8Char): PUTF8Char; cdecl; external SPARK_DLL;
function  al_path_ustr(const path: PALLEGRO_PATH; delim: UTF8Char): PALLEGRO_USTR; cdecl; external SPARK_DLL;
procedure al_destroy_path(path: PALLEGRO_PATH); cdecl; external SPARK_DLL;
procedure al_set_path_drive(path: PALLEGRO_PATH; const drive: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_path_drive(const path: PALLEGRO_PATH): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_set_path_filename(path: PALLEGRO_PATH; const filename: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_path_filename(const path: PALLEGRO_PATH): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_path_extension(const path: PALLEGRO_PATH): PUTF8Char; cdecl; external SPARK_DLL;
function  al_set_path_extension(path: PALLEGRO_PATH; const extension: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_get_path_basename(const path: PALLEGRO_PATH): PUTF8Char; cdecl; external SPARK_DLL;
function  al_make_path_canonical(path: PALLEGRO_PATH): Boolean; cdecl; external SPARK_DLL;
function  al_fopen(const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_fopen_interface(const vt: PALLEGRO_FILE_INTERFACE; const path: PUTF8Char; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_create_file_handle(const vt: PALLEGRO_FILE_INTERFACE; userdata: Pointer): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_fclose(f: PALLEGRO_FILE): Boolean; cdecl; external SPARK_DLL;
function  al_fread(f: PALLEGRO_FILE; ptr: Pointer; size: NativeUInt): NativeUInt; cdecl; external SPARK_DLL;
function  al_fwrite(f: PALLEGRO_FILE; const ptr: Pointer; size: NativeUInt): NativeUInt; cdecl; external SPARK_DLL;
function  al_fflush(f: PALLEGRO_FILE): Boolean; cdecl; external SPARK_DLL;
function  al_ftell(f: PALLEGRO_FILE): Int64; cdecl; external SPARK_DLL;
function  al_fseek(f: PALLEGRO_FILE; offset: Int64; whence: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_feof(f: PALLEGRO_FILE): Boolean; cdecl; external SPARK_DLL;
function  al_ferror(f: PALLEGRO_FILE): Integer; cdecl; external SPARK_DLL;
function  al_ferrmsg(f: PALLEGRO_FILE): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_fclearerr(f: PALLEGRO_FILE); cdecl; external SPARK_DLL;
function  al_fungetc(f: PALLEGRO_FILE; c: Integer): Integer; cdecl; external SPARK_DLL;
function  al_fsize(f: PALLEGRO_FILE): Int64; cdecl; external SPARK_DLL;
function  al_fgetc(f: PALLEGRO_FILE): Integer; cdecl; external SPARK_DLL;
function  al_fputc(f: PALLEGRO_FILE; c: Integer): Integer; cdecl; external SPARK_DLL;
function  al_fread16le(f: PALLEGRO_FILE): Int16; cdecl; external SPARK_DLL;
function  al_fread16be(f: PALLEGRO_FILE): Int16; cdecl; external SPARK_DLL;
function  al_fwrite16le(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl; external SPARK_DLL;
function  al_fwrite16be(f: PALLEGRO_FILE; w: Int16): NativeUInt; cdecl; external SPARK_DLL;
function  al_fread32le(f: PALLEGRO_FILE): Int32; cdecl; external SPARK_DLL;
function  al_fread32be(f: PALLEGRO_FILE): Int32; cdecl; external SPARK_DLL;
function  al_fwrite32le(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_fwrite32be(f: PALLEGRO_FILE; l: Int32): NativeUInt; cdecl; external SPARK_DLL;
function  al_fgets(f: PALLEGRO_FILE; const p: PUTF8Char; max: NativeUInt): PUTF8Char; cdecl; external SPARK_DLL;
function  al_fget_ustr(f: PALLEGRO_FILE): PALLEGRO_USTR; cdecl; external SPARK_DLL;
function  al_fputs(f: PALLEGRO_FILE; const p: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_fprintf(f: PALLEGRO_FILE; const format: PUTF8Char): Integer varargs; cdecl; external SPARK_DLL;
function  al_vfprintf(f: PALLEGRO_FILE; const format: PUTF8Char; args: Pointer): Integer; cdecl; varargs; external SPARK_DLL;
function  al_fopen_fd(fd: Integer; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_make_temp_file(const tmpl: PUTF8Char; ret_path: PPALLEGRO_PATH): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_fopen_slice(fp: PALLEGRO_FILE; initial_size: NativeUInt; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_get_new_file_interface(): PALLEGRO_FILE_INTERFACE; cdecl; external SPARK_DLL;
procedure al_set_new_file_interface(const file_interface: PALLEGRO_FILE_INTERFACE); cdecl; external SPARK_DLL;
procedure al_set_standard_file_interface(); cdecl; external SPARK_DLL;
function  al_get_file_userdata(f: PALLEGRO_FILE): Pointer; cdecl; external SPARK_DLL;
function  al_register_bitmap_loader(const ext: PUTF8Char; loader: ALLEGRO_IIO_LOADER_FUNCTION): Boolean; cdecl; external SPARK_DLL;
function  al_register_bitmap_saver(const ext: PUTF8Char; saver: ALLEGRO_IIO_SAVER_FUNCTION): Boolean; cdecl; external SPARK_DLL;
function  al_register_bitmap_loader_f(const ext: PUTF8Char; fs_loader: ALLEGRO_IIO_FS_LOADER_FUNCTION): Boolean; cdecl; external SPARK_DLL;
function  al_register_bitmap_saver_f(const ext: PUTF8Char; fs_saver: ALLEGRO_IIO_FS_SAVER_FUNCTION): Boolean; cdecl; external SPARK_DLL;
function  al_register_bitmap_identifier(const ext: PUTF8Char; identifier: ALLEGRO_IIO_IDENTIFIER_FUNCTION): Boolean; cdecl; external SPARK_DLL;
function  al_load_bitmap(const filename: PUTF8Char): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_load_bitmap_flags(const filename: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_load_bitmap_f(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_load_bitmap_flags_f(fp: PALLEGRO_FILE; const ident: PUTF8Char; flags: Integer): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_save_bitmap(const filename: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl; external SPARK_DLL;
function  al_save_bitmap_f(fp: PALLEGRO_FILE; const ident: PUTF8Char; bitmap: PALLEGRO_BITMAP): Boolean; cdecl; external SPARK_DLL;
function  al_identify_bitmap_f(fp: PALLEGRO_FILE): PUTF8Char; cdecl; external SPARK_DLL;
function  al_identify_bitmap(const filename: PUTF8Char): PUTF8Char; cdecl; external SPARK_DLL;
function  al_lock_bitmap(bitmap: PALLEGRO_BITMAP; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl; external SPARK_DLL;
function  al_lock_bitmap_region(bitmap: PALLEGRO_BITMAP; x: Integer; y: Integer; width: Integer; height: Integer; format: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl; external SPARK_DLL;
function  al_lock_bitmap_blocked(bitmap: PALLEGRO_BITMAP; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl; external SPARK_DLL;
function  al_lock_bitmap_region_blocked(bitmap: PALLEGRO_BITMAP; x_block: Integer; y_block: Integer; width_block: Integer; height_block: Integer; flags: Integer): PALLEGRO_LOCKED_REGION; cdecl; external SPARK_DLL;
procedure al_unlock_bitmap(bitmap: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
function  al_is_bitmap_locked(bitmap: PALLEGRO_BITMAP): Boolean; cdecl; external SPARK_DLL;
procedure al_set_blender(op: Integer; source: Integer; dest: Integer); cdecl; external SPARK_DLL;
procedure al_set_blend_color(color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_get_blender(op: PInteger; source: PInteger; dest: PInteger); cdecl; external SPARK_DLL;
function  al_get_blend_color(): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_set_separate_blender(op: Integer; source: Integer; dest: Integer; alpha_op: Integer; alpha_source: Integer; alpha_dest: Integer); cdecl; external SPARK_DLL;
procedure al_get_separate_blender(op: PInteger; source: PInteger; dest: PInteger; alpha_op: PInteger; alpha_src: PInteger; alpha_dest: PInteger); cdecl; external SPARK_DLL;
procedure al_init_user_event_source(p1: PALLEGRO_EVENT_SOURCE); cdecl; external SPARK_DLL;
procedure al_destroy_user_event_source(p1: PALLEGRO_EVENT_SOURCE); cdecl; external SPARK_DLL;
function  al_emit_user_event(p1: PALLEGRO_EVENT_SOURCE; p2: PALLEGRO_EVENT; dtor: al_emit_user_event_dtor): Boolean; cdecl; external SPARK_DLL;
procedure al_unref_user_event(p1: PALLEGRO_USER_EVENT); cdecl; external SPARK_DLL;
procedure al_set_event_source_data(p1: PALLEGRO_EVENT_SOURCE; data: IntPtr); cdecl; external SPARK_DLL;
function  al_get_event_source_data(const p1: PALLEGRO_EVENT_SOURCE): IntPtr; cdecl; external SPARK_DLL;
function  al_create_event_queue(): PALLEGRO_EVENT_QUEUE; cdecl; external SPARK_DLL;
procedure al_destroy_event_queue(p1: PALLEGRO_EVENT_QUEUE); cdecl; external SPARK_DLL;
function  al_is_event_source_registered(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE): Boolean; cdecl; external SPARK_DLL;
procedure al_register_event_source(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl; external SPARK_DLL;
procedure al_unregister_event_source(p1: PALLEGRO_EVENT_QUEUE; p2: PALLEGRO_EVENT_SOURCE); cdecl; external SPARK_DLL;
procedure al_pause_event_queue(p1: PALLEGRO_EVENT_QUEUE; p2: Boolean); cdecl; external SPARK_DLL;
function  al_is_event_queue_paused(const p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl; external SPARK_DLL;
function  al_is_event_queue_empty(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl; external SPARK_DLL;
function  al_get_next_event(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl; external SPARK_DLL;
function  al_peek_next_event(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT): Boolean; cdecl; external SPARK_DLL;
function  al_drop_next_event(p1: PALLEGRO_EVENT_QUEUE): Boolean; cdecl; external SPARK_DLL;
procedure al_flush_event_queue(p1: PALLEGRO_EVENT_QUEUE); cdecl; external SPARK_DLL;
procedure al_wait_for_event(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT); cdecl; external SPARK_DLL;
function  al_wait_for_event_timed(p1: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; secs: Single): Boolean; cdecl; external SPARK_DLL;
function  al_wait_for_event_until(queue: PALLEGRO_EVENT_QUEUE; ret_event: PALLEGRO_EVENT; timeout: PALLEGRO_TIMEOUT): Boolean; cdecl; external SPARK_DLL;
procedure al_set_new_display_refresh_rate(refresh_rate: Integer); cdecl; external SPARK_DLL;
procedure al_set_new_display_flags(flags: Integer); cdecl; external SPARK_DLL;
function  al_get_new_display_refresh_rate(): Integer; cdecl; external SPARK_DLL;
function  al_get_new_display_flags(): Integer; cdecl; external SPARK_DLL;
procedure al_set_new_window_title(const title: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_new_window_title(): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_display_width(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_get_display_height(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_get_display_format(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_get_display_refresh_rate(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_get_display_flags(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_get_display_orientation(display: PALLEGRO_DISPLAY): Integer; cdecl; external SPARK_DLL;
function  al_set_display_flag(display: PALLEGRO_DISPLAY; flag: Integer; onoff: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_create_display(w: Integer; h: Integer): PALLEGRO_DISPLAY; cdecl; external SPARK_DLL;
procedure al_destroy_display(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
function  al_get_current_display(): PALLEGRO_DISPLAY; cdecl; external SPARK_DLL;
procedure al_set_target_bitmap(bitmap: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
procedure al_set_target_backbuffer(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
function  al_get_backbuffer(display: PALLEGRO_DISPLAY): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_get_target_bitmap(): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_acknowledge_resize(display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_resize_display(display: PALLEGRO_DISPLAY; width: Integer; height: Integer): Boolean; cdecl; external SPARK_DLL;
procedure al_flip_display(); cdecl; external SPARK_DLL;
procedure al_update_display_region(x: Integer; y: Integer; width: Integer; height: Integer); cdecl; external SPARK_DLL;
function  al_is_compatible_bitmap(bitmap: PALLEGRO_BITMAP): Boolean; cdecl; external SPARK_DLL;
function  al_wait_for_vsync(): Boolean; cdecl; external SPARK_DLL;
function  al_get_display_event_source(display: PALLEGRO_DISPLAY): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
procedure al_set_display_icon(display: PALLEGRO_DISPLAY; icon: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
procedure al_set_display_icons(display: PALLEGRO_DISPLAY; num_icons: Integer; icons: PPALLEGRO_BITMAP); cdecl; external SPARK_DLL;
function  al_get_new_display_adapter(): Integer; cdecl; external SPARK_DLL;
procedure al_set_new_display_adapter(adapter: Integer); cdecl; external SPARK_DLL;
procedure al_set_new_window_position(x: Integer; y: Integer); cdecl; external SPARK_DLL;
procedure al_get_new_window_position(x: PInteger; y: PInteger); cdecl; external SPARK_DLL;
procedure al_set_window_position(display: PALLEGRO_DISPLAY; x: Integer; y: Integer); cdecl; external SPARK_DLL;
procedure al_get_window_position(display: PALLEGRO_DISPLAY; x: PInteger; y: PInteger); cdecl; external SPARK_DLL;
function  al_set_window_constraints(display: PALLEGRO_DISPLAY; min_w: Integer; min_h: Integer; max_w: Integer; max_h: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_get_window_constraints(display: PALLEGRO_DISPLAY; min_w: PInteger; min_h: PInteger; max_w: PInteger; max_h: PInteger): Boolean; cdecl; external SPARK_DLL;
procedure al_apply_window_constraints(display: PALLEGRO_DISPLAY; onoff: Boolean); cdecl; external SPARK_DLL;
procedure al_set_window_title(display: PALLEGRO_DISPLAY; const title: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_set_new_display_option(option: Integer; value: Integer; importance: Integer); cdecl; external SPARK_DLL;
function  al_get_new_display_option(option: Integer; importance: PInteger): Integer; cdecl; external SPARK_DLL;
procedure al_reset_new_display_options(); cdecl; external SPARK_DLL;
procedure al_set_display_option(display: PALLEGRO_DISPLAY; option: Integer; value: Integer); cdecl; external SPARK_DLL;
function  al_get_display_option(display: PALLEGRO_DISPLAY; option: Integer): Integer; cdecl; external SPARK_DLL;
procedure al_hold_bitmap_drawing(hold: Boolean); cdecl; external SPARK_DLL;
function  al_is_bitmap_drawing_held(): Boolean; cdecl; external SPARK_DLL;
procedure al_acknowledge_drawing_halt(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
procedure al_acknowledge_drawing_resume(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
procedure al_backup_dirty_bitmaps(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
function  al_get_clipboard_text(display: PALLEGRO_DISPLAY): PUTF8Char; cdecl; external SPARK_DLL;
function  al_set_clipboard_text(display: PALLEGRO_DISPLAY; const text: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_clipboard_has_text(display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_create_config(): PALLEGRO_CONFIG; cdecl; external SPARK_DLL;
procedure al_add_config_section(config: PALLEGRO_CONFIG; const name: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_set_config_value(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char; const value: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_add_config_comment(config: PALLEGRO_CONFIG; const section: PUTF8Char; const comment: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_config_value(const config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): PUTF8Char; cdecl; external SPARK_DLL;
function  al_load_config_file(const filename: PUTF8Char): PALLEGRO_CONFIG; cdecl; external SPARK_DLL;
function  al_load_config_file_f(filename: PALLEGRO_FILE): PALLEGRO_CONFIG; cdecl; external SPARK_DLL;
function  al_save_config_file(const filename: PUTF8Char; const config: PALLEGRO_CONFIG): Boolean; cdecl; external SPARK_DLL;
function  al_save_config_file_f(file_: PALLEGRO_FILE; const config: PALLEGRO_CONFIG): Boolean; cdecl; external SPARK_DLL;
procedure al_merge_config_into(master: PALLEGRO_CONFIG; const add: PALLEGRO_CONFIG); cdecl; external SPARK_DLL;
function  al_merge_config(const cfg1: PALLEGRO_CONFIG; const cfg2: PALLEGRO_CONFIG): PALLEGRO_CONFIG; cdecl; external SPARK_DLL;
procedure al_destroy_config(config: PALLEGRO_CONFIG); cdecl; external SPARK_DLL;
function  al_remove_config_section(config: PALLEGRO_CONFIG; const section: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_remove_config_key(config: PALLEGRO_CONFIG; const section: PUTF8Char; const key: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_get_first_config_section(const config: PALLEGRO_CONFIG; iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_next_config_section(iterator: PPALLEGRO_CONFIG_SECTION): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_first_config_entry(const config: PALLEGRO_CONFIG; const section: PUTF8Char; iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_next_config_entry(iterator: PPALLEGRO_CONFIG_ENTRY): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_cpu_count(): Integer; cdecl; external SPARK_DLL;
function  al_get_ram_size(): Integer; cdecl; external SPARK_DLL;
function  _al_trace_prefix(const channel: PUTF8Char; level: Integer; const file_: PUTF8Char; line: Integer; const function_: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
procedure _al_trace_suffix(const msg: PUTF8Char) varargs; cdecl; external SPARK_DLL;
procedure al_register_assert_handler(handler: al_register_assert_handler_handler); cdecl; external SPARK_DLL;
procedure al_register_trace_handler(handler: al_register_trace_handler_handler); cdecl; external SPARK_DLL;
procedure al_clear_to_color(color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_clear_depth_buffer(x: Single); cdecl; external SPARK_DLL;
procedure al_draw_pixel(x: Single; y: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
function  al_get_errno(): Integer; cdecl; external SPARK_DLL;
procedure al_set_errno(errnum: Integer); cdecl; external SPARK_DLL;
function  al_fixsqrt(x: al_fixed): al_fixed; cdecl; external SPARK_DLL;
function  al_fixhypot(x: al_fixed; y: al_fixed): al_fixed; cdecl; external SPARK_DLL;
function  al_fixatan(x: al_fixed): al_fixed; cdecl; external SPARK_DLL;
function  al_fixatan2(y: al_fixed; x: al_fixed): al_fixed; cdecl; external SPARK_DLL;
function  al_create_fs_entry(const path: PUTF8Char): PALLEGRO_FS_ENTRY; cdecl; external SPARK_DLL;
procedure al_destroy_fs_entry(e: PALLEGRO_FS_ENTRY); cdecl; external SPARK_DLL;
function  al_get_fs_entry_name(e: PALLEGRO_FS_ENTRY): PUTF8Char; cdecl; external SPARK_DLL;
function  al_update_fs_entry(e: PALLEGRO_FS_ENTRY): Boolean; cdecl; external SPARK_DLL;
function  al_get_fs_entry_mode(e: PALLEGRO_FS_ENTRY): UInt32; cdecl; external SPARK_DLL;
function  al_get_fs_entry_atime(e: PALLEGRO_FS_ENTRY): Longint; cdecl; external SPARK_DLL;
function  al_get_fs_entry_mtime(e: PALLEGRO_FS_ENTRY): Longint; cdecl; external SPARK_DLL;
function  al_get_fs_entry_ctime(e: PALLEGRO_FS_ENTRY): Longint; cdecl; external SPARK_DLL;
function  al_get_fs_entry_size(e: PALLEGRO_FS_ENTRY): off_t; cdecl; external SPARK_DLL;
function  al_fs_entry_exists(e: PALLEGRO_FS_ENTRY): Boolean; cdecl; external SPARK_DLL;
function  al_remove_fs_entry(e: PALLEGRO_FS_ENTRY): Boolean; cdecl; external SPARK_DLL;
function  al_open_directory(e: PALLEGRO_FS_ENTRY): Boolean; cdecl; external SPARK_DLL;
function  al_read_directory(e: PALLEGRO_FS_ENTRY): PALLEGRO_FS_ENTRY; cdecl; external SPARK_DLL;
function  al_close_directory(e: PALLEGRO_FS_ENTRY): Boolean; cdecl; external SPARK_DLL;
function  al_filename_exists(const path: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_remove_filename(const path: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_get_current_directory(): PUTF8Char; cdecl; external SPARK_DLL;
function  al_change_directory(const path: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_make_directory(const path: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_open_fs_entry(e: PALLEGRO_FS_ENTRY; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_for_each_fs_entry(dir: PALLEGRO_FS_ENTRY; callback: al_for_each_fs_entry_callback; extra: Pointer): Integer; cdecl; external SPARK_DLL;
function  al_get_fs_interface(): PALLEGRO_FS_INTERFACE; cdecl; external SPARK_DLL;
procedure al_set_fs_interface(const vtable: PALLEGRO_FS_INTERFACE); cdecl; external SPARK_DLL;
procedure al_set_standard_fs_interface(); cdecl; external SPARK_DLL;
function  al_get_num_display_modes(): Integer; cdecl; external SPARK_DLL;
function  al_get_display_mode(index: Integer; mode: PALLEGRO_DISPLAY_MODE): PALLEGRO_DISPLAY_MODE; cdecl; external SPARK_DLL;
function  al_install_joystick(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_joystick(); cdecl; external SPARK_DLL;
function  al_is_joystick_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_reconfigure_joysticks(): Boolean; cdecl; external SPARK_DLL;
function  al_get_num_joysticks(): Integer; cdecl; external SPARK_DLL;
function  al_get_joystick(joyn: Integer): PALLEGRO_JOYSTICK; cdecl; external SPARK_DLL;
procedure al_release_joystick(p1: PALLEGRO_JOYSTICK); cdecl; external SPARK_DLL;
function  al_get_joystick_active(p1: PALLEGRO_JOYSTICK): Boolean; cdecl; external SPARK_DLL;
function  al_get_joystick_name(p1: PALLEGRO_JOYSTICK): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_joystick_num_sticks(p1: PALLEGRO_JOYSTICK): Integer; cdecl; external SPARK_DLL;
function  al_get_joystick_stick_flags(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_joystick_stick_name(p1: PALLEGRO_JOYSTICK; stick: Integer): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_joystick_num_axes(p1: PALLEGRO_JOYSTICK; stick: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_joystick_axis_name(p1: PALLEGRO_JOYSTICK; stick: Integer; axis: Integer): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_joystick_num_buttons(p1: PALLEGRO_JOYSTICK): Integer; cdecl; external SPARK_DLL;
function  al_get_joystick_button_name(p1: PALLEGRO_JOYSTICK; buttonn: Integer): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_get_joystick_state(p1: PALLEGRO_JOYSTICK; ret_state: PALLEGRO_JOYSTICK_STATE); cdecl; external SPARK_DLL;
function  al_get_joystick_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_is_keyboard_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_install_keyboard(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_keyboard(); cdecl; external SPARK_DLL;
function  al_set_keyboard_leds(leds: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_keycode_to_name(keycode: Integer): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_get_keyboard_state(ret_state: PALLEGRO_KEYBOARD_STATE); cdecl; external SPARK_DLL;
procedure al_clear_keyboard_state(display: PALLEGRO_DISPLAY); cdecl; external SPARK_DLL;
function  al_key_down(const p1: PALLEGRO_KEYBOARD_STATE; keycode: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_get_keyboard_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_is_mouse_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_install_mouse(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_mouse(); cdecl; external SPARK_DLL;
function  al_get_mouse_num_buttons(): Cardinal; cdecl; external SPARK_DLL;
function  al_get_mouse_num_axes(): Cardinal; cdecl; external SPARK_DLL;
function  al_set_mouse_xy(display: PALLEGRO_DISPLAY; x: Integer; y: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_mouse_z(z: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_mouse_w(w: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_mouse_axis(axis: Integer; value: Integer): Boolean; cdecl; external SPARK_DLL;
procedure al_get_mouse_state(ret_state: PALLEGRO_MOUSE_STATE); cdecl; external SPARK_DLL;
function  al_mouse_button_down(const state: PALLEGRO_MOUSE_STATE; button: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_get_mouse_state_axis(const state: PALLEGRO_MOUSE_STATE; axis: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_mouse_cursor_position(ret_x: PInteger; ret_y: PInteger): Boolean; cdecl; external SPARK_DLL;
function  al_grab_mouse(display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_ungrab_mouse(): Boolean; cdecl; external SPARK_DLL;
procedure al_set_mouse_wheel_precision(precision: Integer); cdecl; external SPARK_DLL;
function  al_get_mouse_wheel_precision(): Integer; cdecl; external SPARK_DLL;
function  al_get_mouse_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_is_touch_input_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_install_touch_input(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_touch_input(); cdecl; external SPARK_DLL;
procedure al_get_touch_input_state(ret_state: PALLEGRO_TOUCH_INPUT_STATE); cdecl; external SPARK_DLL;
function  al_get_touch_input_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
procedure al_set_mouse_emulation_mode(mode: Integer); cdecl; external SPARK_DLL;
function  al_get_mouse_emulation_mode(): Integer; cdecl; external SPARK_DLL;
function  al_get_touch_input_mouse_emulation_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_install_haptic(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_haptic(); cdecl; external SPARK_DLL;
function  al_is_haptic_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_is_mouse_haptic(p1: PALLEGRO_MOUSE): Boolean; cdecl; external SPARK_DLL;
function  al_is_joystick_haptic(p1: PALLEGRO_JOYSTICK): Boolean; cdecl; external SPARK_DLL;
function  al_is_keyboard_haptic(p1: PALLEGRO_KEYBOARD): Boolean; cdecl; external SPARK_DLL;
function  al_is_display_haptic(p1: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_is_touch_input_haptic(p1: PALLEGRO_TOUCH_INPUT): Boolean; cdecl; external SPARK_DLL;
function  al_get_haptic_from_mouse(p1: PALLEGRO_MOUSE): PALLEGRO_HAPTIC; cdecl; external SPARK_DLL;
function  al_get_haptic_from_joystick(p1: PALLEGRO_JOYSTICK): PALLEGRO_HAPTIC; cdecl; external SPARK_DLL;
function  al_get_haptic_from_keyboard(p1: PALLEGRO_KEYBOARD): PALLEGRO_HAPTIC; cdecl; external SPARK_DLL;
function  al_get_haptic_from_display(p1: PALLEGRO_DISPLAY): PALLEGRO_HAPTIC; cdecl; external SPARK_DLL;
function  al_get_haptic_from_touch_input(p1: PALLEGRO_TOUCH_INPUT): PALLEGRO_HAPTIC; cdecl; external SPARK_DLL;
function  al_release_haptic(p1: PALLEGRO_HAPTIC): Boolean; cdecl; external SPARK_DLL;
function  al_is_haptic_active(p1: PALLEGRO_HAPTIC): Boolean; cdecl; external SPARK_DLL;
function  al_get_haptic_capabilities(p1: PALLEGRO_HAPTIC): Integer; cdecl; external SPARK_DLL;
function  al_is_haptic_capable(p1: PALLEGRO_HAPTIC; p2: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_haptic_gain(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl; external SPARK_DLL;
function  al_get_haptic_gain(p1: PALLEGRO_HAPTIC): Double; cdecl; external SPARK_DLL;
function  al_set_haptic_autocenter(p1: PALLEGRO_HAPTIC; p2: Double): Boolean; cdecl; external SPARK_DLL;
function  al_get_haptic_autocenter(p1: PALLEGRO_HAPTIC): Double; cdecl; external SPARK_DLL;
function  al_get_max_haptic_effects(p1: PALLEGRO_HAPTIC): Integer; cdecl; external SPARK_DLL;
function  al_is_haptic_effect_ok(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT): Boolean; cdecl; external SPARK_DLL;
function  al_upload_haptic_effect(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl; external SPARK_DLL;
function  al_play_haptic_effect(p1: PALLEGRO_HAPTIC_EFFECT_ID; p2: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_upload_and_play_haptic_effect(p1: PALLEGRO_HAPTIC; p2: PALLEGRO_HAPTIC_EFFECT; p3: PALLEGRO_HAPTIC_EFFECT_ID; p4: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_stop_haptic_effect(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl; external SPARK_DLL;
function  al_is_haptic_effect_playing(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl; external SPARK_DLL;
function  al_release_haptic_effect(p1: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl; external SPARK_DLL;
function  al_get_haptic_effect_duration(p1: PALLEGRO_HAPTIC_EFFECT): Double; cdecl; external SPARK_DLL;
function  al_rumble_haptic(p1: PALLEGRO_HAPTIC; p2: Double; p3: Double; p4: PALLEGRO_HAPTIC_EFFECT_ID): Boolean; cdecl; external SPARK_DLL;
procedure al_set_memory_interface(iface: PALLEGRO_MEMORY_INTERFACE); cdecl; external SPARK_DLL;
function  al_malloc_with_context(n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl; external SPARK_DLL;
procedure al_free_with_context(ptr: Pointer; line: Integer; const file_: PUTF8Char; const func: PUTF8Char); cdecl; external SPARK_DLL;
function  al_realloc_with_context(ptr: Pointer; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl; external SPARK_DLL;
function  al_calloc_with_context(count: NativeUInt; n: NativeUInt; line: Integer; const file_: PUTF8Char; const func: PUTF8Char): Pointer; cdecl; external SPARK_DLL;
function  al_get_num_video_adapters(): Integer; cdecl; external SPARK_DLL;
function  al_get_monitor_info(adapter: Integer; info: PALLEGRO_MONITOR_INFO): Boolean; cdecl; external SPARK_DLL;
function  al_get_monitor_dpi(adapter: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_monitor_refresh_rate(adapter: Integer): Integer; cdecl; external SPARK_DLL;
function  al_create_mouse_cursor(sprite: PALLEGRO_BITMAP; xfocus: Integer; yfocus: Integer): PALLEGRO_MOUSE_CURSOR; cdecl; external SPARK_DLL;
procedure al_destroy_mouse_cursor(p1: PALLEGRO_MOUSE_CURSOR); cdecl; external SPARK_DLL;
function  al_set_mouse_cursor(display: PALLEGRO_DISPLAY; cursor: PALLEGRO_MOUSE_CURSOR): Boolean; cdecl; external SPARK_DLL;
function  al_set_system_mouse_cursor(display: PALLEGRO_DISPLAY; cursor_id: ALLEGRO_SYSTEM_MOUSE_CURSOR): Boolean; cdecl; external SPARK_DLL;
function  al_show_mouse_cursor(display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_hide_mouse_cursor(display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
procedure al_set_render_state(state: ALLEGRO_RENDER_STATE; value: Integer); cdecl; external SPARK_DLL;
procedure al_use_transform(const trans: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
procedure al_use_projection_transform(const trans: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
procedure al_copy_transform(dest: PALLEGRO_TRANSFORM; const src: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
procedure al_identity_transform(trans: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
procedure al_build_transform(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; sx: Single; sy: Single; theta: Single); cdecl; external SPARK_DLL;
procedure al_build_camera_transform(trans: PALLEGRO_TRANSFORM; position_x: Single; position_y: Single; position_z: Single; look_x: Single; look_y: Single; look_z: Single; up_x: Single; up_y: Single; up_z: Single); cdecl; external SPARK_DLL;
procedure al_translate_transform(trans: PALLEGRO_TRANSFORM; x: Single; y: Single); cdecl; external SPARK_DLL;
procedure al_translate_transform_3d(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single); cdecl; external SPARK_DLL;
procedure al_rotate_transform(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl; external SPARK_DLL;
procedure al_rotate_transform_3d(trans: PALLEGRO_TRANSFORM; x: Single; y: Single; z: Single; angle: Single); cdecl; external SPARK_DLL;
procedure al_scale_transform(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single); cdecl; external SPARK_DLL;
procedure al_scale_transform_3d(trans: PALLEGRO_TRANSFORM; sx: Single; sy: Single; sz: Single); cdecl; external SPARK_DLL;
procedure al_transform_coordinates(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle); cdecl; external SPARK_DLL;
procedure al_transform_coordinates_3d(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl; external SPARK_DLL;
procedure al_transform_coordinates_4d(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle; w: PSingle); cdecl; external SPARK_DLL;
procedure al_transform_coordinates_3d_projective(const trans: PALLEGRO_TRANSFORM; x: PSingle; y: PSingle; z: PSingle); cdecl; external SPARK_DLL;
procedure al_compose_transform(trans: PALLEGRO_TRANSFORM; const other: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
function  al_get_current_transform(): PALLEGRO_TRANSFORM; cdecl; external SPARK_DLL;
function  al_get_current_inverse_transform(): PALLEGRO_TRANSFORM; cdecl; external SPARK_DLL;
function  al_get_current_projection_transform(): PALLEGRO_TRANSFORM; cdecl; external SPARK_DLL;
procedure al_invert_transform(trans: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
procedure al_transpose_transform(trans: PALLEGRO_TRANSFORM); cdecl; external SPARK_DLL;
function  al_check_inverse(const trans: PALLEGRO_TRANSFORM; tol: Single): Integer; cdecl; external SPARK_DLL;
procedure al_orthographic_transform(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl; external SPARK_DLL;
procedure al_perspective_transform(trans: PALLEGRO_TRANSFORM; left: Single; top: Single; n: Single; right: Single; bottom: Single; f: Single); cdecl; external SPARK_DLL;
procedure al_horizontal_shear_transform(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl; external SPARK_DLL;
procedure al_vertical_shear_transform(trans: PALLEGRO_TRANSFORM; theta: Single); cdecl; external SPARK_DLL;
function  al_create_shader(platform_: ALLEGRO_SHADER_PLATFORM): PALLEGRO_SHADER; cdecl; external SPARK_DLL;
function  al_attach_shader_source(shader: PALLEGRO_SHADER; type_: ALLEGRO_SHADER_TYPE; const source: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_attach_shader_source_file(shader: PALLEGRO_SHADER; type_: ALLEGRO_SHADER_TYPE; const filename: PUTF8Char): Boolean; cdecl; external SPARK_DLL;
function  al_build_shader(shader: PALLEGRO_SHADER): Boolean; cdecl; external SPARK_DLL;
function  al_get_shader_log(shader: PALLEGRO_SHADER): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_shader_platform(shader: PALLEGRO_SHADER): ALLEGRO_SHADER_PLATFORM; cdecl; external SPARK_DLL;
function  al_use_shader(shader: PALLEGRO_SHADER): Boolean; cdecl; external SPARK_DLL;
procedure al_destroy_shader(shader: PALLEGRO_SHADER); cdecl; external SPARK_DLL;
function  al_set_shader_sampler(const name: PUTF8Char; bitmap: PALLEGRO_BITMAP; unit_: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_matrix(const name: PUTF8Char; const matrix: PALLEGRO_TRANSFORM): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_int(const name: PUTF8Char; i: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_float(const name: PUTF8Char; f: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_int_vector(const name: PUTF8Char; num_components: Integer; const i: PInteger; num_elems: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_float_vector(const name: PUTF8Char; num_components: Integer; const f: System.PSingle; num_elems: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_set_shader_bool(const name: PUTF8Char; b: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_get_default_shader_source(platform_: ALLEGRO_SHADER_PLATFORM; type_: ALLEGRO_SHADER_TYPE): PUTF8Char; cdecl; external SPARK_DLL;
function  al_install_system(version: Integer; atexit_ptr: al_install_system_atexit_ptr): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_system(); cdecl; external SPARK_DLL;
function  al_is_system_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_get_system_driver(): PALLEGRO_SYSTEM; cdecl; external SPARK_DLL;
function  al_get_system_config(): PALLEGRO_CONFIG; cdecl; external SPARK_DLL;
function  al_get_system_id(): ALLEGRO_SYSTEM_ID; cdecl; external SPARK_DLL;
function  al_get_standard_path(id: Integer): PALLEGRO_PATH; cdecl; external SPARK_DLL;
procedure al_set_exe_name(const path: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_set_org_name(const org_name: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_set_app_name(const app_name: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_org_name(): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_app_name(): PUTF8Char; cdecl; external SPARK_DLL;
function  al_inhibit_screensaver(inhibit: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_create_thread(proc: al_create_thread_proc; arg: Pointer): PALLEGRO_THREAD; cdecl; external SPARK_DLL;
function  al_create_thread_with_stacksize(proc: al_create_thread_with_stacksize_proc; arg: Pointer; stacksize: NativeUInt): PALLEGRO_THREAD; cdecl; external SPARK_DLL;
procedure al_start_thread(outer: PALLEGRO_THREAD); cdecl; external SPARK_DLL;
procedure al_join_thread(outer: PALLEGRO_THREAD; ret_value: PPointer); cdecl; external SPARK_DLL;
procedure al_set_thread_should_stop(outer: PALLEGRO_THREAD); cdecl; external SPARK_DLL;
function  al_get_thread_should_stop(outer: PALLEGRO_THREAD): Boolean; cdecl; external SPARK_DLL;
procedure al_destroy_thread(thread: PALLEGRO_THREAD); cdecl; external SPARK_DLL;
procedure al_run_detached_thread(proc: al_run_detached_thread_proc; arg: Pointer); cdecl; external SPARK_DLL;
function  al_create_mutex(): PALLEGRO_MUTEX; cdecl; external SPARK_DLL;
function  al_create_mutex_recursive(): PALLEGRO_MUTEX; cdecl; external SPARK_DLL;
procedure al_lock_mutex(mutex: PALLEGRO_MUTEX); cdecl; external SPARK_DLL;
procedure al_unlock_mutex(mutex: PALLEGRO_MUTEX); cdecl; external SPARK_DLL;
procedure al_destroy_mutex(mutex: PALLEGRO_MUTEX); cdecl; external SPARK_DLL;
function  al_create_cond(): PALLEGRO_COND; cdecl; external SPARK_DLL;
procedure al_destroy_cond(cond: PALLEGRO_COND); cdecl; external SPARK_DLL;
procedure al_wait_cond(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX); cdecl; external SPARK_DLL;
function  al_wait_cond_until(cond: PALLEGRO_COND; mutex: PALLEGRO_MUTEX; const timeout: PALLEGRO_TIMEOUT): Integer; cdecl; external SPARK_DLL;
procedure al_broadcast_cond(cond: PALLEGRO_COND); cdecl; external SPARK_DLL;
procedure al_signal_cond(cond: PALLEGRO_COND); cdecl; external SPARK_DLL;
function  al_create_timer(speed_secs: Double): PALLEGRO_TIMER; cdecl; external SPARK_DLL;
procedure al_destroy_timer(timer: PALLEGRO_TIMER); cdecl; external SPARK_DLL;
procedure al_start_timer(timer: PALLEGRO_TIMER); cdecl; external SPARK_DLL;
procedure al_stop_timer(timer: PALLEGRO_TIMER); cdecl; external SPARK_DLL;
procedure al_resume_timer(timer: PALLEGRO_TIMER); cdecl; external SPARK_DLL;
function  al_get_timer_started(const timer: PALLEGRO_TIMER): Boolean; cdecl; external SPARK_DLL;
function  al_get_timer_speed(const timer: PALLEGRO_TIMER): Double; cdecl; external SPARK_DLL;
procedure al_set_timer_speed(timer: PALLEGRO_TIMER; speed_secs: Double); cdecl; external SPARK_DLL;
function  al_get_timer_count(const timer: PALLEGRO_TIMER): Int64; cdecl; external SPARK_DLL;
procedure al_set_timer_count(timer: PALLEGRO_TIMER; count: Int64); cdecl; external SPARK_DLL;
procedure al_add_timer_count(timer: PALLEGRO_TIMER; diff: Int64); cdecl; external SPARK_DLL;
function  al_get_timer_event_source(timer: PALLEGRO_TIMER): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
procedure al_store_state(state: PALLEGRO_STATE; flags: Integer); cdecl; external SPARK_DLL;
procedure al_restore_state(const state: PALLEGRO_STATE); cdecl; external SPARK_DLL;
function  al_create_sample(buf: Pointer; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF; free_buf: Boolean): PALLEGRO_SAMPLE; cdecl; external SPARK_DLL;
procedure al_destroy_sample(spl: PALLEGRO_SAMPLE); cdecl; external SPARK_DLL;
function  al_create_sample_instance(data: PALLEGRO_SAMPLE): PALLEGRO_SAMPLE_INSTANCE; cdecl; external SPARK_DLL;
procedure al_destroy_sample_instance(spl: PALLEGRO_SAMPLE_INSTANCE); cdecl; external SPARK_DLL;
function  al_get_sample_frequency(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_sample_length(const spl: PALLEGRO_SAMPLE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_sample_depth(const spl: PALLEGRO_SAMPLE): ALLEGRO_AUDIO_DEPTH; cdecl; external SPARK_DLL;
function  al_get_sample_channels(const spl: PALLEGRO_SAMPLE): ALLEGRO_CHANNEL_CONF; cdecl; external SPARK_DLL;
function  al_get_sample_data(const spl: PALLEGRO_SAMPLE): Pointer; cdecl; external SPARK_DLL;
function  al_get_sample_instance_frequency(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_sample_instance_length(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_sample_instance_position(const spl: PALLEGRO_SAMPLE_INSTANCE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_sample_instance_speed(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl; external SPARK_DLL;
function  al_get_sample_instance_gain(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl; external SPARK_DLL;
function  al_get_sample_instance_pan(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl; external SPARK_DLL;
function  al_get_sample_instance_time(const spl: PALLEGRO_SAMPLE_INSTANCE): Single; cdecl; external SPARK_DLL;
function  al_get_sample_instance_depth(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_AUDIO_DEPTH; cdecl; external SPARK_DLL;
function  al_get_sample_instance_channels(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_CHANNEL_CONF; cdecl; external SPARK_DLL;
function  al_get_sample_instance_playmode(const spl: PALLEGRO_SAMPLE_INSTANCE): ALLEGRO_PLAYMODE; cdecl; external SPARK_DLL;
function  al_get_sample_instance_playing(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl; external SPARK_DLL;
function  al_get_sample_instance_attached(const spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_position(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_length(spl: PALLEGRO_SAMPLE_INSTANCE; val: Cardinal): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_speed(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_gain(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_pan(spl: PALLEGRO_SAMPLE_INSTANCE; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_playmode(spl: PALLEGRO_SAMPLE_INSTANCE; val: ALLEGRO_PLAYMODE): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_playing(spl: PALLEGRO_SAMPLE_INSTANCE; val: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_detach_sample_instance(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample(spl: PALLEGRO_SAMPLE_INSTANCE; data: PALLEGRO_SAMPLE): Boolean; cdecl; external SPARK_DLL;
function  al_get_sample(spl: PALLEGRO_SAMPLE_INSTANCE): PALLEGRO_SAMPLE; cdecl; external SPARK_DLL;
function  al_play_sample_instance(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl; external SPARK_DLL;
function  al_stop_sample_instance(spl: PALLEGRO_SAMPLE_INSTANCE): Boolean; cdecl; external SPARK_DLL;
function  al_set_sample_instance_channel_matrix(spl: PALLEGRO_SAMPLE_INSTANCE; const matrix: PSingle): Boolean; cdecl; external SPARK_DLL;
function  al_create_audio_stream(buffer_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_STREAM; cdecl; external SPARK_DLL;
procedure al_destroy_audio_stream(stream: PALLEGRO_AUDIO_STREAM); cdecl; external SPARK_DLL;
procedure al_drain_audio_stream(stream: PALLEGRO_AUDIO_STREAM); cdecl; external SPARK_DLL;
function  al_get_audio_stream_frequency(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl; external SPARK_DLL;
function  al_get_audio_stream_length(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl; external SPARK_DLL;
function  al_get_audio_stream_fragments(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl; external SPARK_DLL;
function  al_get_available_audio_stream_fragments(const stream: PALLEGRO_AUDIO_STREAM): Cardinal; cdecl; external SPARK_DLL;
function  al_get_audio_stream_speed(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl; external SPARK_DLL;
function  al_get_audio_stream_gain(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl; external SPARK_DLL;
function  al_get_audio_stream_pan(const stream: PALLEGRO_AUDIO_STREAM): Single; cdecl; external SPARK_DLL;
function  al_get_audio_stream_channels(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_CHANNEL_CONF; cdecl; external SPARK_DLL;
function  al_get_audio_stream_depth(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_AUDIO_DEPTH; cdecl; external SPARK_DLL;
function  al_get_audio_stream_playmode(const stream: PALLEGRO_AUDIO_STREAM): ALLEGRO_PLAYMODE; cdecl; external SPARK_DLL;
function  al_get_audio_stream_playing(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl; external SPARK_DLL;
function  al_get_audio_stream_attached(const spl: PALLEGRO_AUDIO_STREAM): Boolean; cdecl; external SPARK_DLL;
function  al_get_audio_stream_played_samples(const stream: PALLEGRO_AUDIO_STREAM): UInt64; cdecl; external SPARK_DLL;
function  al_get_audio_stream_fragment(const stream: PALLEGRO_AUDIO_STREAM): Pointer; cdecl; external SPARK_DLL;
function  al_set_audio_stream_speed(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_audio_stream_gain(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_audio_stream_pan(stream: PALLEGRO_AUDIO_STREAM; val: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_audio_stream_playmode(stream: PALLEGRO_AUDIO_STREAM; val: ALLEGRO_PLAYMODE): Boolean; cdecl; external SPARK_DLL;
function  al_set_audio_stream_playing(stream: PALLEGRO_AUDIO_STREAM; val: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_detach_audio_stream(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl; external SPARK_DLL;
function  al_set_audio_stream_fragment(stream: PALLEGRO_AUDIO_STREAM; val: Pointer): Boolean; cdecl; external SPARK_DLL;
function  al_rewind_audio_stream(stream: PALLEGRO_AUDIO_STREAM): Boolean; cdecl; external SPARK_DLL;
function  al_seek_audio_stream_secs(stream: PALLEGRO_AUDIO_STREAM; time: Double): Boolean; cdecl; external SPARK_DLL;
function  al_get_audio_stream_position_secs(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl; external SPARK_DLL;
function  al_get_audio_stream_length_secs(stream: PALLEGRO_AUDIO_STREAM): Double; cdecl; external SPARK_DLL;
function  al_set_audio_stream_loop_secs(stream: PALLEGRO_AUDIO_STREAM; start: Double; end_: Double): Boolean; cdecl; external SPARK_DLL;
function  al_get_audio_stream_event_source(stream: PALLEGRO_AUDIO_STREAM): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_set_audio_stream_channel_matrix(stream: PALLEGRO_AUDIO_STREAM; const matrix: PSingle): Boolean; cdecl; external SPARK_DLL;
function  al_create_mixer(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_MIXER; cdecl; external SPARK_DLL;
procedure al_destroy_mixer(mixer: PALLEGRO_MIXER); cdecl; external SPARK_DLL;
function  al_attach_sample_instance_to_mixer(stream: PALLEGRO_SAMPLE_INSTANCE; mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_attach_audio_stream_to_mixer(stream: PALLEGRO_AUDIO_STREAM; mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_attach_mixer_to_mixer(stream: PALLEGRO_MIXER; mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_set_mixer_postprocess_callback(mixer: PALLEGRO_MIXER; cb: al_set_mixer_postprocess_callback_cb; data: Pointer): Boolean; cdecl; external SPARK_DLL;
function  al_get_mixer_frequency(const mixer: PALLEGRO_MIXER): Cardinal; cdecl; external SPARK_DLL;
function  al_get_mixer_channels(const mixer: PALLEGRO_MIXER): ALLEGRO_CHANNEL_CONF; cdecl; external SPARK_DLL;
function  al_get_mixer_depth(const mixer: PALLEGRO_MIXER): ALLEGRO_AUDIO_DEPTH; cdecl; external SPARK_DLL;
function  al_get_mixer_quality(const mixer: PALLEGRO_MIXER): ALLEGRO_MIXER_QUALITY; cdecl; external SPARK_DLL;
function  al_get_mixer_gain(const mixer: PALLEGRO_MIXER): Single; cdecl; external SPARK_DLL;
function  al_get_mixer_playing(const mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_get_mixer_attached(const mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_set_mixer_frequency(mixer: PALLEGRO_MIXER; val: Cardinal): Boolean; cdecl; external SPARK_DLL;
function  al_set_mixer_quality(mixer: PALLEGRO_MIXER; val: ALLEGRO_MIXER_QUALITY): Boolean; cdecl; external SPARK_DLL;
function  al_set_mixer_gain(mixer: PALLEGRO_MIXER; gain: Single): Boolean; cdecl; external SPARK_DLL;
function  al_set_mixer_playing(mixer: PALLEGRO_MIXER; val: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_detach_mixer(mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_create_voice(freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_VOICE; cdecl; external SPARK_DLL;
procedure al_destroy_voice(voice: PALLEGRO_VOICE); cdecl; external SPARK_DLL;
function  al_attach_sample_instance_to_voice(stream: PALLEGRO_SAMPLE_INSTANCE; voice: PALLEGRO_VOICE): Boolean; cdecl; external SPARK_DLL;
function  al_attach_audio_stream_to_voice(stream: PALLEGRO_AUDIO_STREAM; voice: PALLEGRO_VOICE): Boolean; cdecl; external SPARK_DLL;
function  al_attach_mixer_to_voice(mixer: PALLEGRO_MIXER; voice: PALLEGRO_VOICE): Boolean; cdecl; external SPARK_DLL;
procedure al_detach_voice(voice: PALLEGRO_VOICE); cdecl; external SPARK_DLL;
function  al_get_voice_frequency(const voice: PALLEGRO_VOICE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_voice_position(const voice: PALLEGRO_VOICE): Cardinal; cdecl; external SPARK_DLL;
function  al_get_voice_channels(const voice: PALLEGRO_VOICE): ALLEGRO_CHANNEL_CONF; cdecl; external SPARK_DLL;
function  al_get_voice_depth(const voice: PALLEGRO_VOICE): ALLEGRO_AUDIO_DEPTH; cdecl; external SPARK_DLL;
function  al_get_voice_playing(const voice: PALLEGRO_VOICE): Boolean; cdecl; external SPARK_DLL;
function  al_set_voice_position(voice: PALLEGRO_VOICE; val: Cardinal): Boolean; cdecl; external SPARK_DLL;
function  al_set_voice_playing(voice: PALLEGRO_VOICE; val: Boolean): Boolean; cdecl; external SPARK_DLL;
function  al_install_audio(): Boolean; cdecl; external SPARK_DLL;
procedure al_uninstall_audio(); cdecl; external SPARK_DLL;
function  al_is_audio_installed(): Boolean; cdecl; external SPARK_DLL;
function  al_get_allegro_audio_version(): UInt32; cdecl; external SPARK_DLL;
function  al_get_channel_count(conf: ALLEGRO_CHANNEL_CONF): NativeUInt; cdecl; external SPARK_DLL;
function  al_get_audio_depth_size(conf: ALLEGRO_AUDIO_DEPTH): NativeUInt; cdecl; external SPARK_DLL;
procedure al_fill_silence(buf: Pointer; samples: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF); cdecl; external SPARK_DLL;
function  al_get_num_audio_output_devices(): Integer; cdecl; external SPARK_DLL;
function  al_get_audio_output_device(index: Integer): PALLEGRO_AUDIO_DEVICE; cdecl; external SPARK_DLL;
function  al_get_audio_device_name(const device: PALLEGRO_AUDIO_DEVICE): PUTF8Char; cdecl; external SPARK_DLL;
function  al_reserve_samples(reserve_samples: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_get_default_mixer(): PALLEGRO_MIXER; cdecl; external SPARK_DLL;
function  al_set_default_mixer(mixer: PALLEGRO_MIXER): Boolean; cdecl; external SPARK_DLL;
function  al_restore_default_mixer(): Boolean; cdecl; external SPARK_DLL;
function  al_play_sample(data: PALLEGRO_SAMPLE; gain: Single; pan: Single; speed: Single; loop: ALLEGRO_PLAYMODE; ret_id: PALLEGRO_SAMPLE_ID): Boolean; cdecl; external SPARK_DLL;
procedure al_stop_sample(spl_id: PALLEGRO_SAMPLE_ID); cdecl; external SPARK_DLL;
procedure al_stop_samples(); cdecl; external SPARK_DLL;
function  al_get_default_voice(): PALLEGRO_VOICE; cdecl; external SPARK_DLL;
procedure al_set_default_voice(voice: PALLEGRO_VOICE); cdecl; external SPARK_DLL;
function  al_lock_sample_id(spl_id: PALLEGRO_SAMPLE_ID): PALLEGRO_SAMPLE_INSTANCE; cdecl; external SPARK_DLL;
procedure al_unlock_sample_id(spl_id: PALLEGRO_SAMPLE_ID); cdecl; external SPARK_DLL;
function  al_register_sample_loader(const ext: PUTF8Char; loader: al_register_sample_loader_loader): Boolean; cdecl; external SPARK_DLL;
function  al_register_sample_saver(const ext: PUTF8Char; saver: al_register_sample_saver_saver): Boolean; cdecl; external SPARK_DLL;
function  al_register_audio_stream_loader(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_stream_loader): Boolean; cdecl; external SPARK_DLL;
function  al_register_sample_loader_f(const ext: PUTF8Char; loader: al_register_sample_loader_f_loader): Boolean; cdecl; external SPARK_DLL;
function  al_register_sample_saver_f(const ext: PUTF8Char; saver: al_register_sample_saver_f_saver): Boolean; cdecl; external SPARK_DLL;
function  al_register_audio_stream_loader_f(const ext: PUTF8Char; stream_loader: al_register_audio_stream_loader_f_stream_loader): Boolean; cdecl; external SPARK_DLL;
function  al_register_sample_identifier(const ext: PUTF8Char; identifier: al_register_sample_identifier_identifier): Boolean; cdecl; external SPARK_DLL;
function  al_load_sample(const filename: PUTF8Char): PALLEGRO_SAMPLE; cdecl; external SPARK_DLL;
function  al_save_sample(const filename: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl; external SPARK_DLL;
function  al_load_audio_stream(const filename: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl; external SPARK_DLL;
function  al_load_sample_f(fp: PALLEGRO_FILE; const ident: PUTF8Char): PALLEGRO_SAMPLE; cdecl; external SPARK_DLL;
function  al_save_sample_f(fp: PALLEGRO_FILE; const ident: PUTF8Char; spl: PALLEGRO_SAMPLE): Boolean; cdecl; external SPARK_DLL;
function  al_load_audio_stream_f(fp: PALLEGRO_FILE; const ident: PUTF8Char; buffer_count: NativeUInt; samples: Cardinal): PALLEGRO_AUDIO_STREAM; cdecl; external SPARK_DLL;
function  al_identify_sample_f(fp: PALLEGRO_FILE): PUTF8Char; cdecl; external SPARK_DLL;
function  al_identify_sample(const filename: PUTF8Char): PUTF8Char; cdecl; external SPARK_DLL;
function  al_create_audio_recorder(fragment_count: NativeUInt; samples: Cardinal; freq: Cardinal; depth: ALLEGRO_AUDIO_DEPTH; chan_conf: ALLEGRO_CHANNEL_CONF): PALLEGRO_AUDIO_RECORDER; cdecl; external SPARK_DLL;
function  al_start_audio_recorder(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl; external SPARK_DLL;
procedure al_stop_audio_recorder(r: PALLEGRO_AUDIO_RECORDER); cdecl; external SPARK_DLL;
function  al_is_audio_recorder_recording(r: PALLEGRO_AUDIO_RECORDER): Boolean; cdecl; external SPARK_DLL;
function  al_get_audio_recorder_event_source(r: PALLEGRO_AUDIO_RECORDER): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_get_audio_recorder_event(event: PALLEGRO_EVENT): PALLEGRO_AUDIO_RECORDER_EVENT; cdecl; external SPARK_DLL;
procedure al_destroy_audio_recorder(r: PALLEGRO_AUDIO_RECORDER); cdecl; external SPARK_DLL;
function  al_init_acodec_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_acodec_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
function  al_get_allegro_acodec_version(): UInt32; cdecl; external SPARK_DLL;
function  al_get_allegro_color_version(): UInt32; cdecl; external SPARK_DLL;
procedure al_color_hsv_to_rgb(hue: Single; saturation: Single; value: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_hsl(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; lightness: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_hsv(red: Single; green: Single; blue: Single; hue: PSingle; saturation: PSingle; value: PSingle); cdecl; external SPARK_DLL;
procedure al_color_hsl_to_rgb(hue: Single; saturation: Single; lightness: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
function  al_color_name_to_rgb(const name: PUTF8Char; r: PSingle; g: PSingle; b: PSingle): Boolean; cdecl; external SPARK_DLL;
function  al_color_rgb_to_name(r: Single; g: Single; b: Single): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_color_cmyk_to_rgb(cyan: Single; magenta: Single; yellow: Single; key: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_cmyk(red: Single; green: Single; blue: Single; cyan: PSingle; magenta: PSingle; yellow: PSingle; key: PSingle); cdecl; external SPARK_DLL;
procedure al_color_yuv_to_rgb(y: Single; u: Single; v: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_yuv(red: Single; green: Single; blue: Single; y: PSingle; u: PSingle; v: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_html(red: Single; green: Single; blue: Single; string_: PUTF8Char); cdecl; external SPARK_DLL;
function  al_color_html_to_rgb(const string_: PUTF8Char; red: PSingle; green: PSingle; blue: PSingle): Boolean; cdecl; external SPARK_DLL;
function  al_color_yuv(y: Single; u: Single; v: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_cmyk(c: Single; m: Single; y: Single; k: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_hsl(h: Single; s: Single; l: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_hsv(h: Single; s: Single; v: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_name(const name: PUTF8Char): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_html(const string_: PUTF8Char): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_color_xyz_to_rgb(x: Single; y: Single; z: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_xyz(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; z: PSingle); cdecl; external SPARK_DLL;
function  al_color_xyz(x: Single; y: Single; z: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_color_lab_to_rgb(l: Single; a: Single; b: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_lab(red: Single; green: Single; blue: Single; l: PSingle; a: PSingle; b: PSingle); cdecl; external SPARK_DLL;
function  al_color_lab(l: Single; a: Single; b: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_color_xyy_to_rgb(x: Single; y: Single; y2: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_xyy(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; y2: PSingle); cdecl; external SPARK_DLL;
function  al_color_xyy(x: Single; y: Single; y2: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_color_distance_ciede2000(c1: ALLEGRO_COLOR; c2: ALLEGRO_COLOR): Double; cdecl; external SPARK_DLL;
procedure al_color_lch_to_rgb(l: Single; c: Single; h: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_lch(red: Single; green: Single; blue: Single; l: PSingle; c: PSingle; h: PSingle); cdecl; external SPARK_DLL;
function  al_color_lch(l: Single; c: Single; h: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_is_color_valid(color: ALLEGRO_COLOR): Boolean; cdecl; external SPARK_DLL;
procedure al_color_oklab_to_rgb(l: Single; a: Single; b: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_oklab(red: Single; green: Single; blue: Single; l: PSingle; a: PSingle; b: PSingle); cdecl; external SPARK_DLL;
function  al_color_oklab(l: Single; a: Single; b: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
procedure al_color_linear_to_rgb(x: Single; y: Single; z: Single; red: PSingle; green: PSingle; blue: PSingle); cdecl; external SPARK_DLL;
procedure al_color_rgb_to_linear(red: Single; green: Single; blue: Single; x: PSingle; y: PSingle; z: PSingle); cdecl; external SPARK_DLL;
function  al_color_linear(r: Single; g: Single; b: Single): ALLEGRO_COLOR; cdecl; external SPARK_DLL;
function  al_register_font_loader(const ext: PUTF8Char; load: al_register_font_loader_load): Boolean; cdecl; external SPARK_DLL;
function  al_load_bitmap_font(const filename: PUTF8Char): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_load_bitmap_font_flags(const filename: PUTF8Char; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_load_font(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_grab_font_from_bitmap(bmp: PALLEGRO_BITMAP; n: Integer; ranges: PInteger): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_create_builtin_font(): PALLEGRO_FONT; cdecl; external SPARK_DLL;
procedure al_draw_ustr(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const ustr: PALLEGRO_USTR); cdecl; external SPARK_DLL;
procedure al_draw_text(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const text: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_draw_justified_text(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_draw_justified_ustr(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl; external SPARK_DLL;
procedure al_draw_textf(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl; external SPARK_DLL;
procedure al_draw_justified_textf(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x1: Single; x2: Single; y: Single; diff: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl; external SPARK_DLL;
function  al_get_text_width(const f: PALLEGRO_FONT; const str: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  al_get_ustr_width(const f: PALLEGRO_FONT; const ustr: PALLEGRO_USTR): Integer; cdecl; external SPARK_DLL;
function  al_get_font_line_height(const f: PALLEGRO_FONT): Integer; cdecl; external SPARK_DLL;
function  al_get_font_ascent(const f: PALLEGRO_FONT): Integer; cdecl; external SPARK_DLL;
function  al_get_font_descent(const f: PALLEGRO_FONT): Integer; cdecl; external SPARK_DLL;
procedure al_destroy_font(f: PALLEGRO_FONT); cdecl; external SPARK_DLL;
procedure al_get_ustr_dimensions(const f: PALLEGRO_FONT; const text: PALLEGRO_USTR; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl; external SPARK_DLL;
procedure al_get_text_dimensions(const f: PALLEGRO_FONT; const text: PUTF8Char; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger); cdecl; external SPARK_DLL;
function  al_init_font_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_font_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_font_addon(); cdecl; external SPARK_DLL;
function  al_get_allegro_font_version(): UInt32; cdecl; external SPARK_DLL;
function  al_get_font_ranges(font: PALLEGRO_FONT; ranges_count: Integer; ranges: PInteger): Integer; cdecl; external SPARK_DLL;
procedure al_draw_glyph(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; codepoint: Integer); cdecl; external SPARK_DLL;
function  al_get_glyph_width(const f: PALLEGRO_FONT; codepoint: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_glyph_dimensions(const f: PALLEGRO_FONT; codepoint: Integer; bbx: PInteger; bby: PInteger; bbw: PInteger; bbh: PInteger): Boolean; cdecl; external SPARK_DLL;
function  al_get_glyph_advance(const f: PALLEGRO_FONT; codepoint1: Integer; codepoint2: Integer): Integer; cdecl; external SPARK_DLL;
function  al_get_glyph(const f: PALLEGRO_FONT; prev_codepoint: Integer; codepoint: Integer; glyph: PALLEGRO_GLYPH): Boolean; cdecl; external SPARK_DLL;
procedure al_draw_multiline_text(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PUTF8Char); cdecl; external SPARK_DLL;
procedure al_draw_multiline_textf(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const format: PUTF8Char) varargs; cdecl; external SPARK_DLL;
procedure al_draw_multiline_ustr(const font: PALLEGRO_FONT; color: ALLEGRO_COLOR; x: Single; y: Single; max_width: Single; line_height: Single; flags: Integer; const text: PALLEGRO_USTR); cdecl; external SPARK_DLL;
procedure al_do_multiline_text(const font: PALLEGRO_FONT; max_width: Single; const text: PUTF8Char; cb: al_do_multiline_text_cb; extra: Pointer); cdecl; external SPARK_DLL;
procedure al_do_multiline_ustr(const font: PALLEGRO_FONT; max_width: Single; const ustr: PALLEGRO_USTR; cb: al_do_multiline_ustr_cb; extra: Pointer); cdecl; external SPARK_DLL;
procedure al_set_fallback_font(font: PALLEGRO_FONT; fallback: PALLEGRO_FONT); cdecl; external SPARK_DLL;
function  al_get_fallback_font(font: PALLEGRO_FONT): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_init_image_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_image_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_image_addon(); cdecl; external SPARK_DLL;
function  al_get_allegro_image_version(): UInt32; cdecl; external SPARK_DLL;
function  al_open_memfile(mem: Pointer; size: Int64; const mode: PUTF8Char): PALLEGRO_FILE; cdecl; external SPARK_DLL;
function  al_get_allegro_memfile_version(): UInt32; cdecl; external SPARK_DLL;
function  al_init_native_dialog_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_native_dialog_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_native_dialog_addon(); cdecl; external SPARK_DLL;
function  al_create_native_file_dialog(const initial_path: PUTF8Char; const title: PUTF8Char; const patterns: PUTF8Char; mode: Integer): PALLEGRO_FILECHOOSER; cdecl; external SPARK_DLL;
function  al_show_native_file_dialog(display: PALLEGRO_DISPLAY; dialog: PALLEGRO_FILECHOOSER): Boolean; cdecl; external SPARK_DLL;
function  al_get_native_file_dialog_count(const dialog: PALLEGRO_FILECHOOSER): Integer; cdecl; external SPARK_DLL;
function  al_get_native_file_dialog_path(const dialog: PALLEGRO_FILECHOOSER; index: NativeUInt): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_destroy_native_file_dialog(dialog: PALLEGRO_FILECHOOSER); cdecl; external SPARK_DLL;
function  al_show_native_message_box(display: PALLEGRO_DISPLAY; const title: PUTF8Char; const heading: PUTF8Char; const text: PUTF8Char; const buttons: PUTF8Char; flags: Integer): Integer; cdecl; external SPARK_DLL;
function  al_open_native_text_log(const title: PUTF8Char; flags: Integer): PALLEGRO_TEXTLOG; cdecl; external SPARK_DLL;
procedure al_close_native_text_log(textlog: PALLEGRO_TEXTLOG); cdecl; external SPARK_DLL;
procedure al_append_native_text_log(textlog: PALLEGRO_TEXTLOG; const format: PUTF8Char) varargs; cdecl; external SPARK_DLL;
function  al_get_native_text_log_event_source(textlog: PALLEGRO_TEXTLOG): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_create_menu(): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_create_popup_menu(): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_build_menu(info: PALLEGRO_MENU_INFO): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_append_menu_item(parent: PALLEGRO_MENU; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl; external SPARK_DLL;
function  al_insert_menu_item(parent: PALLEGRO_MENU; pos: Integer; const title: PUTF8Char; id: UInt16; flags: Integer; icon: PALLEGRO_BITMAP; submenu: PALLEGRO_MENU): Integer; cdecl; external SPARK_DLL;
function  al_remove_menu_item(menu: PALLEGRO_MENU; pos: Integer): Boolean; cdecl; external SPARK_DLL;
function  al_clone_menu(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_clone_menu_for_popup(menu: PALLEGRO_MENU): PALLEGRO_MENU; cdecl; external SPARK_DLL;
procedure al_destroy_menu(menu: PALLEGRO_MENU); cdecl; external SPARK_DLL;
function  al_get_menu_item_caption(menu: PALLEGRO_MENU; pos: Integer): PUTF8Char; cdecl; external SPARK_DLL;
procedure al_set_menu_item_caption(menu: PALLEGRO_MENU; pos: Integer; const caption: PUTF8Char); cdecl; external SPARK_DLL;
function  al_get_menu_item_flags(menu: PALLEGRO_MENU; pos: Integer): Integer; cdecl; external SPARK_DLL;
procedure al_set_menu_item_flags(menu: PALLEGRO_MENU; pos: Integer; flags: Integer); cdecl; external SPARK_DLL;
function  al_get_menu_item_icon(menu: PALLEGRO_MENU; pos: Integer): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
procedure al_set_menu_item_icon(menu: PALLEGRO_MENU; pos: Integer; icon: PALLEGRO_BITMAP); cdecl; external SPARK_DLL;
function  al_toggle_menu_item_flags(menu: PALLEGRO_MENU; pos: Integer; flags: Integer): Integer; cdecl; external SPARK_DLL;
function  al_find_menu(haystack: PALLEGRO_MENU; id: UInt16): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_find_menu_item(haystack: PALLEGRO_MENU; id: UInt16; menu: PPALLEGRO_MENU; index: PInteger): Boolean; cdecl; external SPARK_DLL;
function  al_get_default_menu_event_source(): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
function  al_enable_menu_event_source(menu: PALLEGRO_MENU): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
procedure al_disable_menu_event_source(menu: PALLEGRO_MENU); cdecl; external SPARK_DLL;
function  al_get_display_menu(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_set_display_menu(display: PALLEGRO_DISPLAY; menu: PALLEGRO_MENU): Boolean; cdecl; external SPARK_DLL;
function  al_popup_menu(popup: PALLEGRO_MENU; display: PALLEGRO_DISPLAY): Boolean; cdecl; external SPARK_DLL;
function  al_remove_display_menu(display: PALLEGRO_DISPLAY): PALLEGRO_MENU; cdecl; external SPARK_DLL;
function  al_get_allegro_native_dialog_version(): UInt32; cdecl; external SPARK_DLL;
procedure al_set_physfs_file_interface(); cdecl; external SPARK_DLL;
function  al_get_allegro_physfs_version(): UInt32; cdecl; external SPARK_DLL;
function  al_get_allegro_primitives_version(): UInt32; cdecl; external SPARK_DLL;
function  al_init_primitives_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_primitives_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_primitives_addon(); cdecl; external SPARK_DLL;
function  al_draw_prim(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; start: Integer; end_: Integer; type_: Integer): Integer; cdecl; external SPARK_DLL;
function  al_draw_indexed_prim(const vtxs: Pointer; const decl: PALLEGRO_VERTEX_DECL; texture: PALLEGRO_BITMAP; const indices: PInteger; num_vtx: Integer; type_: Integer): Integer; cdecl; external SPARK_DLL;
function  al_draw_vertex_buffer(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; start: Integer; end_: Integer; type_: Integer): Integer; cdecl; external SPARK_DLL;
function  al_draw_indexed_buffer(vertex_buffer: PALLEGRO_VERTEX_BUFFER; texture: PALLEGRO_BITMAP; index_buffer: PALLEGRO_INDEX_BUFFER; start: Integer; end_: Integer; type_: Integer): Integer; cdecl; external SPARK_DLL;
function  al_create_vertex_decl(const elements: PALLEGRO_VERTEX_ELEMENT; stride: Integer): PALLEGRO_VERTEX_DECL; cdecl; external SPARK_DLL;
procedure al_destroy_vertex_decl(decl: PALLEGRO_VERTEX_DECL); cdecl; external SPARK_DLL;
function  al_create_vertex_buffer(decl: PALLEGRO_VERTEX_DECL; const initial_data: Pointer; num_vertices: Integer; flags: Integer): PALLEGRO_VERTEX_BUFFER; cdecl; external SPARK_DLL;
procedure al_destroy_vertex_buffer(buffer: PALLEGRO_VERTEX_BUFFER); cdecl; external SPARK_DLL;
function  al_lock_vertex_buffer(buffer: PALLEGRO_VERTEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl; external SPARK_DLL;
procedure al_unlock_vertex_buffer(buffer: PALLEGRO_VERTEX_BUFFER); cdecl; external SPARK_DLL;
function  al_get_vertex_buffer_size(buffer: PALLEGRO_VERTEX_BUFFER): Integer; cdecl; external SPARK_DLL;
function  al_create_index_buffer(index_size: Integer; const initial_data: Pointer; num_indices: Integer; flags: Integer): PALLEGRO_INDEX_BUFFER; cdecl; external SPARK_DLL;
procedure al_destroy_index_buffer(buffer: PALLEGRO_INDEX_BUFFER); cdecl; external SPARK_DLL;
function  al_lock_index_buffer(buffer: PALLEGRO_INDEX_BUFFER; offset: Integer; length: Integer; flags: Integer): Pointer; cdecl; external SPARK_DLL;
procedure al_unlock_index_buffer(buffer: PALLEGRO_INDEX_BUFFER); cdecl; external SPARK_DLL;
function  al_get_index_buffer_size(buffer: PALLEGRO_INDEX_BUFFER): Integer; cdecl; external SPARK_DLL;
function  al_triangulate_polygon(const vertices: PSingle; vertex_stride: NativeUInt; const vertex_counts: PInteger; emit_triangle: al_triangulate_polygon_emit_triangle; userdata: Pointer): Boolean; cdecl; external SPARK_DLL;
procedure al_draw_soft_triangle(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; v3: PALLEGRO_VERTEX; state: UIntPtr; init: al_draw_soft_triangle_init; first: al_draw_soft_triangle_first; step: al_draw_soft_triangle_step; draw: al_draw_soft_triangle_draw); cdecl; external SPARK_DLL;
procedure al_draw_soft_line(v1: PALLEGRO_VERTEX; v2: PALLEGRO_VERTEX; state: UIntPtr; first: al_draw_soft_line_first; step: al_draw_soft_line_step; draw: al_draw_soft_line_draw); cdecl; external SPARK_DLL;
procedure al_draw_line(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_triangle(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_rectangle(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_rounded_rectangle(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_calculate_arc(dest: PSingle; stride: Integer; cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; thickness: Single; num_points: Integer); cdecl; external SPARK_DLL;
procedure al_draw_circle(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_ellipse(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_arc(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_elliptical_arc(cx: Single; cy: Single; rx: Single; ry: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_draw_pieslice(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_calculate_spline(dest: PSingle; stride: Integer; points: PSingle; thickness: Single; num_segments: Integer); cdecl; external SPARK_DLL;
procedure al_draw_spline(points: PSingle; color: ALLEGRO_COLOR; thickness: Single); cdecl; external SPARK_DLL;
procedure al_calculate_ribbon(dest: PSingle; dest_stride: Integer; const points: PSingle; points_stride: Integer; thickness: Single; num_segments: Integer); cdecl; external SPARK_DLL;
procedure al_draw_ribbon(const points: PSingle; points_stride: Integer; color: ALLEGRO_COLOR; thickness: Single; num_segments: Integer); cdecl; external SPARK_DLL;
procedure al_draw_filled_triangle(x1: Single; y1: Single; x2: Single; y2: Single; x3: Single; y3: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_rectangle(x1: Single; y1: Single; x2: Single; y2: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_ellipse(cx: Single; cy: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_circle(cx: Single; cy: Single; r: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_pieslice(cx: Single; cy: Single; r: Single; start_theta: Single; delta_theta: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_rounded_rectangle(x1: Single; y1: Single; x2: Single; y2: Single; rx: Single; ry: Single; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_polyline(const vertices: PSingle; vertex_stride: Integer; vertex_count: Integer; join_style: Integer; cap_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl; external SPARK_DLL;
procedure al_draw_polygon(const vertices: PSingle; vertex_count: Integer; join_style: Integer; color: ALLEGRO_COLOR; thickness: Single; miter_limit: Single); cdecl; external SPARK_DLL;
procedure al_draw_filled_polygon(const vertices: PSingle; vertex_count: Integer; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
procedure al_draw_filled_polygon_with_holes(const vertices: PSingle; const vertex_counts: PInteger; color: ALLEGRO_COLOR); cdecl; external SPARK_DLL;
function  al_load_ttf_font(const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_load_ttf_font_f(file_: PALLEGRO_FILE; const filename: PUTF8Char; size: Integer; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_load_ttf_font_stretch(const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_load_ttf_font_stretch_f(file_: PALLEGRO_FILE; const filename: PUTF8Char; w: Integer; h: Integer; flags: Integer): PALLEGRO_FONT; cdecl; external SPARK_DLL;
function  al_init_ttf_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_ttf_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_ttf_addon(); cdecl; external SPARK_DLL;
function  al_get_allegro_ttf_version(): UInt32; cdecl; external SPARK_DLL;
function  al_open_video(const filename: PUTF8Char): PALLEGRO_VIDEO; cdecl; external SPARK_DLL;
procedure al_close_video(video: PALLEGRO_VIDEO); cdecl; external SPARK_DLL;
procedure al_start_video(video: PALLEGRO_VIDEO; mixer: PALLEGRO_MIXER); cdecl; external SPARK_DLL;
procedure al_start_video_with_voice(video: PALLEGRO_VIDEO; voice: PALLEGRO_VOICE); cdecl; external SPARK_DLL;
function  al_get_video_event_source(video: PALLEGRO_VIDEO): PALLEGRO_EVENT_SOURCE; cdecl; external SPARK_DLL;
procedure al_set_video_playing(video: PALLEGRO_VIDEO; playing: Boolean); cdecl; external SPARK_DLL;
function  al_is_video_playing(video: PALLEGRO_VIDEO): Boolean; cdecl; external SPARK_DLL;
function  al_get_video_audio_rate(video: PALLEGRO_VIDEO): Double; cdecl; external SPARK_DLL;
function  al_get_video_fps(video: PALLEGRO_VIDEO): Double; cdecl; external SPARK_DLL;
function  al_get_video_scaled_width(video: PALLEGRO_VIDEO): Single; cdecl; external SPARK_DLL;
function  al_get_video_scaled_height(video: PALLEGRO_VIDEO): Single; cdecl; external SPARK_DLL;
function  al_get_video_frame(video: PALLEGRO_VIDEO): PALLEGRO_BITMAP; cdecl; external SPARK_DLL;
function  al_get_video_position(video: PALLEGRO_VIDEO; which: ALLEGRO_VIDEO_POSITION_TYPE): Double; cdecl; external SPARK_DLL;
function  al_seek_video(video: PALLEGRO_VIDEO; pos_in_seconds: Double): Boolean; cdecl; external SPARK_DLL;
function  al_init_video_addon(): Boolean; cdecl; external SPARK_DLL;
function  al_is_video_addon_initialized(): Boolean; cdecl; external SPARK_DLL;
procedure al_shutdown_video_addon(); cdecl; external SPARK_DLL;
function  al_get_allegro_video_version(): UInt32; cdecl; external SPARK_DLL;
function  al_identify_video_f(fp: PALLEGRO_FILE): PUTF8Char; cdecl; external SPARK_DLL;
function  al_identify_video(const filename: PUTF8Char): PUTF8Char; cdecl; external SPARK_DLL;
function  al_get_win_window_handle(display: PALLEGRO_DISPLAY): HWND; cdecl; external SPARK_DLL;

// --- PHYSFS ---------------------------------------------------------------
function  PHYSFS_init(const argv0: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  PHYSFS_deinit(): Integer; cdecl; external SPARK_DLL;
function  PHYSFS_getWriteDir(): PUTF8Char; cdecl; external SPARK_DLL;
function  PHYSFS_setWriteDir(const newDir: PUTF8Char): Integer; cdecl; external SPARK_DLL;
function  PHYSFS_mount(const newDir: PUTF8Char; const mountPoint: PUTF8Char; appendToPath: Integer): Integer; cdecl; external SPARK_DLL;
function  PHYSFS_unmount(const oldDir: PUTF8Char): Integer; cdecl; external SPARK_DLL;

// --- ZLib -----------------------------------------------------------------
function  crc32(crc: Cardinal; const buf: PByte; len: Cardinal): Cardinal; cdecl; external SPARK_DLL;
function  zipOpen(const pathname: PUTF8Char; append: Integer): zipFile; cdecl; external SPARK_DLL;
function  zipOpenNewFileInZip3(file_: zipFile; const filename: PUTF8Char; const zipfi: Pzip_fileinfo; const extrafield_local: Pointer; intsize_extrafield_local: Cardinal; const extrafield_global: Pointer; intsize_extrafield_global: Cardinal; const comment: PUTF8Char; method: Integer; level: Integer; raw: Integer; windowBits: Integer; memLevel: Integer; strategy: Integer; const password: PUTF8Char; crcForCrypting: Cardinal): Integer; cdecl; external SPARK_DLL;
function  zipWriteInFileInZip(file_: zipFile; const buf: Pointer; len: Cardinal): Integer; cdecl; external SPARK_DLL;
function  zipCloseFileInZip(file_: zipFile): Integer; cdecl; external SPARK_DLL;
function  zipClose(file_: zipFile; const global_comment: PUTF8Char): Integer; cdecl; external SPARK_DLL;

{$ENDREGION}

{$REGION 'Spark.Math'}
const
  RAD2DEG = 180.0 / PI;
  DEG2RAD = PI / 180.0;
  EPSILON = 0.00001;
  NaN     =  0.0 / 0.0;

type
  { TLineIntersection }
  TLineIntersection = (liNone, liTrue, liParallel);

  { TEaseType }
  TEaseType = (etLinearTween, etInQuad, etOutQuad, etInOutQuad, etInCubic,
    etOutCubic, etInOutCubic, etInQuart, etOutQuart, etInOutQuart, etInQuint,
    etOutQuint, etInOutQuint, etInSine, etOutSine, etInOutSine, etInExpo,
    etOutExpo, etInOutExpo, etInCircle, etOutCircle, etInOutCircle);

  { TVector }
  PVector = ^TVector;
  TVector = record
    X,Y,Z, W: Single;
    constructor Create(aX, aY: Single); overload;
    constructor Create(aX, aY, aZ: Single); overload;
    constructor Create(aX, aY, aZ, aW: Single); overload;
    procedure Assign(aX, aY: Single); overload;
    procedure Assign(aX, aY, aZ: Single); overload;
    procedure Assign(aX, aY, aZ, aW: Single); overload;
    procedure Assign(aVector: TVector); overload;
    procedure Clear;
    procedure Add(aVector: TVector);
    procedure Subtract(aVector: TVector);
    procedure Multiply(aVector: TVector);
    procedure Divide(aVector: TVector);
    function  Magnitude: Single;
    function  MagnitudeTruncate(aMaxMagitude: Single): TVector;
    function  Distance(aVector: TVector): Single;
    procedure Normalize;
    function  Angle(aVector: TVector): Single;
    procedure Thrust(aAngle: Single; aSpeed: Single);
    function  MagnitudeSquared: Single;
    function  DotProduct(aVector: TVector): Single;
    procedure Scale(aValue: Single);
    procedure DivideBy(aValue: Single);
    function  Project(aVector: TVector): TVector;
    procedure Negate;
  end;

  { TRectangle }
  PRectangle = ^TRectangle;
  TRectangle = record
    X, Y, Width, Height: Single;
    constructor Create(aX, aY, aWidth, aHeight: Single);
    procedure Assign(aX, aY, aWidth, aHeight: Single); overload;
    procedure Assign(aRectangle: TRectangle); overload;
    procedure Clear;
    function Intersect(aRect: TRectangle): Boolean;
  end;

{ Routines }
function  Min(const A, B: Int64): Int64; overload; inline;
function  Min(const A, B: UInt64): UInt64; overload; inline;
function  Min(const A, B: Double): Double; overload; inline;
function  Max(const A, B: Int64): Int64; overload; inline;
function  Max(const A, B: UInt64): UInt64; overload; inline;
function  Max(const A, B: Double): Double; overload; inline;
function  Sign(const aValue: Int64): Integer; overload; inline;
function  Sign(const aValue: Double): Integer; overload; inline;
function  InRange(const AValue, AMin, AMax: Int64): Boolean; overload;
function  InRange(const AValue, AMin, AMax: UInt64): Boolean; overload;
function  InRange(const AValue, AMin, AMax: Double): Boolean; overload;
function  EnsureRange(const aValue, aMin, aMax: Int64): Int64; overload;
function  EnsureRange(const aValue, aMin, aMax: UInt64): UInt64; overload;
function  EnsureRange(const aValue, aMin, aMax: Double): Double; overload;
function  Floor(const X: Extended): Integer;
function  IntPower(const Base: Extended; const Exponent: Integer): Extended;
function  Power(const Base, Exponent: Extended): Extended;
function  RandomRange(aMin, aMax: Integer): Integer; overload;
function  RandomRange(aMin, aMax: Single): Single; overload;
function  RandomBool: Boolean;
function  GetRandomSeed: Integer;
procedure SetRandomSeed(aValue: Integer);
function  AngleCos(aAngle: Integer): Single;
function  AngleSin(aAngle: Integer): Single;
function  AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
procedure AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
function  ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single; overload;
function  ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer; overload;
function  SameSign(aValue1: Integer; aValue2: Integer): Boolean; overload;
function  SameSign(aValue1: Single; aValue2: Single): Boolean; overload;
function  SameValue(aA: Double; aB: Double; aEpsilon: Double = 0): Boolean; overload;
function  SameValue(aA: Single; aB: Single; aEpsilon: Single = 0): Boolean; overload;
function  Vector(aX: Single; aY: Single): TVector;
function  Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TRectangle;
procedure SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
function  Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;

// --- Collision ------------------------------------------------------------
function  PointInRectangle(aPoint: TVector; aRect: TRectangle): Boolean;
function  PointInCircle(aPoint, aCenter: TVector; aRadius: Single): Boolean;
function  PointInTriangle(aPoint, aP1, aP2, aP3: TVector): Boolean;
function  CirclesOverlap(aCenter1: TVector; aRadius1: Single; aCenter2: TVector; aRadius2: Single): Boolean;
function  CircleInRectangle(aCenter: TVector; aRadius: Single; aRect: TRectangle): Boolean;
function  RectanglesOverlap(aRect1: TRectangle; aRect2: TRectangle): Boolean;
function  RectangleIntersection(aRect1, aRect2: TRectangle): TRectangle;
function  LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TLineIntersection;
function  RadiusOverlap(aRadius1, aX1, aY1, aRadius2, aX2, aY2, aShrinkFactor: Single): Boolean;

// --- Easing ---------------------------------------------------------------
function  EaseValue(aCurrentTime: Double; aStartValue: Double; aChangeInValue: Double; aDuration: Double; aEaseType: TEaseType): Double;
function  EasePosition(aStartPos: Double; aEndPos: Double; aCurrentPos: Double; aEaseType: TEaseType): Double;


{$ENDREGION}

{$REGION 'Spark.Utils'}
const
  PathDelim  = '\';
  DriveDelim = ':';
  PathSep    = ';';
  CR         = #13;
  LF         = #10;
  CRLF       = #13#10;

type
  TSysCharSet = set of AnsiChar;
  TStringArray = array of string;

  { TGVHAlign }
  THAlign = (haLeft, haCenter, haRight);

  { TGVVAlign }
  TVAlign = (vaTop, vaCenter, vaBottom);

  { TBaseObject }
  TBaseObject = class
  public
    constructor Create; virtual;
    destructor Destroy; override;
  end;

  { TListCompareFunc }
  TListCompareFunc = function (Item1, Item2: Pointer): Integer;

  { TList }
  TList = class(TBaseObject)
  protected
    FItems    : array of Pointer;
    FCount    : Integer;
    FCapacity : Integer;
    function OutOfBounds(aIndex: Integer): Boolean;
    function GetItem(aIndex: Integer): Pointer; inline;
    procedure SetItem(aIndex: Integer; aValue: Pointer); inline;
  public
    property Count: Integer read FCount;
    property Items[aIndex: Integer]: Pointer read GetItem write SetItem; default;
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aCapacity: Integer = 1);
    procedure Clear;
    function IndexOf(aItem: Pointer): Integer;
    function Add(aItem: Pointer): Integer;
    function Delete(aIndex: Integer): Pointer;
    procedure Insert(aIndex: Integer; aItem: Pointer);
    procedure Sort(aCompareFunc: TListCompareFunc);
  end;

  { TStringListCompareFunc }
  TStringListCompareFunc = function (Item1, Item2: string): Integer;

  { TStringList }
  TStringList = class(TBaseObject)
  protected
    FItems    : array of string;
    FCount    : Integer;
    FCapacity : Integer;
    function OutOfBounds(aIndex: Integer): Boolean;
    function GetItem(aIndex: Integer): string; inline;
    procedure SetItem(aIndex: Integer; aValue: string); inline;
  public
    property Count: Integer read FCount;
    property Items[aIndex: Integer]: string read GetItem write SetItem; default;
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aCapacity: Integer = 1);
    procedure Clear;
    function IndexOf(aItem: string): Integer;
    function Add(aItem: string): Integer;
    function Delete(aIndex: Integer): string;
    procedure Insert(aIndex: Integer; aItem: string);
    procedure Sort(aCompareFunc: TStringListCompareFunc);
    function AddPair(const aName, aValue: string): TStringList;
    function GetKey(aIndex: Integer): string; inline;
    function GetValue(aIndex: Integer): string; inline;
  end;

  { TStream }
  TStream = class(TBaseObject)
  protected
  type
    TType = (stClosed, stMemory, stFile);
  protected
    FType  : TType;
    FSize  : Integer;
    FPos   : Integer;
    FFile  : File;
    FMem   : Pointer;
    procedure SetPos(aValue: Integer);
  public
    property Size: Integer read FSize;
    property Pos: Integer read FPos write SetPos;
    constructor Create; override;
    destructor Destroy; override;
    function Open(aMemory: Pointer; aMemSize: Integer): Boolean; overload;
    function Open(const aFilename: string; aCreate: Boolean = False): Boolean; overload;
    procedure Close;
    procedure CopyFrom(const aStream: TStream);
    function Read(out aBuf; aBufSize: Integer): Integer;
    function Write(const aBuf; aBufSize: Integer): Integer;
    function ReadAnsiString: AnsiString;
    procedure WriteAnsiString(const aValue: AnsiString);
    function ReadString: string;
    procedure WriteString(const aValue: string);
    class function Init(aMemory: Pointer; aMemSize: Integer): TStream; overload;
    class function Init(const aFilename: string; aCreate: Boolean = False): TStream; overload;
  end;

{ Routines }
procedure FreeNilObject(var aObject);
function  GetTempPath: string;
function  GetTempFileName: string;
procedure ProcessMessages;
function  NumToStr(aValue: Int64): string; overload;
function  NumToStr(aValue: UInt64): string; overload;
function  NumToStr(aValue: Double; aWidth: Integer=0; aDecimals: Integer=2): string; overload;
function  NumToStr(aValue: Extended; aWidth: Integer=0; aDecimals: Integer=2): string; overload;
function  TrimChars(const aValue: string; Chars: TSysCharSet): string;
function  TrimStr(aValue: string): string;
function  DeleteChars(const Str: string; Chars: TSysCharSet): string;
function  StrToInt(aValue: string): Int64;
function  StrToUInt(aValue: string): UInt64;
function  StrToFloat(aValue: string): Double;
function  StuffStr(const aText: string; aStart, aLength: Cardinal; const aSubText: string): string;
function  UpperCase(const S: string): string;
function  SameText(A, B: string): Boolean;
function  LastDelimiter(const aText: string; const Delims: TSysCharSet): Integer;
function  ChangeFileExt(const aFilename, aExtension: string): string;
function  FileExist(const aFilename: string): Boolean;
function  DirExist(const aDir: string): Boolean;
function  GetFiles(const aPath: string; aRecursive: Boolean): TStringArray;
function  FileCount(const aPath: string; const aMask: string): Int64;
function  GetBit(const aValue: Cardinal; const Bit: Byte): Boolean;
function  SetBit(const aValue: Cardinal; const Bit: Byte): Cardinal;
function  ClearBit(const aValue: Cardinal; const Bit: Byte): Cardinal;
function  EnableBit(const aValue: Cardinal; const Bit: Byte; const Flag: Boolean): Cardinal;
function  StrScan(const aText: PWideChar; Chr: WideChar): PWideChar;
function  StrEnd(const aText: PWideChar): PWideChar;
function  ExtractQuotedStr(var aText: PWideChar; Quote: WideChar): UnicodeString;
function  DequotedStr(const aText: string; aQuote: Char): string;
function  RemoveQuotes(const aText: string): string;
function  FormatStr(const aMsg: string; const aArgs: array of const): string;
function  PadRightStr(const aText: string; aTotalWidth: Integer; aPaddingChar: Char): string;
function  PadLeftStr(const aText: string; aTotalWidth: Integer; aPaddingChar: Char): string;
function  ExtractStrings(Separators, WhiteSpace: TSysCharSet; Content: PChar; Strings: TStringList): Integer;
function  GetFilename(const aPath: string): string;
function  HasConsoleOutput: Boolean;
procedure Print(const aMsg: string; const aArgs: array of const);
procedure PrintLn(const aMsg: string; const aArgs: array of const);
function  ExtractFilePath(const FileName: string): string;
function  CreateDir(const Dir: string): Boolean;
function  ForceDirectories(Dir: string): Boolean;
function ExpandFileName(const FileName: string): string;

{$ENDREGION}

{$REGION 'Spark.System'}
const
  SPARK_VERSION_MAJOR = '0';
  SPARK_VERSION_MINOR = '1';
  SPARK_VERSION_PATCH = '0';
  SPARK_VERSION       = SPARK_VERSION_MAJOR + '.' + SPARK_VERSION_MINOR + '.' + SPARK_VERSION_PATCH;
  cLogExt = '.log';
  cIniExt = '.ini';
  cPngExt = '.png';

type
  { TLog }
  TLog = class(TBaseObject)
  protected
    FFilename: string;
    FText: Text;
    FBuffer: array[Word] of Byte;
    FOpen: Boolean;
    FGlobalWriteToConsole: Boolean;
  public
    property GlobalWriteToConsole: Boolean read FGlobalWriteToConsole write FGlobalWriteToConsole;
    constructor Create; override;
    destructor Destroy; override;
    procedure Open(const aFilename: string=''; aOverwrite: Boolean=True);
    procedure Close;
    function Add(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean=False): string;
  end;

  { TconfigFile }
  TConfigFile = class(TBaseObject)
  protected
  type
    { TParams }
    TParams = record
      Name : string;
      Value: string;
    end;

     { TData }
    TData = record
      Category: string;
      Params  : array of TParams;
    end;
  protected
    FData: array of TData;
    FFilename: string;
    procedure Load(const aFilename: string);
    procedure Save(const aFilename: string);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Open(const aFilename: string='');
    procedure Close;
    procedure Clear;
    procedure Write(const aCategory, aName, aValue: string); overload;
    procedure Write(const aCategory, aName: string; aValue: Int64); overload;
    procedure Write(const aCategory, aName: string; aValue: Single); overload;
    procedure Write(const aCategory, aName: string; aValue: Boolean); overload;
    function Read(const aCategory, aName: string; const Default: string = ''): string; overload;
    function Read(const aCategory, aName: string; aDefault: Int64 = 0): Int64; overload;
    function Read(const aCategory, aName: string; aDefault: Single = 0): Single; overload;
    function Read(const aCategory, aName: string; aDefault: Boolean = False): Boolean; overload;
    function CategoryName(aIndex: Integer): string;
  end;

  { TArchiveBuildProgressEvent }
  TArchiveBuildProgressEvent = procedure(const aFilename: string; aProgress: Integer; aNewFile: Boolean) of object;

  { TArchive }
  TArchive = class(TBaseObject)
  protected
    FPassword: string;
    FFilename: string;
    FPasswordFilename: string;
    FIsOpen: Boolean;
    function GetCRC32(aStream: PALLEGRO_FILE): Cardinal;
  public
    constructor Create; override;
    destructor Destroy; override;
    function IsOpen: Boolean;
    function Open(const aPassword: string; const aFilename: string): Boolean;
    function Close: Boolean;
    function FileInside(const aFilename: string): Boolean;
    function GetPasswordFilename(const aFilename: string): PAnsiChar;
    function Build(const aPassword: string; const aFilename: string; const aDirectory: string; aOnProgress: TArchiveBuildProgressEvent): Boolean;
  end;

var
  LogToConsole: Boolean = True;

{$ENDREGION}

{$REGION 'Spark.Graphics'}
const
  cCmdConsoleViewPrecentage = 0.75;

type
  { TBlendMode }
  TBlendMode = (bmPreMultipliedAlpha, bmNonPreMultipliedAlpha, bmAdditiveAlpha, bmCopySrcToDest, bmMultiplySrcAndDest);

  { TVideoState }
  TVideoState = (vsLoad, vsUnload, vsPlaying, vsPaused, vsFinished);

  { TBlendModeColor }
  TBlendModeColor = (bmcNormal, bmcAvgSrcDest);

  { TColor }
  PColor = ^TColor;
  TColor = record
    Red, Green, Blue, Alpha: Single;
    function FromByte(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TColor; overload;
    function FromFloat(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TColor; overload;
    function FromName(const aName: string): TColor; overload;
    function Fade(aTo: TColor; aPos: Single): TColor;
    function Equal(aColor: TColor): Boolean;
  end;

{$REGION 'Common Colors'}
const
  ALICEBLUE           : TColor = (Red:$F0/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  ANTIQUEWHITE        : TColor = (Red:$FA/$FF; Green:$EB/$FF; Blue:$D7/$FF; Alpha:$FF/$FF);
  AQUA                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  AQUAMARINE          : TColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$D4/$FF; Alpha:$FF/$FF);
  AZURE               : TColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BEIGE               : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  BISQUE              : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$C4/$FF; Alpha:$FF/$FF);
  BLACK               : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  BLANCHEDALMOND      : TColor = (Red:$FF/$FF; Green:$EB/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  BLUE                : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  BLUEVIOLET          : TColor = (Red:$8A/$FF; Green:$2B/$FF; Blue:$E2/$FF; Alpha:$FF/$FF);
  BROWN               : TColor = (Red:$A5/$FF; Green:$2A/$FF; Blue:$2A/$FF; Alpha:$FF/$FF);
  BURLYWOOD           : TColor = (Red:$DE/$FF; Green:$B8/$FF; Blue:$87/$FF; Alpha:$FF/$FF);
  CADETBLUE           : TColor = (Red:$5F/$FF; Green:$9E/$FF; Blue:$A0/$FF; Alpha:$FF/$FF);
  CHARTREUSE          : TColor = (Red:$7F/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  CHOCOLATE           : TColor = (Red:$D2/$FF; Green:$69/$FF; Blue:$1E/$FF; Alpha:$FF/$FF);
  CORAL               : TColor = (Red:$FF/$FF; Green:$7F/$FF; Blue:$50/$FF; Alpha:$FF/$FF);
  CORNFLOWERBLUE      : TColor = (Red:$64/$FF; Green:$95/$FF; Blue:$ED/$FF; Alpha:$FF/$FF);
  CORNSILK            : TColor = (Red:$FF/$FF; Green:$F8/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  CRIMSON             : TColor = (Red:$DC/$FF; Green:$14/$FF; Blue:$3C/$FF; Alpha:$FF/$FF);
  CYAN                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DARKBLUE            : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKCYAN            : TColor = (Red:$00/$FF; Green:$8B/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKGOLDENROD       : TColor = (Red:$B8/$FF; Green:$86/$FF; Blue:$0B/$FF; Alpha:$FF/$FF);
  DARKGRAY            : TColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKGREEN           : TColor = (Red:$00/$FF; Green:$64/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKGREY            : TColor = (Red:$A9/$FF; Green:$A9/$FF; Blue:$A9/$FF; Alpha:$FF/$FF);
  DARKKHAKI           : TColor = (Red:$BD/$FF; Green:$B7/$FF; Blue:$6B/$FF; Alpha:$FF/$FF);
  DARKMAGENTA         : TColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKOLIVEGREEN      : TColor = (Red:$55/$FF; Green:$6B/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  DARKORANGE          : TColor = (Red:$FF/$FF; Green:$8C/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKORCHID          : TColor = (Red:$99/$FF; Green:$32/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  DARKRED             : TColor = (Red:$8B/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  DARKSALMON          : TColor = (Red:$E9/$FF; Green:$96/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  DARKSEAGREEN        : TColor = (Red:$8F/$FF; Green:$BC/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  DARKSLATEBLUE       : TColor = (Red:$48/$FF; Green:$3D/$FF; Blue:$8B/$FF; Alpha:$FF/$FF);
  DARKSLATEGRAY       : TColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKSLATEGREY       : TColor = (Red:$2F/$FF; Green:$4F/$FF; Blue:$4F/$FF; Alpha:$FF/$FF);
  DARKTURQUOISE       : TColor = (Red:$00/$FF; Green:$CE/$FF; Blue:$D1/$FF; Alpha:$FF/$FF);
  DARKVIOLET          : TColor = (Red:$94/$FF; Green:$00/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  DEEPPINK            : TColor = (Red:$FF/$FF; Green:$14/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  DEEPSKYBLUE         : TColor = (Red:$00/$FF; Green:$BF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  DIMGRAY             : TColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DIMGREY             : TColor = (Red:$69/$FF; Green:$69/$FF; Blue:$69/$FF; Alpha:$FF/$FF);
  DODGERBLUE          : TColor = (Red:$1E/$FF; Green:$90/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  FIREBRICK           : TColor = (Red:$B2/$FF; Green:$22/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FLORALWHITE         : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  FORESTGREEN         : TColor = (Red:$22/$FF; Green:$8B/$FF; Blue:$22/$FF; Alpha:$FF/$FF);
  FUCHSIA             : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GAINSBORO           : TColor = (Red:$DC/$FF; Green:$DC/$FF; Blue:$DC/$FF; Alpha:$FF/$FF);
  GHOSTWHITE          : TColor = (Red:$F8/$FF; Green:$F8/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  GOLD                : TColor = (Red:$FF/$FF; Green:$D7/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GOLDENROD           : TColor = (Red:$DA/$FF; Green:$A5/$FF; Blue:$20/$FF; Alpha:$FF/$FF);
  GRAY                : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  GREEN               : TColor = (Red:$00/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  GREENYELLOW         : TColor = (Red:$AD/$FF; Green:$FF/$FF; Blue:$2F/$FF; Alpha:$FF/$FF);
  GREY                : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  HONEYDEW            : TColor = (Red:$F0/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  HOTPINK             : TColor = (Red:$FF/$FF; Green:$69/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  INDIANRED           : TColor = (Red:$CD/$FF; Green:$5C/$FF; Blue:$5C/$FF; Alpha:$FF/$FF);
  INDIGO              : TColor = (Red:$4B/$FF; Green:$00/$FF; Blue:$82/$FF; Alpha:$FF/$FF);
  IVORY               : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$F0/$FF; Alpha:$FF/$FF);
  KHAKI               : TColor = (Red:$F0/$FF; Green:$E6/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  LAVENDER            : TColor = (Red:$E6/$FF; Green:$E6/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LAVENDERBLUSH       : TColor = (Red:$FF/$FF; Green:$F0/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  LAWNGREEN           : TColor = (Red:$7C/$FF; Green:$FC/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LEMONCHIFFON        : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  LIGHTBLUE           : TColor = (Red:$AD/$FF; Green:$D8/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  LIGHTCORAL          : TColor = (Red:$F0/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  LIGHTCYAN           : TColor = (Red:$E0/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  LIGHTGOLDENRODYELLOW: TColor = (Red:$FA/$FF; Green:$FA/$FF; Blue:$D2/$FF; Alpha:$FF/$FF);
  LIGHTGRAY           : TColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTGREEN          : TColor = (Red:$90/$FF; Green:$EE/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  LIGHTGREY           : TColor = (Red:$D3/$FF; Green:$D3/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  LIGHTPINK           : TColor = (Red:$FF/$FF; Green:$B6/$FF; Blue:$C1/$FF; Alpha:$FF/$FF);
  LIGHTSALMON         : TColor = (Red:$FF/$FF; Green:$A0/$FF; Blue:$7A/$FF; Alpha:$FF/$FF);
  LIGHTSEAGREEN       : TColor = (Red:$20/$FF; Green:$B2/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  LIGHTSKYBLUE        : TColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGRAY      : TColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSLATEGREY      : TColor = (Red:$77/$FF; Green:$88/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  LIGHTSTEELBLUE      : TColor = (Red:$B0/$FF; Green:$C4/$FF; Blue:$DE/$FF; Alpha:$FF/$FF);
  LIGHTYELLOW         : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$E0/$FF; Alpha:$FF/$FF);
  LIME                : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  LIMEGREEN           : TColor = (Red:$32/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  LINEN               : TColor = (Red:$FA/$FF; Green:$F0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  MAGENTA             : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  MAROON              : TColor = (Red:$80/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  MEDIUMAQUAMARINE    : TColor = (Red:$66/$FF; Green:$CD/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  MEDIUMBLUE          : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  MEDIUMORCHID        : TColor = (Red:$BA/$FF; Green:$55/$FF; Blue:$D3/$FF; Alpha:$FF/$FF);
  MEDIUMPURPLE        : TColor = (Red:$93/$FF; Green:$70/$FF; Blue:$DB/$FF; Alpha:$FF/$FF);
  MEDIUMSEAGREEN      : TColor = (Red:$3C/$FF; Green:$B3/$FF; Blue:$71/$FF; Alpha:$FF/$FF);
  MEDIUMSLATEBLUE     : TColor = (Red:$7B/$FF; Green:$68/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  MEDIUMSPRINGGREEN   : TColor = (Red:$00/$FF; Green:$FA/$FF; Blue:$9A/$FF; Alpha:$FF/$FF);
  MEDIUMTURQUOISE     : TColor = (Red:$48/$FF; Green:$D1/$FF; Blue:$CC/$FF; Alpha:$FF/$FF);
  MEDIUMVIOLETRED     : TColor = (Red:$C7/$FF; Green:$15/$FF; Blue:$85/$FF; Alpha:$FF/$FF);
  MIDNIGHTBLUE        : TColor = (Red:$19/$FF; Green:$19/$FF; Blue:$70/$FF; Alpha:$FF/$FF);
  MINTCREAM           : TColor = (Red:$F5/$FF; Green:$FF/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  MISTYROSE           : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  MOCCASIN            : TColor = (Red:$FF/$FF; Green:$E4/$FF; Blue:$B5/$FF; Alpha:$FF/$FF);
  NAVAJOWHITE         : TColor = (Red:$FF/$FF; Green:$DE/$FF; Blue:$AD/$FF; Alpha:$FF/$FF);
  NAVY                : TColor = (Red:$00/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  OLDLACE             : TColor = (Red:$FD/$FF; Green:$F5/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  OLIVE               : TColor = (Red:$80/$FF; Green:$80/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  OLIVEDRAB           : TColor = (Red:$6B/$FF; Green:$8E/$FF; Blue:$23/$FF; Alpha:$FF/$FF);
  ORANGE              : TColor = (Red:$FF/$FF; Green:$A5/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORANGERED           : TColor = (Red:$FF/$FF; Green:$45/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ORCHID              : TColor = (Red:$DA/$FF; Green:$70/$FF; Blue:$D6/$FF; Alpha:$FF/$FF);
  PALEGOLDENROD       : TColor = (Red:$EE/$FF; Green:$E8/$FF; Blue:$AA/$FF; Alpha:$FF/$FF);
  PALEGREEN           : TColor = (Red:$98/$FF; Green:$FB/$FF; Blue:$98/$FF; Alpha:$FF/$FF);
  PALETURQUOISE       : TColor = (Red:$AF/$FF; Green:$EE/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  PALEVIOLETRED       : TColor = (Red:$DB/$FF; Green:$70/$FF; Blue:$93/$FF; Alpha:$FF/$FF);
  PAPAYAWHIP          : TColor = (Red:$FF/$FF; Green:$EF/$FF; Blue:$D5/$FF; Alpha:$FF/$FF);
  PEACHPUFF           : TColor = (Red:$FF/$FF; Green:$DA/$FF; Blue:$B9/$FF; Alpha:$FF/$FF);
  PERU                : TColor = (Red:$CD/$FF; Green:$85/$FF; Blue:$3F/$FF; Alpha:$FF/$FF);
  PINK                : TColor = (Red:$FF/$FF; Green:$C0/$FF; Blue:$CB/$FF; Alpha:$FF/$FF);
  PLUM                : TColor = (Red:$DD/$FF; Green:$A0/$FF; Blue:$DD/$FF; Alpha:$FF/$FF);
  POWDERBLUE          : TColor = (Red:$B0/$FF; Green:$E0/$FF; Blue:$E6/$FF; Alpha:$FF/$FF);
  PURPLE              : TColor = (Red:$80/$FF; Green:$00/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  REBECCAPURPLE       : TColor = (Red:$66/$FF; Green:$33/$FF; Blue:$99/$FF; Alpha:$FF/$FF);
  RED                 : TColor = (Red:$FF/$FF; Green:$00/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  ROSYBROWN           : TColor = (Red:$BC/$FF; Green:$8F/$FF; Blue:$8F/$FF; Alpha:$FF/$FF);
  ROYALBLUE           : TColor = (Red:$41/$FF; Green:$69/$FF; Blue:$E1/$FF; Alpha:$FF/$FF);
  SADDLEBROWN         : TColor = (Red:$8B/$FF; Green:$45/$FF; Blue:$13/$FF; Alpha:$FF/$FF);
  SALMON              : TColor = (Red:$FA/$FF; Green:$80/$FF; Blue:$72/$FF; Alpha:$FF/$FF);
  SANDYBROWN          : TColor = (Red:$F4/$FF; Green:$A4/$FF; Blue:$60/$FF; Alpha:$FF/$FF);
  SEAGREEN            : TColor = (Red:$2E/$FF; Green:$8B/$FF; Blue:$57/$FF; Alpha:$FF/$FF);
  SEASHELL            : TColor = (Red:$FF/$FF; Green:$F5/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  SIENNA              : TColor = (Red:$A0/$FF; Green:$52/$FF; Blue:$2D/$FF; Alpha:$FF/$FF);
  SILVER              : TColor = (Red:$C0/$FF; Green:$C0/$FF; Blue:$C0/$FF; Alpha:$FF/$FF);
  SKYBLUE             : TColor = (Red:$87/$FF; Green:$CE/$FF; Blue:$EB/$FF; Alpha:$FF/$FF);
  SLATEBLUE           : TColor = (Red:$6A/$FF; Green:$5A/$FF; Blue:$CD/$FF; Alpha:$FF/$FF);
  SLATEGRAY           : TColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SLATEGREY           : TColor = (Red:$70/$FF; Green:$80/$FF; Blue:$90/$FF; Alpha:$FF/$FF);
  SNOW                : TColor = (Red:$FF/$FF; Green:$FA/$FF; Blue:$FA/$FF; Alpha:$FF/$FF);
  SPRINGGREEN         : TColor = (Red:$00/$FF; Green:$FF/$FF; Blue:$7F/$FF; Alpha:$FF/$FF);
  STEELBLUE           : TColor = (Red:$46/$FF; Green:$82/$FF; Blue:$B4/$FF; Alpha:$FF/$FF);
  TAN                 : TColor = (Red:$D2/$FF; Green:$B4/$FF; Blue:$8C/$FF; Alpha:$FF/$FF);
  TEAL                : TColor = (Red:$00/$FF; Green:$80/$FF; Blue:$80/$FF; Alpha:$FF/$FF);
  THISTLE             : TColor = (Red:$D8/$FF; Green:$BF/$FF; Blue:$D8/$FF; Alpha:$FF/$FF);
  TOMATO              : TColor = (Red:$FF/$FF; Green:$63/$FF; Blue:$47/$FF; Alpha:$FF/$FF);
  TURQUOISE           : TColor = (Red:$40/$FF; Green:$E0/$FF; Blue:$D0/$FF; Alpha:$FF/$FF);
  VIOLET              : TColor = (Red:$EE/$FF; Green:$82/$FF; Blue:$EE/$FF; Alpha:$FF/$FF);
  WHEAT               : TColor = (Red:$F5/$FF; Green:$DE/$FF; Blue:$B3/$FF; Alpha:$FF/$FF);
  WHITE               : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$FF/$FF; Alpha:$FF/$FF);
  WHITESMOKE          : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  YELLOW              : TColor = (Red:$FF/$FF; Green:$FF/$FF; Blue:$00/$FF; Alpha:$FF/$FF);
  YELLOWGREEN         : TColor = (Red:$9A/$FF; Green:$CD/$FF; Blue:$32/$FF; Alpha:$FF/$FF);
  BLANK               : TColor = (Red:$00;     Green:$00;     Blue:$00;     Alpha:$00);
  WHITE2              : TColor = (Red:$F5/$FF; Green:$F5/$FF; Blue:$F5/$FF; Alpha:$FF/$FF);
  RED2                : TColor = (Red:$7E/$FF; Green:$32/$FF; Blue:$3F/$FF; Alpha:255/$FF);
  COLORKEY            : TColor = (Red:$FF/$FF; Green:$00;     Blue:$FF/$FF; Alpha:$FF/$FF);
  OVERLAY1            : TColor = (Red:$00/$FF; Green:$20/$FF; Blue:$29/$FF; Alpha:$B4/$FF);
  OVERLAY2            : TColor = (Red:$01/$FF; Green:$1B/$FF; Blue:$01/$FF; Alpha:255/$FF);
  DIMWHITE            : TColor = (Red:$10/$FF; Green:$10/$FF; Blue:$10/$FF; Alpha:$10/$FF);
  DARKSLATEBROWN      : TColor = (Red:30/255; Green:31/255; Blue:30/255; Alpha:1);
{$ENDREGION}

type
  { TFont }
  TFont = class(TBaseObject)
  private
    FHandle: PALLEGRO_FONT;
    FFilename: string;
    FSize: Integer;
  public
    constructor Create; override;
    destructor Destroy; override;
    function LoadBuiltIn: Boolean;
    function LoadDefault(aSize: Cardinal): Boolean;
    function Load(aArchive: TArchive; aSize: Cardinal; aFilename: string): Boolean;
    function Unload: Boolean;
    procedure PrintText(aX: Single; aY: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aX: Single; var aY: Single; aLineSpace: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const); overload;
    procedure PrintText(aX: Single; aY: Single; aColor: TColor; aAngle: Single; const aMsg: string; const aArgs: array of const); overload;
    function  GetTextWidth(const aMsg: string; const aArgs: array of const): Single;
    function  GetLineHeight: Single;
  end;

  { TTextureData }
  PTextureData = ^TTextureData;
  TTextureData = record
    Memory: Pointer;
    Format: Integer;
    Pitch: Integer;
    PixelSize: Integer;
  end;

  { TTexture }
  TTexture = class(TBaseObject)
  protected
    FHandle: PALLEGRO_BITMAP;
    FWidth: Single;
    FHeight: Single;
    FLocked: Boolean;
    FLockedRegion: TRectangle;
    FFilename: string;
  public
    property Width: Single read FWidth;
    property Height: Single read FHeight;
    property Filename: string read FFilename;
    property Handle: PALLEGRO_BITMAP read FHandle;
    constructor Create; override;
    destructor Destroy; override;
    function  Allocate(aWidth: Integer; aHeight: Integer): Boolean;
    function  Load(aArchive: TArchive; const aFilename: string; aColorKey: PColor): Boolean;
    function Unload: Boolean;
    function Lock(aRegion: PRectangle; aData: PTextureData=nil): Boolean;
    function Unlock: Boolean;
    function  GetPixel(aX: Integer; aY: Integer): TColor;
    procedure SetPixel(aX: Integer; aY: Integer; aColor: TColor);
    procedure Draw(aX, aY: Single; aRegion: PRectangle; aCenter: PVector;  aScale: PVector; aAngle: Single; aColor: TColor; aHFlip: Boolean=False; aVFlip: Boolean=False); overload;
    procedure Draw(aX, aY, aScale, aAngle: Single; aColor: TColor; aHAlign: THAlign; aVAlign: TVAlign; aHFlip: Boolean=False; aVFlip: Boolean=False); overload;
    procedure DrawTiled(aDeltaX: Single; aDeltaY: Single);
  end;

  { TRenderTarget }
  TRenderTarget = class(TBaseObject)
  protected
    FTexture: TTexture;
    FPosition: TVector;
    FRegion: TRectangle;
    FCenter: TVector;
    FActive: Boolean;
    FAngle: Single;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aX, aY, aWidth, aHeight: Integer);
    procedure SetActive(aActive: Boolean);
    function  GetActive: Boolean;
    procedure SetPosition(aX: Single; aY: Single);
    procedure GetPosition(var aPosition: TVector);
    procedure GetSize(var aSize: TRectangle);
    procedure SetRegion(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
    procedure GetRegion(var aRegion: TRectangle);
    procedure SetAngle(aAngle: Single);
    function  GetAngle: Single;
    procedure Show;
  end;

  { TGVShaderType }
  TShaderType = (stVertex=1, stFragment=2);

  { TShader }
  TShader = class(TBaseObject)
  protected
    FHandle: PALLEGRO_SHADER;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Clear;
    function Load(aType: TShaderType; const aSource: string): Boolean; overload;
    function Load(aArchive: TArchive; aType: TShaderType; const aFilename: string): Boolean; overload;
    function Build: Boolean;
    function Enable(aEnable: Boolean): Boolean;
    function Log: string;
    function SetIntUniform(const aName: string; aValue: Integer): Boolean; overload;
    function SetIntUniform(const aName: string; aNumComponents: Integer; aValue: PInteger; aNumElements: Integer): Boolean; overload;
    function SetFloatUniform(const aName: string; aValue: Single): Boolean; overload;
    function SetFloatUniform(const aName: string; aNumComponents: Integer; aValue: System.PSingle; aNumElements: Integer): Boolean; overload;
    function SetBoolUniform(const aName: string; aValue: Boolean): Boolean;
    function SetTextureUniform(const aName: string; aTexture: TTexture): Boolean;
    function SetVec2Uniform(const aName: string; aValue: TVector): Boolean; overload;
    function SetVec2Uniform(const aName: string; aX: Single; aY: Single): Boolean; overload;
  end;

  { TCmdConsoleActionEvent }
  TCmdConsoleActionEvent = procedure of object;

  { TCmdConsoleState }
  TCmdConsoleState = (ccOpen, ccClose);

  { TCmdConsole }
  TCmdConsole = class(TBaseObject)
  protected
  const
    cDefaultSlideSpeed = 60 * 4;
    cDefaultFrameWidth = 2;
    cDefaultMargins = 2;
    cDefaultMaxCmdHistoryCount = 20;
    cDefaultMaxTextLinesCount = 1080;
  protected
  type
    { TState }
    TState = (stInactive, stSlideDown, stSlideUp);
    { TAction }
    PAction = ^TAction;
    TAction = record
      Name: string;
      Discription: string;
      Handler: TCmdConsoleActionEvent;
    end;
  protected
    FEnabled: Boolean;
    FActive: Boolean;
    FSize: TRectangle;
    FPos: TVector;
    FSlider: Double;
    FState: TState;
    FFont: TFont;
    FFontHeight: Single;
    FToggleKey: Integer;
    FSlideSpeed: Single;
    FCmdLine: string;
    FCmdCurPos: Integer;
    FCurFlashTimer: Single;
    FCurFlash: Boolean;
    FTextLines: TStringList;
    FCmdHistory: TStringList;
    FCmdHistoryIndex: Integer;
    FMaxCmdHistoryCount: Integer;
    FMaxTextLinesCount: Integer;
    FCmdActionList: TList;
    FCmdParams: TStringList;
    FLastChar: Integer;
    function ProcessCmd(aName: string; var aWasInternalCmd: Boolean): Boolean;
    procedure Setup;
    procedure Shutdown;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Render;
    procedure Update(aDeltaTime: Double);
  public
    function  GetActive: Boolean;
    procedure LoadFont(aArchive: TArchive; aSize: Cardinal; const aFilename: string);
    procedure Open;
    procedure Close;
    function  Toggle: Boolean;
    procedure SetToggleKey(aKey: Integer);
    procedure SetSlideSpeed(aSpeed: Single);
    procedure ClearCommands;
    procedure AddCommand(const aName: string; const aDiscription: string; aAction: TCmdConsoleActionEvent);
    procedure Enable(aEnable: Boolean);
    function  ParamCount: Integer;
    function  ParamStr(aIndex: Integer): string;
    procedure AddTextLine(const aMsg: string; const aArgs: array of const);
  end;

  { TVideo }
  TVideo = class(TBaseObject)
  protected
    FVoice: PALLEGRO_VOICE;
    FMixer: PALLEGRO_MIXER;
    FHandle: PALLEGRO_VIDEO;
    FLoop: Boolean;
    FPlaying: Boolean;
    FPaused: Boolean;
    FFilename: string;
    procedure Play(aLoop: Boolean; aVolume: Single); overload;
  public
    procedure OnFinished(aHandle: PALLEGRO_VIDEO);
    constructor Create; override;
    destructor Destroy; override;
    function  Load(aArchive: TArchive; const aFilename: string): Boolean;
    function  Unload: Boolean;
    function  GetPause: Boolean;
    procedure SetPause(aPause: Boolean);
    function  GetLooping:  Boolean;
    procedure SetLoping(aLoop: Boolean);
    function  GetPlaying: Boolean;
    procedure SetPlaying(aPlay: Boolean);
    function  GetFilename: string;
    procedure Play(aArchive: TArchive; const aFilename: string; aLoop: Boolean; aVolume: Single); overload;
    procedure Draw(aX: Single; aY: Single; aScale: Single);
    procedure GetSize(aWidth: System.PSingle; aHeight: System.PSingle);
    procedure Seek(aSeconds: Single);
    procedure Rewind;
  end;

  { TAScreenshake }
  TAScreenshake = class
  protected
    FActive: Boolean;
    FDuration: Single;
    FMagnitude: Single;
    FTimer: Single;
    FPos: TVector;
  public
    constructor Create(aDuration: Single; aMagnitude: Single);
    destructor Destroy; override;
    procedure Process(aSpeed: Single; aDeltaTime: Double);
    property Active: Boolean read FActive;
  end;

  { TScreenshake }
  TScreenshake = class(TBaseObject)
  protected
    FTrans: ALLEGRO_TRANSFORM;
    FList: TList;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Process(aSpeed: Single; aDeltaTime: Double);
    procedure Start(aDuration: Single; aMagnitude: Single);
    procedure Clear;
    function  Active: Boolean;
  end;

  { TScreenshot }
  TScreenshot = class(TBaseObject)
  protected
    FFlag: Boolean;
    FDir: string;
    FBaseFilename: string;
    FFilename: string;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Process;
    procedure Init(const aDir: string=''; const aBaseFilename: string='');
    procedure Take;
  end;

  { TStarfield }
  TStarfield = class(TBaseObject)
  protected
    type
      { TItem }
      TItem = record
        X, Y, Z, Speed: Single;
      end;
  protected
    FCenter: TVector;
    FMin: TVector;
    FMax: TVector;
    FViewScaleRatio: Single;
    FViewScale: Single;
    FStarCount: Cardinal;
    FStar: array of TItem;
    FSpeed: TVector;
    FVirtualPos: TVector;
    procedure TransformDrawPoint(aX, aY, aZ: Single; aVPX, aVPY, aVPW, aVPH: Integer);
    procedure Done;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Init(aStarCount: Cardinal; aMinX, aMinY, aMinZ, aMaxX, aMaxY, aMaxZ, aViewScale: Single);
    procedure SetVirtualPos(aX, aY: Single);
    procedure GetVirtualPos(var aX: Single; var aY: Single);
    procedure SetXSpeed(aSpeed: Single);
    procedure SetYSpeed(aSpeed: Single);
    procedure SetZSpeed(aSpeed: Single);
    procedure Update(aDeltaTime: Single);
    procedure Render;
  end;

{$ENDREGION}

{$REGION 'Spark.Window'}
const
  MAX_AXES = 3;
  MAX_STICKS = 16;
  MAX_BUTTONS = 32;
  MOUSE_BUTTON_LEFT = 1;
  MOUSE_BUTTON_RIGHT = 2;
  MOUSE_BUTTON_MIDDLE = 3;

  // sticks
  JOY_STICK_LS = 0;
  JOY_STICK_RS = 1;
  JOY_STICK_LT = 2;
  JOY_STICK_RT = 3;

  // axes
  JOY_AXES_X = 0;
  JOY_AXES_Y = 1;
  JOY_AXES_Z = 2;

  // buttons
  JOY_BTN_A = 0;
  JOY_BTN_B = 1;
  JOY_BTN_X = 2;
  JOY_BTN_Y = 3;
  JOY_BTN_RB = 4;
  JOY_BTN_LB = 5;
  JOY_BTN_RT = 6;
  JOY_BTN_LT = 7;
  JOY_BTN_BACK = 8;
  JOY_BTN_START = 9;
  JOY_BTN_RDPAD = 10;
  JOY_BTN_LDPAD = 11;
  JOY_BTN_DDPAD = 12;
  JOY_BTN_UDPAD = 13;

{$REGION 'Keyboard Constants'}
const
  KEY_A = 1;
  KEY_B = 2;
  KEY_C = 3;
  KEY_D = 4;
  KEY_E = 5;
  KEY_F = 6;
  KEY_G = 7;
  KEY_H = 8;
  KEY_I = 9;
  KEY_J = 10;
  KEY_K = 11;
  KEY_L = 12;
  KEY_M = 13;
  KEY_N = 14;
  KEY_O = 15;
  KEY_P = 16;
  KEY_Q = 17;
  KEY_R = 18;
  KEY_S = 19;
  KEY_T = 20;
  KEY_U = 21;
  KEY_V = 22;
  KEY_W = 23;
  KEY_X = 24;
  KEY_Y = 25;
  KEY_Z = 26;
  KEY_0 = 27;
  KEY_1 = 28;
  KEY_2 = 29;
  KEY_3 = 30;
  KEY_4 = 31;
  KEY_5 = 32;
  KEY_6 = 33;
  KEY_7 = 34;
  KEY_8 = 35;
  KEY_9 = 36;
  KEY_PAD_0 = 37;
  KEY_PAD_1 = 38;
  KEY_PAD_2 = 39;
  KEY_PAD_3 = 40;
  KEY_PAD_4 = 41;
  KEY_PAD_5 = 42;
  KEY_PAD_6 = 43;
  KEY_PAD_7 = 44;
  KEY_PAD_8 = 45;
  KEY_PAD_9 = 46;
  KEY_F1 = 47;
  KEY_F2 = 48;
  KEY_F3 = 49;
  KEY_F4 = 50;
  KEY_F5 = 51;
  KEY_F6 = 52;
  KEY_F7 = 53;
  KEY_F8 = 54;
  KEY_F9 = 55;
  KEY_F10 = 56;
  KEY_F11 = 57;
  KEY_F12 = 58;
  KEY_ESCAPE = 59;
  KEY_TILDE = 60;
  KEY_MINUS = 61;
  KEY_EQUALS = 62;
  KEY_BACKSPACE = 63;
  KEY_TAB = 64;
  KEY_OPENBRACE = 65;
  KEY_CLOSEBRACE = 66;
  KEY_ENTER = 67;
  KEY_SEMICOLON = 68;
  KEY_QUOTE = 69;
  KEY_BACKSLASH = 70;
  KEY_BACKSLASH2 = 71;
  KEY_COMMA = 72;
  KEY_FULLSTOP = 73;
  KEY_SLASH = 74;
  KEY_SPACE = 75;
  KEY_INSERT = 76;
  KEY_DELETE = 77;
  KEY_HOME = 78;
  KEY_END = 79;
  KEY_PGUP = 80;
  KEY_PGDN = 81;
  KEY_LEFT = 82;
  KEY_RIGHT = 83;
  KEY_UP = 84;
  KEY_DOWN = 85;
  KEY_PAD_SLASH = 86;
  KEY_PAD_ASTERISK = 87;
  KEY_PAD_MINUS = 88;
  KEY_PAD_PLUS = 89;
  KEY_PAD_DELETE = 90;
  KEY_PAD_ENTER = 91;
  KEY_PRINTSCREEN = 92;
  KEY_PAUSE = 93;
  KEY_ABNT_C1 = 94;
  KEY_YEN = 95;
  KEY_KANA = 96;
  KEY_CONVERT = 97;
  KEY_NOCONVERT = 98;
  KEY_AT = 99;
  KEY_CIRCUMFLEX = 100;
  KEY_COLON2 = 101;
  KEY_KANJI = 102;
  KEY_PAD_EQUALS = 103;
  KEY_BACKQUOTE = 104;
  KEY_SEMICOLON2 = 105;
  KEY_COMMAND = 106;
  KEY_BACK = 107;
  KEY_VOLUME_UP = 108;
  KEY_VOLUME_DOWN = 109;
  KEY_SEARCH = 110;
  KEY_DPAD_CENTER = 111;
  KEY_BUTTON_X = 112;
  KEY_BUTTON_Y = 113;
  KEY_DPAD_UP = 114;
  KEY_DPAD_DOWN = 115;
  KEY_DPAD_LEFT = 116;
  KEY_DPAD_RIGHT = 117;
  KEY_SELECT = 118;
  KEY_START = 119;
  KEY_BUTTON_L1 = 120;
  KEY_BUTTON_R1 = 121;
  KEY_BUTTON_L2 = 122;
  KEY_BUTTON_R2 = 123;
  KEY_BUTTON_A = 124;
  KEY_BUTTON_B = 125;
  KEY_THUMBL = 126;
  KEY_THUMBR = 127;
  KEY_UNKNOWN = 128;
  KEY_MODIFIERS = 215;
  KEY_LSHIFT = 215;
  KEY_RSHIFT = 216;
  KEY_LCTRL = 217;
  KEY_RCTRL = 218;
  KEY_ALT = 219;
  KEY_ALTGR = 220;
  KEY_LWIN = 221;
  KEY_RWIN = 222;
  KEY_MENU = 223;
  KEY_SCROLLLOCK = 224;
  KEY_NUMLOCK = 225;
  KEY_CAPSLOCK = 226;
  KEY_MAX = 227;
  KEYMOD_SHIFT = $0001;
  KEYMOD_CTRL = $0002;
  KEYMOD_ALT = $0004;
  KEYMOD_LWIN = $0008;
  KEYMOD_RWIN = $0010;
  KEYMOD_MENU = $0020;
  KEYMOD_COMMAND = $0040;
  KEYMOD_SCROLOCK = $0100;
  KEYMOD_NUMLOCK = $0200;
  KEYMOD_CAPSLOCK = $0400;
  KEYMOD_INALTSEQ = $0800;
  KEYMOD_ACCENT1 = $1000;
  KEYMOD_ACCENT2 = $2000;
  KEYMOD_ACCENT3 = $4000;
  KEYMOD_ACCENT4 = $8000;
{$ENDREGION}


type
  { TWindow }
  TWindow = class(TBaseObject)
  protected
    FHandle: PALLEGRO_DISPLAY;
    FTransform: ALLEGRO_TRANSFORM;
    FWidth: Integer;
    FHeight: Integer;
    FScale: Single;
    FHWnd: HWND;
    FDpi: Integer;
    FRenderTarget: TRenderTarget;
    procedure ScaleWindowToDPI;
  public
    property Handle: PALLEGRO_DISPLAY read FHandle;
    property Scale: Single read FScale;
    property Dpi: Integer read FDpi;
    property Width: Integer read FWidth;
    property Height: Integer read FHeight;
    property Transform: ALLEGRO_TRANSFORM read FTransform;
    constructor Create; override;
    destructor Destroy; override;
    procedure Open(aWidth, aHeight: Integer; const aTitle: string);
    procedure Close;
    procedure SetTitle(aTitle: string);
    function  IsOpen: Boolean;
    procedure Clear(aColor: TColor);
    procedure Show;
    procedure ResetTransform;
    procedure Save(const aFilename: string);
    procedure GetViewportSize(var aSize: TRectangle);
    procedure SetRenderTarget(aRenderTarget: TRenderTarget);
    procedure SetTransformPos(aX: Single; aY: Single);

    // --- Blending ---------------------------------------------------------
    procedure SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
    procedure GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
    procedure SetBlendColor(aColor: TColor);
    function  GetBlendColor: TColor;
    procedure SetBlendMode(aMode: TBlendMode);
    procedure SetBlendModeColor(aMode: TBlendModeColor; aColor: TColor);
    procedure RestoreDefaultBlendMode;

    // --- Primitives -------------------------------------------------------
    procedure DrawLine(aX1, aY1, aX2, aY2, aThickness: Single; aColor: TColor);
    procedure DrawRectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TColor);
    procedure DrawFilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TColor);
    procedure DrawCircle(aX, aY, aRadius, aThickness: Single; aColor: TColor);
    procedure DrawFilledCircle(aX, aY, aRadius: Single; aColor: TColor);
    procedure DrawTriangle(aX1, aY1, aX2, aY2, aX3, aY3, aThickness: Single; aColor: TColor);
    procedure DrawFilledTriangle(aX1, aY1, aX2, aY2, aX3, aY3: Single; aColor: TColor);
    procedure DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TColor);
    procedure DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TColor);

  end;

  { TJoystick }
  TJoystick = record
    Name: string;
    Sticks: Integer;
    Buttons: Integer;
    StickName: array[0..MAX_STICKS-1] of string;
    Axes: array[0..MAX_STICKS-1] of Integer;
    AxesName: array[0..MAX_STICKS-1, 0..MAX_AXES-1] of string;
    Pos: array[0..MAX_STICKS-1, 0..MAX_AXES-1] of Single;
    Button: array[0..1, 0..MAX_BUTTONS-1] of Boolean;
    ButtonName: array[0..MAX_BUTTONS- 1] of string;
    procedure Setup(aNum: Integer);
    function GetPos(aStick: Integer; aAxes: Integer): Single;
    function GetButton(aButton: Integer): Boolean;
    procedure Clear;
  end;

  { TInput }
  TInput = class(TBaseObject)
  protected
  type
    TMouse = record
      Postion: TVector;
      Delta: TVector;
      Pressure: Single;
    end;
  protected
    FKeyCode: Integer;
    FKeyCodeRepeat: Boolean;
    FMouseButtons: array [0..1, 0..256] of Boolean;
    FKeyButtons: array [0..1, 0..256] of Boolean;
    FJoyStick: TJoystick;
    FMouse: TMouse;
  public
    constructor Create; override;
    destructor Destroy; override;
    property KeyCode: Integer read FKeyCode;
    property KeyCodeRepeat: Boolean read FKeyCodeRepeat;
    procedure Clear;
    procedure Update;
    function  KeyDown(aKey: Cardinal): Boolean;
    function  KeyPressed(aKey: Cardinal): Boolean;
    function  KeyReleased(aKey: Cardinal): Boolean;
    function  MouseDown(aButton: Cardinal): Boolean;
    function  MousePressed(aButton: Cardinal): Boolean;
    function  MouseReleased(aButton: Cardinal): Boolean;
    procedure MouseSetPos(aX: Integer; aY: Integer);
    procedure GetMouseInfo(aPosition: PVector; aDelta: PVector; aPressure: System.PSingle);
    function  JoystickDown(aButton: Cardinal): Boolean;
    function  JoystickPressed(aButton: Cardinal): Boolean;
    function  JoystickReleased(aButton: Cardinal): Boolean;
    function  JoystickPosition(aStick: Integer; aAxes: Integer): Single;
  end;

{$ENDREGION}

{$REGION 'Spark.Audio'}
const
  AUDIO_CHANNEL_COUNT   = 16;
  AUDIO_PAN_NONE        = -1000.0;

type
  { TSample }
  TSample = type PALLEGRO_SAMPLE;

  { TSampleID }
  PSampleID = ^TSampleID;
  TSampleID = record
    Index: Integer;
    Id: Integer;
  end;

  { TAudio }
  TAudio = class(TBaseObject)
  protected
    FMusic: PALLEGRO_AUDIO_STREAM;
    FMusicFilename: string;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Pause(aPause: Boolean);
    procedure Clear;
    procedure LoadMusic(aArchive: TArchive; const aFilename: string);
    procedure UnloadMusic;
    procedure PlayMusic(aVolume: Single; aLoop: Boolean); overload;
    procedure PlayMusic(aArchive: TArchive; const aFilename: string; aVolume: Single; aLoop: Boolean); overload;
    procedure StopMusic;
    function  GetMusicLooping: Boolean;
    procedure SetMusicLooping(aLoop: Boolean);
    function  GetMusicPlaying: Boolean;
    procedure SetMusicPlaying(aPlay: Boolean);
    procedure SetMusicVolume(aVolume: Single);
    function  GetMusicVolume: Single;
    procedure SeekMusic(aTime: Single);
    procedure RewindMusic(aTime: Single);
    function  ReserveSampleChannels(aCount: Integer): Boolean;
    function  LoadSample(aArchive: TArchive; const aFilename: string): TSample;
    procedure UnloadSample(var aSample: TSample);
    procedure PlaySample(aSample: TSample; aVolume: Single; aPan: Single; aSpeed: Single; aLoop: Boolean; aId: PSampleID);
    procedure StopSample(aID: TSampleID);
    procedure StopAllSamples;
    function  GetSamplePlaying(aID: TSampleID): Boolean;
  end;

{$ENDREGION}

{$REGION 'Spark.Game'}
type
  { TCustomGameClass }
  TCustomGameClass = class of TCustomGame;

  { TCustomGame }
  TCustomGame = class(TBaseObject)
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure OnInit; virtual;
    procedure OnDone; virtual;
    procedure OnRun; virtual;
  end;

  { TGameSettings }
  TGameSettings = record
    // Window
    WindowWidth: Integer;
    WindowHeight: Integer;
    WindowTitle: string;
    WindowClearColor: TColor;

    // ConfigFile
    ConfigFilename: string;

    // Archive
    ArchivePassword: string;
    ArchiveFilename: string;

    // Font
    FontSize: Cardinal;
    FontFilename: string;

    // Hud
    HudTextItemPadWidth: Integer;
    HudPosX: Integer;
    HudPosY: Integer;
    HudLineSpace: Integer;
  end;

  { TGame }
  TGame = class(TCustomGame)
  protected
  type
    { TTimer }
    TTimer = record
      LNow: Double;
      Passed: Double;
      Last: Double;
      Accumulator: Double;
      FrameAccumulator: Double;
      DeltaTime: Double;
      FrameCount: Cardinal;
      FrameRate: Cardinal;
      UpdateSpeed: Single;
      FixedUpdateSpeed: Single;
      FixedUpdateTimer: Single;
    end;
    { THud }
    THud = record
      TextItemPadWidth: Integer;
      Pos: TVector;
    end;
  protected
    FTerminate: Boolean;
    FReady: Boolean;
    FMousePos: TVector;
    FMouseDelta: TVector;
    FMousePressure: Single;
    FTimer: TTimer;
    FConfigFile: TConfigFile;
    FArchive: TArchive;
    FFont: TFont;
    FSettings: TGameSettings;
    FHud: THud;
    procedure UpdateTiming;
  public
    property Terminate: Boolean read FTerminate write FTerminate;
    property MousePos: TVector read FMousePos;
    property MouseDelta: TVector read FMouseDelta;
    property MousePressure: Single read FMousePressure;
    property Settings: TGameSettings read FSettings;
    property ConfigFile: TConfigFile read FConfigFile;
    property Archive: TArchive read FArchive;
    property Font: TFont read FFont;
    constructor Create; override;
    destructor Destroy; override;
    procedure OnInit; override;
    procedure OnDone; override;
    procedure OnSetSettings(var aSettings: TGameSettings); virtual;
    procedure OnApplySettings; virtual;
    procedure OnUnapplySettings; virtual;
    procedure OnStartup; virtual;
    procedure OnShutdown; virtual;
    procedure OnRun; override;
    procedure OnReady(aReady: Boolean); virtual;
    procedure OnUpdate(aDeltaTime: Double); virtual;
    procedure OnFixedUpdate; virtual;
    procedure OnClearWindow; virtual;
    procedure OnShowWindow; virtual;
    procedure OnRender; virtual;
    procedure OnRenderHUD; virtual;
    procedure OnPreShowWindow; virtual;
    procedure OnPostShowWindow; virtual;
    procedure OnCmdConsoleState(aState: TCmdConsoleState); virtual;
    procedure OnVideoState(aState: TVideoState; aFilename: string); virtual;
    procedure OnScreenshot(const aFilename: string); virtual;
    function  GetTime: Double;
    procedure ResetTiming(aSpeed: Single=0; aFixedSpeed: Single=0);
    procedure SetUpdateSpeed(aSpeed: Single);
    function  GetUpdateSpeed: Single;
    procedure SetFixedUpdateSpeed(aSpeed: Single);
    function  GetFixedUpdateSpeed: Single;
    function  GetDeltaTime: Double;
    function  GetFrameRate: Cardinal;
    function  FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
    function  FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;
    procedure ResetHudPos;
    procedure SetHudPos(aX: Integer; aY: Integer);
    procedure SetHudLineSpace(aLineSpace: Integer);
    procedure SetHudTextItemPadWidth(aWidth: Integer);
    procedure HudText(aFont: TFont; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
    function  HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;
  end;

{ Variables }
var
  Game: TGame = nil;

{ Routines }
procedure RunGame(aGame: TCustomGameClass);

{$ENDREGION}

{$REGION 'Spark.Core'}
const
  EVENT_CMDCON_ACTIVE   = 10000;
  EVENT_CMDCON_INACTIVE = 10001;

type

  { TSGT }
  TSGT = class(TBaseObject)
  protected
    FCodePage: Cardinal;
    FEvent: ALLEGRO_EVENT;
    FQueue: PALLEGRO_EVENT_QUEUE;
    FVoice: PALLEGRO_VOICE;
    FMixer: PALLEGRO_MIXER;
    FFileState: array[False..True] of ALLEGRO_STATE;
    FFileInterface: array[False..True] of PALLEGRO_FILE_INTERFACE;
    FUserEventSrc: ALLEGRO_EVENT_SOURCE;
    FCmdConActive: ALLEGRO_EVENT;
    FCmdConInactive: ALLEGRO_EVENT;
    FLog: TLog;
    FInput: TInput;
    FWindow: TWindow;
    FCmdConsole: TCmdConsole;
    FAudio: TAudio;
    FVideo: TVideo;
    FScreenshake: TScreenshake;
    FScreenshot: TScreenshot;
    procedure Startup;
    procedure Shutdown;
  public
    property Event: ALLEGRO_EVENT read FEvent write FEVent;
    property Queue: PALLEGRO_EVENT_QUEUE read FQueue write FQueue;
    property Voice: PALLEGRO_VOICE read FVoice write FVoice;
    property Mixer: PALLEGRO_MIXER read FMixer write FMixer;
    property Log: TLog read FLog;
    property Window: TWindow read FWindow;
    property Input: TInput read FInput;
    property CmdConsole: TCmdConsole read FCmdConsole;
    property Audio: TAudio read FAudio;
    property Video: TVideo read FVideo;
    property Screenshake: TScreenshake read FScreenshake;
    property Screenshot: TScreenshot read FScreenshot;
    constructor Create; override;
    destructor Destroy; override;
    procedure SetFileSandBoxed(aEnable: Boolean);
    function  GetFileSandBoxed: Boolean;
    procedure SetFileSandboxWriteDir(aPath: string);
    function  GetFileSandboxWriteDir: string;
    procedure EmitCmdConInactiveEvent;
    procedure EmitCmdConActiveEvent;
    procedure RunGame(aGame: TCustomGameClass);
  end;

var
  SGT: TSGT = nil;

{$ENDREGION}

implementation

{$REGION 'Spark.Math'}
var
  mCosTable: array [0 .. 360] of Single;
  mSinTable: array [0 .. 360] of Single;

{ TVector }
constructor TVector.Create(aX, aY: Single);
begin
  X := aX;
  Y := aY;
  Z := 0;
  W := 0;
end;

constructor TVector.Create(aX, aY, aZ: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := 0;
end;

constructor TVector.Create(aX, aY, aZ, aW: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := aW;
end;

procedure TVector.Assign(aX, aY: Single);
begin
  X := aX;
  Y := aY;
  Z := 0;
  W := 0;
end;

procedure TVector.Assign(aX, aY, aZ: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := 0;
end;

procedure TVector.Assign(aX, aY, aZ, aW: Single);
begin
  X := aX;
  Y := aY;
  Z := aZ;
  W := aW;
end;

procedure TVector.Assign(aVector: TVector);
begin
  Self := aVector;
end;

procedure TVector.Clear;
begin
  X := 0;
  Y := 0;
  Z := 0;
  W := 0;
end;

procedure TVector.Add(aVector: TVector);
begin
  X := X + aVector.X;
  Y := Y + aVector.Y;
end;

procedure TVector.Subtract(aVector: TVector);
begin
  X := X - aVector.X;
  Y := Y - aVector.Y;
end;

procedure TVector.Multiply(aVector: TVector);
begin
  X := X * aVector.X;
  Y := Y * aVector.Y;
end;

procedure TVector.Divide(aVector: TVector);
begin
  X := X / aVector.X;
  Y := Y / aVector.Y;
end;

function  TVector.Magnitude: Single;
begin
  Result := Sqrt((X * X) + (Y * Y));
end;

function  TVector.MagnitudeTruncate(aMaxMagitude: Single): TVector;
var
  LMaxMagSqrd: Single;
  LVecMagSqrd: Single;
  LTruc: Single;
begin
  Result.Assign(X, Y);
  LMaxMagSqrd := aMaxMagitude * aMaxMagitude;
  LVecMagSqrd := Result.Magnitude;
  if LVecMagSqrd > LMaxMagSqrd then
  begin
    LTruc := (aMaxMagitude / Sqrt(LVecMagSqrd));
    Result.X := Result.X * LTruc;
    Result.Y := Result.Y * LTruc;
  end;
end;

function  TVector.Distance(aVector: TVector): Single;
var
  LDirVec: TVector;
begin
  LDirVec.X := X - aVector.X;
  LDirVec.Y := Y - aVector.Y;
  Result := LDirVec.Magnitude;
end;

procedure TVector.Normalize;
var
  LLen, LOOL: Single;
begin
  LLen := self.Magnitude;
  if LLen <> 0 then
  begin
    LOOL := 1.0 / LLen;
    X := X * LOOL;
    Y := Y * LOOL;
  end;
end;

function  TVector.Angle(aVector: TVector): Single;
var
  LXOY: Single;
  LR: TVector;
begin
  LR.Assign(self);
  LR.Subtract(aVector);
  LR.Normalize;

  if LR.Y = 0 then
  begin
    LR.Y := 0.001;
  end;

  LXOY := LR.X / LR.Y;

  Result := ArcTan(LXOY) * RAD2DEG;
  if LR.Y < 0 then
    Result := Result + 180.0;
end;

procedure TVector.Thrust(aAngle: Single; aSpeed: Single);
var
  LA: Single;

begin
  LA := aAngle + 90.0;

  ClipValue(LA, 0, 360, True);

  X := X + AngleCos(Round(LA)) * -(aSpeed);
  Y := Y + AngleSin(Round(LA)) * -(aSpeed);
end;

function  TVector.MagnitudeSquared: Single;
begin
  Result := (X * X) + (Y * Y);
end;

function  TVector.DotProduct(aVector: TVector): Single;
begin
  Result := (X * aVector.X) + (Y * aVector.Y);
end;

procedure TVector.Scale(aValue: Single);
begin
  X := X * aValue;
  Y := Y * aValue;
end;

procedure TVector.DivideBy(aValue: Single);
begin
  X := X / aValue;
  Y := Y / aValue;
end;

function  TVector.Project(aVector: TVector): TVector;
var
  LDP: Single;
begin
  LDP := DotProduct(aVector);
  Result.X := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.X;
  Result.Y := (LDP / (aVector.X * aVector.X + aVector.Y * aVector.Y)) * aVector.Y;
end;

procedure TVector.Negate;
begin
  X := -X;
  Y := -Y;
end;

{ TRectangle }
constructor TRectangle.Create(aX, aY, aWidth, aHeight: Single);
begin
  X := aX;
  Y := aY;
  Width := aWidth;
  Height := aHeight;
end;

procedure TRectangle.Assign(aX, aY, aWidth, aHeight: Single);
begin
  X := aX;
  Y := aY;
  Width := aWidth;
  Height := aHeight;
end;

procedure TRectangle.Assign(aRectangle: TRectangle);
begin
  X := aRectangle.X;
  Y := aRectangle.Y;
  Width := aRectangle.Width;
  Height := aRectangle.Height;
end;

procedure TRectangle.Clear;
begin
  X := 0;
  Y := 0;
  Width := 0;
  Height := 0;
end;

function TRectangle.Intersect(aRect: TRectangle): Boolean;
var
  LR1R, LR1B: Single;
  LR2R, LR2B: Single;
begin
  LR1R := X - (Width - 1);
  LR1B := Y - (Height - 1);
  LR2R := aRect.X - (aRect.Width - 1);
  LR2B := aRect.Y - (aRect.Height - 1);

  Result := (X < LR2R) and (LR1R > aRect.X) and (Y < LR2B) and (LR1B > aRect.Y);
end;

function _RandomRange(const aFrom, aTo: Integer): Integer;
var
  LFrom: Integer;
  LTo: Integer;
begin
  LFrom := aFrom;
  LTo := aTo;

  if AFrom > ATo then
    Result := Random(LFrom - LTo) + ATo
  else
    Result := Random(LTo - LFrom) + AFrom;
end;

{ Routines }
function Min(const A, B: Int64): Int64;
begin
  if A < B then
    Result := A
  else
    Result := B;
end;

function Min(const A, B: UInt64): UInt64;
begin
  if A < B then
    Result := A
  else
    Result := B;
end;

function Min(const A, B: Double): Double;
begin
  if A < B then
    Result := A
  else
    Result := B;
end;

function Max(const A, B: Int64): Int64;
begin
  if A > B then
    Result := A
  else
    Result := B;
end;

function Max(const A, B: UInt64): UInt64;
begin
  if A > B then
    Result := A
  else
    Result := B;
end;

function Max(const A, B: Double): Double;
begin
  if A > B then
    Result := A
  else
    Result := B;
end;

function Sign(const aValue: Int64): Integer;
begin
  Result := 0;
  if aValue < 0 then
    Result := -1
  else if aValue > 0 then
    Result := 1;
end;

function Sign(const aValue: Double): Integer;
begin
  Result := 0;
  if aValue < 0 then
    Result := -1
  else if aValue > 0 then
    Result := 1;
end;

function InRange(const AValue, AMin, AMax: Int64): Boolean;
var
  A, B: Boolean;
begin
  A := (AValue >= AMin);
  B := (AValue <= AMax);
  Result := B and A;
end;

function InRange(const AValue, AMin, AMax: UInt64): Boolean;
var
  A, B: Boolean;
begin
  A := (AValue >= AMin);
  B := (AValue <= AMax);
  Result := B and A;
end;

function InRange(const AValue, AMin, AMax: Double): Boolean;
var
  A, B: Boolean;
begin
  A := (AValue >= AMin);
  B := (AValue <= AMax);
  Result := B and A;
end;

function EnsureRange(const aValue, aMin, aMax: Int64): Int64;
begin
  assert(aMin <= aMax);
  if aValue < aMin then
    Result := aMin
  else if aValue > aMax then
    Result := aMax
  else
    Result := aValue;
end;

function EnsureRange(const aValue, aMin, aMax: UInt64): UInt64;
begin
  assert(aMin <= aMax);
  if aValue < aMin then
    Result := aMin
  else if aValue > aMax then
    Result := aMax
  else
    Result := aValue;
end;

function EnsureRange(const aValue, aMin, aMax: Double): Double;
begin
  assert(aMin <= aMax);
  if aValue < aMin then
    Result := aMin
  else if aValue > aMax then
    Result := aMax
  else
    Result := aValue;
end;

function Floor(const X: Extended): Integer;
begin
  Result := Integer(Trunc(X));
  if Frac(X) < 0 then
    Dec(Result);
end;

function IntPower(const Base: Extended; const Exponent: Integer): Extended;
var
  Y: Integer;
  LBase: Extended;
begin
  Y := Abs(Exponent);
  LBase := Base;
  Result := 1.0;
  while Y > 0 do
  begin
    while not Odd(Y) do
    begin
      Y := Y shr 1;
      LBase := LBase * LBase
    end;
    Dec(Y);
    Result := Result * LBase
  end;
  if Exponent < 0 then
    Result := 1.0 / Result;
end;

function Power(const Base, Exponent: Extended): Extended;
begin
  if Exponent = 0.0 then
    Result := 1.0               { n**0 = 1 }
  else if (Base = 0.0) and (Exponent > 0.0) then
    Result := 0.0               { 0**n = 0, n > 0 }
  else if (Frac(Exponent) = 0.0) and (Abs(Exponent) <= MaxInt) then
    Result := IntPower(Base, Integer(Trunc(Exponent)))
  else if Base < 0 then
  begin
    Result := Nan; // Return NaN (not a number) if base is less than zero and Exponent is not natural number
  end
  else
    Result := Exp(Exponent * Ln(Base));
end;

function  RandomRange(aMin, aMax: Integer): Integer;
begin
  Result := _RandomRange(aMin, aMax + 1);
end;

function  RandomRange(aMin, aMax: Single): Single;
var
  LNum: Single;
begin
  LNum := _RandomRange(0, MaxInt) / MaxInt;
  Result := aMin + (LNum * (aMax - aMin));
end;

function  RandomBool: Boolean;
begin
  Result := Boolean(_RandomRange(0, 2) = 1);
end;

function  GetRandomSeed: Integer;
begin
  Result := System.RandSeed;
end;

procedure SetRandomSeed(aValue: Integer);
begin
  System.RandSeed := aValue;
end;

function  AngleCos(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := mCosTable[aAngle];
end;

function  AngleSin(aAngle: Integer): Single;
begin
  Result := 0;
  if (aAngle < 0) or (aAngle > 360) then Exit;
  Result := mSinTable[aAngle];
end;

function  AngleDifference(aSrcAngle: Single; aDestAngle: Single): Single;
var
  LC: Single;
begin
  LC := aDestAngle - aSrcAngle -
    (Floor((aDestAngle - aSrcAngle) / 360.0) * 360.0);

  if LC >= (360.0 / 2) then
  begin
    LC := LC - 360.0;
  end;
  Result := LC;
end;

procedure AngleRotatePos(aAngle: Single; var aX: Single; var aY: Single);
var
  LNX, LNY: Single;
  LIA: Integer;
begin
  ClipValue(aAngle, 0, 359, True);

  LIA := Round(aAngle);

  LNX := aX * mCosTable[LIA] - aY * mSinTable[LIA];
  LNY := aY * mCosTable[LIA] + aX * mSinTable[LIA];

  aX := LNX;
  aY := LNY;
end;

function  ClipValue(var aValue: Single; aMin: Single; aMax: Single; aWrap: Boolean): Single;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;

end;

function  ClipValue(var aValue: Integer; aMin: Integer; aMax: Integer; aWrap: Boolean): Integer;
begin
  if aWrap then
    begin
      if (aValue > aMax) then
      begin
        aValue := aMin + Abs(aValue - aMax);
        if aValue > aMax then
          aValue := aMax;
      end
      else if (aValue < aMin) then
      begin
        aValue := aMax - Abs(aValue - aMin);
        if aValue < aMin then
          aValue := aMin;
      end
    end
  else
    begin
      if aValue < aMin then
        aValue := aMin
      else if aValue > aMax then
        aValue := aMax;
    end;

  Result := aValue;
end;

function  SameSign(aValue1: Integer; aValue2: Integer): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function  SameSign(aValue1: Single; aValue2: Single): Boolean;
begin
  if Sign(aValue1) = Sign(aValue2) then
    Result := True
  else
    Result := False;
end;

function  SameValue(aA: Double; aB: Double; aEpsilon: Double = 0): Boolean;
const
  cFuzzFactor = 1000;
  cDoubleResolution   = 1E-15 * cFuzzFactor;
begin
  if aEpsilon = 0 then
    aEpsilon := Max(Min(Abs(aA), Abs(aB)) * cDoubleResolution, cDoubleResolution);
  if aA > aB then
    Result := (aA - aB) <= aEpsilon
  else
    Result := (aB - aA) <= aEpsilon;
end;

function  SameValue(aA: Single; aB: Single; aEpsilon: Single = 0): Boolean;
begin
  Result := SameValue(aA, aB, aEpsilon);
end;

function  Vector(aX: Single; aY: Single): TVector;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Z := 0;
  Result.Z := 0;
  Result.W := 0;
end;

function  Rectangle(aX: Single; aY: Single; aWidth: Single; aHeight: Single): TRectangle;
begin
  Result.X := aX;
  Result.Y := aY;
  Result.Width := aWidth;
  Result.Height := aHeight;
end;

procedure SmoothMove(var aValue: Single; aAmount: Single; aMax: Single; aDrag: Single);
var
  LAmt: Single;
begin
  LAmt := aAmount;

  if LAmt > 0 then
  begin
    aValue := aValue + LAmt;
    if aValue > aMax then
      aValue := aMax;
  end else if LAmt < 0 then
  begin
    aValue := aValue + LAmt;
    if aValue < -aMax then
      aValue := -aMax;
  end else
  begin
    if aValue > 0 then
    begin
      aValue := aValue - aDrag;
      if aValue < 0 then
        aValue := 0;
    end else if aValue < 0 then
    begin
      aValue := aValue + aDrag;
      if aValue > 0 then
        aValue := 0;
    end;
  end;
end;

function  Lerp(aFrom: Double; aTo: Double; aTime: Double): Double;
begin
  if aTime <= 0.5 then
    Result := aFrom + (aTo - aFrom) * aTime
  else
    Result := aTo - (aTo - aFrom) * (1.0 - aTime);
end;

// --- Collision --------------------------------------------------------
function  PointInRectangle(aPoint: TVector; aRect: TRectangle): Boolean;
begin
  if ((aPoint.x >= aRect.x) and (aPoint.x <= (aRect.x + aRect.width)) and
    (aPoint.y >= aRect.y) and (aPoint.y <= (aRect.y + aRect.height))) then
    Result := True
  else
    Result := False;
end;

function  PointInCircle(aPoint, aCenter: TVector; aRadius: Single): Boolean;
begin
  Result := CirclesOverlap(aPoint, 0, aCenter, aRadius);
end;

function  PointInTriangle(aPoint, aP1, aP2, aP3: TVector): Boolean;
var
  LAlpha, LBeta, LGamma: Single;
begin
  LAlpha := ((aP2.y - aP3.y) * (aPoint.x - aP3.x) + (aP3.x - aP2.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LBeta := ((aP3.y - aP1.y) * (aPoint.x - aP3.x) + (aP1.x - aP3.x) *
    (aPoint.y - aP3.y)) / ((aP2.y - aP3.y) * (aP1.x - aP3.x) + (aP3.x - aP2.x) *
    (aP1.y - aP3.y));

  LGamma := 1.0 - LAlpha - LBeta;

  if ((LAlpha > 0) and (LBeta > 0) and (LGamma > 0)) then
    Result := True
  else
    Result := False;
end;

function  CirclesOverlap(aCenter1: TVector; aRadius1: Single; aCenter2: TVector; aRadius2: Single): Boolean;
var
  LDX, LDY, LDistance: Single;
begin
  LDX := aCenter2.x - aCenter1.x; // X distance between centers
  LDY := aCenter2.y - aCenter1.y; // Y distance between centers

  LDistance := sqrt(LDX * LDX + LDY * LDY); // Distance between centers

  if (LDistance <= (aRadius1 + aRadius2)) then
    Result := True
  else
    Result := False;
end;

function  CircleInRectangle(aCenter: TVector; aRadius: Single; aRect: TRectangle): Boolean;
var
  LDX, LDY: Single;
  LCornerDistanceSq: Single;
  LRecCenterX: Integer;
  LRecCenterY: Integer;
begin
  LRecCenterX := Round(aRect.x + aRect.width / 2);
  LRecCenterY := Round(aRect.y + aRect.height / 2);

  LDX := abs(aCenter.x - LRecCenterX);
  LDY := abs(aCenter.y - LRecCenterY);

  if (LDX > (aRect.width / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDY > (aRect.height / 2.0 + aRadius)) then
  begin
    Result := False;
    Exit;
  end;

  if (LDX <= (aRect.width / 2.0)) then
  begin
    Result := True;
    Exit;
  end;
  if (LDY <= (aRect.height / 2.0)) then
  begin
    Result := True;
    Exit;
  end;

  LCornerDistanceSq := (LDX - aRect.width / 2.0) * (LDX - aRect.width / 2.0) +
    (LDY - aRect.height / 2.0) * (LDY - aRect.height / 2.0);

  Result := Boolean(LCornerDistanceSq <= (aRadius * aRadius));
end;

function  RectanglesOverlap(aRect1: TRectangle; aRect2: TRectangle): Boolean;
var
  LDX, LDY: Single;
begin
  LDX := abs((aRect1.x + aRect1.width / 2) - (aRect2.x + aRect2.width / 2));
  LDY := abs((aRect1.y + aRect1.height / 2) - (aRect2.y + aRect2.height / 2));

  if ((LDX <= (aRect1.width / 2 + aRect2.width / 2)) and
    ((LDY <= (aRect1.height / 2 + aRect2.height / 2)))) then
    Result := True
  else
    Result := False;
end;

function  RectangleIntersection(aRect1, aRect2: TRectangle): TRectangle;
var
  LDXX, LDYY: Single;
begin
  Result.Assign(0, 0, 0, 0);

  if RectanglesOverlap(aRect1, aRect2) then
  begin
    LDXX := abs(aRect1.x - aRect2.x);
    LDYY := abs(aRect1.y - aRect2.y);

    if (aRect1.x <= aRect2.x) then
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect2.x;
        Result.y := aRect2.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect2.x;
        Result.y := aRect1.y;
        Result.width := aRect1.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end
    else
    begin
      if (aRect1.y <= aRect2.y) then
      begin
        Result.x := aRect1.x;
        Result.y := aRect2.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect1.height - LDYY;
      end
      else
      begin
        Result.x := aRect1.x;
        Result.y := aRect1.y;
        Result.width := aRect2.width - LDXX;
        Result.height := aRect2.height - LDYY;
      end
    end;

    if (aRect1.width > aRect2.width) then
    begin
      if (Result.width >= aRect2.width) then
        Result.width := aRect2.width;
    end
    else
    begin
      if (Result.width >= aRect1.width) then
        Result.width := aRect1.width;
    end;

    if (aRect1.height > aRect2.height) then
    begin
      if (Result.height >= aRect2.height) then
        Result.height := aRect2.height;
    end
    else
    begin
      if (Result.height >= aRect1.height) then
        Result.height := aRect1.height;
    end
  end;
end;

function  LineIntersection(aX1, aY1, aX2, aY2, aX3, aY3, aX4, aY4: Integer; var aX: Integer; var aY: Integer): TLineIntersection;
var
  LAX, LBX, LCX, LAY, LBY, LCY, LD, LE, LF, LNum: Integer;
  LOffset: Integer;
  LX1Lo, LX1Hi, LY1Lo, LY1Hi: Integer;
begin
  Result := liNone;

  LAX := aX2 - aX1;
  LBX := aX3 - aX4;

  if (LAX < 0) then // X bound box test
  begin
    LX1Lo := aX2;
    LX1Hi := aX1;
  end
  else
  begin
    LX1Hi := aX2;
    LX1Lo := aX1;
  end;

  if (LBX > 0) then
  begin
    if (LX1Hi < aX4) or (aX3 < LX1Lo) then
      Exit;
  end
  else
  begin
    if (LX1Hi < aX3) or (aX4 < LX1Lo) then
      Exit;
  end;

  LAY := aY2 - aY1;
  LBY := aY3 - aY4;

  if (LAY < 0) then // Y bound box test
  begin
    LY1Lo := aY2;
    LY1Hi := aY1;
  end
  else
  begin
    LY1Hi := aY2;
    LY1Lo := aY1;
  end;

  if (LBY > 0) then
  begin
    if (LY1Hi < aY4) or (aY3 < LY1Lo) then
      Exit;
  end
  else
  begin
    if (LY1Hi < aY3) or (aY4 < LY1Lo) then
      Exit;
  end;

  LCX := aX1 - aX3;
  LCY := aY1 - aY3;
  LD := LBY * LCX - LBX * LCY; // alpha numerator
  LF := LAY * LBX - LAX * LBY; // both denominator

  if (LF > 0) then // alpha tests
  begin
    if (LD < 0) or (LD > LF) then
      Exit;
  end
  else
  begin
    if (LD > 0) or (LD < LF) then
      Exit
  end;

  LE := LAX * LCY - LAY * LCX; // beta numerator
  if (LF > 0) then // beta tests
  begin
    if (LE < 0) or (LE > LF) then
      Exit;
  end
  else
  begin
    if (LE > 0) or (LE < LF) then
      Exit;
  end;

  // compute intersection coordinates

  if (LF = 0) then
  begin
    Result := liParallel;
    Exit;
  end;

  LNum := LD * LAX; // numerator
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then

    LOffset := LF div 2
  else
    LOffset := -LF div 2;
  aX := aX1 + (LNum + LOffset) div LF; // intersection x

  LNum := LD * LAY;
  // if SameSigni(num, f) then
  if Sign(LNum) = Sign(LF) then
    LOffset := LF div 2
  else
    LOffset := -LF div 2;

  aY := aY1 + (LNum + LOffset) div LF; // intersection y

  Result := liTrue;
end;

function  RadiusOverlap(aRadius1, aX1, aY1, aRadius2, aX2, aY2, aShrinkFactor: Single): Boolean;
var
  LDist: Single;
  LR1, LR2: Single;
  LV1, LV2: TVector;
begin
  LR1 := aRadius1 * aShrinkFactor;
  LR2 := aRadius2 * aShrinkFactor;

  LV1.x := aX1;
  LV1.y := aY1;
  LV2.x := aX2;
  LV2.y := aY2;

  LDist := LV1.distance(LV2);

  if (LDist < LR1) or (LDist < LR2) then
    Result := True
  else
    Result := False;
end;

// --- Easing ---------------------------------------------------------------
function EaseValue(aCurrentTime: Double; aStartValue: Double; aChangeInValue: Double; aDuration: Double; aEaseType: TEaseType): Double;
begin
  Result := 0;
  case aEaseType of
    etLinearTween:
      begin
        Result := aChangeInValue * aCurrentTime / aDuration + aStartValue;
      end;

    etInQuad:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := aChangeInValue * aCurrentTime * aCurrentTime + aStartValue;
      end;

    etOutQuad:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := -aChangeInValue * aCurrentTime * (aCurrentTime-2) + aStartValue;
      end;

    etInOutQuad:
      begin
        aCurrentTime := aCurrentTime / (aDuration / 2);
        if aCurrentTime < 1 then
          Result := aChangeInValue / 2 * aCurrentTime * aCurrentTime + aStartValue
        else
        begin
          aCurrentTime := aCurrentTime - 1;
          Result := -aChangeInValue / 2 * (aCurrentTime * (aCurrentTime - 2) - 1) + aStartValue;
        end;
      end;

    etInCubic:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := aChangeInValue * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue;
      end;

    etOutCubic:
      begin
        aCurrentTime := (aCurrentTime / aDuration) - 1;
        Result := aChangeInValue * ( aCurrentTime * aCurrentTime * aCurrentTime + 1) + aStartValue;
      end;

    etInOutCubic:
      begin
        aCurrentTime := aCurrentTime / (aDuration/2);
        if aCurrentTime < 1 then
          Result := aChangeInValue / 2 * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue
        else
        begin
          aCurrentTime := aCurrentTime - 2;
          Result := aChangeInValue / 2 * (aCurrentTime * aCurrentTime * aCurrentTime + 2) + aStartValue;
        end;
      end;

    etInQuart:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := aChangeInValue * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue;
      end;

    etOutQuart:
      begin
        aCurrentTime := (aCurrentTime / aDuration) - 1;
        Result := -aChangeInValue * (aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime - 1) + aStartValue;
      end;

    etInOutQuart:
      begin
        aCurrentTime := aCurrentTime / (aDuration / 2);
        if aCurrentTime < 1 then
          Result := aChangeInValue / 2 * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue
        else
        begin
          aCurrentTime := aCurrentTime - 2;
          Result := -aChangeInValue / 2 * (aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime - 2) + aStartValue;
        end;
      end;

    etInQuint:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := aChangeInValue * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue;
      end;

    etOutQuint:
      begin
        aCurrentTime := (aCurrentTime / aDuration) - 1;
        Result := aChangeInValue * (aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + 1) + aStartValue;
      end;

    etInOutQuint:
      begin
        aCurrentTime := aCurrentTime / (aDuration / 2);
        if aCurrentTime < 1 then
          Result := aChangeInValue / 2 * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + aStartValue
        else
        begin
          aCurrentTime := aCurrentTime - 2;
          Result := aChangeInValue / 2 * (aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime * aCurrentTime + 2) + aStartValue;
        end;
      end;

    etInSine:
      begin
        Result := -aChangeInValue * Cos(aCurrentTime / aDuration * (PI / 2)) + aChangeInValue + aStartValue;
      end;

    etOutSine:
      begin
        Result := aChangeInValue * Sin(aCurrentTime / aDuration * (PI / 2)) + aStartValue;
      end;

    etInOutSine:
      begin
        Result := -aChangeInValue / 2 * (Cos(PI * aCurrentTime / aDuration) - 1) + aStartValue;
      end;

    etInExpo:
      begin
        Result := aChangeInValue * Power(2, 10 * (aCurrentTime/aDuration - 1) ) + aStartValue;
      end;

    etOutExpo:
      begin
        Result := aChangeInValue * (-Power(2, -10 * aCurrentTime / aDuration ) + 1 ) + aStartValue;
      end;

    etInOutExpo:
      begin
        aCurrentTime := aCurrentTime / (aDuration/2);
        if aCurrentTime < 1 then
          Result := aChangeInValue / 2 * Power(2, 10 * (aCurrentTime - 1) ) + aStartValue
        else
         begin
           aCurrentTime := aCurrentTime - 1;
           Result := aChangeInValue / 2 * (-Power(2, -10 * aCurrentTime) + 2 ) + aStartValue;
         end;
      end;

    etInCircle:
      begin
        aCurrentTime := aCurrentTime / aDuration;
        Result := -aChangeInValue * (Sqrt(1 - aCurrentTime * aCurrentTime) - 1) + aStartValue;
      end;

    etOutCircle:
      begin
        aCurrentTime := (aCurrentTime / aDuration) - 1;
        Result := aChangeInValue * Sqrt(1 - aCurrentTime * aCurrentTime) + aStartValue;
      end;

    etInOutCircle:
      begin
        aCurrentTime := aCurrentTime / (aDuration / 2);
        if aCurrentTime < 1 then
          Result := -aChangeInValue / 2 * (Sqrt(1 - aCurrentTime * aCurrentTime) - 1) + aStartValue
        else
        begin
          aCurrentTime := aCurrentTime - 2;
          Result := aChangeInValue / 2 * (Sqrt(1 - aCurrentTime * aCurrentTime) + 1) + aStartValue;
        end;
      end;
  end;
end;

function EasePosition(aStartPos: Double; aEndPos: Double; aCurrentPos: Double; aEaseType: TEaseType): Double;
var
  LT, LB, LC, LD: Double;
begin
  LC := aEndPos - aStartPos;
  LD := 100;
  LT := aCurrentPos;
  LB := aStartPos;
  Result := EaseValue(LT, LB, LC, LD, aEaseType);
  if Result > 100 then
    Result := 100;
end;


procedure Startup;
var
  I: Integer;
begin
  System.Randomize;
  for I := 0 to 360 do
  begin
    mCosTable[I] := cos((I * PI / 180.0));
    mSinTable[I] := sin((I * PI / 180.0));
  end;
end;

procedure Shutdown;
begin
end;

{$ENDREGION}

{$REGION 'Spark.Utils'}
{ TBaseObject }
constructor TBaseObject.Create;
begin
  inherited;
end;

destructor TBaseObject.Destroy;
begin
  inherited;
end;

{ TList }
function TList.OutOfBounds(aIndex: Integer): Boolean;
begin
  if (aIndex < 0) or (aIndex > FCount-1) then
    Result := True
  else
    Result := False;
end;

function TList.GetItem(aIndex: Integer): Pointer;
begin
  Result := nil;
  if OutOfBounds(aIndex) then Exit;
  Result := FItems[aIndex];
end;

procedure TList.SetItem(aIndex: Integer; aValue: Pointer);
begin
  if OutOfBounds(aIndex) then Exit;
  FItems[aIndex] := aValue;
end;

constructor TList.Create;
begin
  Init;
  inherited;
end;

destructor TList.Destroy;
begin
  Clear;
  inherited;
end;

procedure TList.Init(aCapacity: Integer);
begin
  FItems := nil;
  FCount := 0;
  FCapacity := aCapacity;
end;

procedure TList.Clear;
begin
  FItems := nil;
  FCount := 0;
end;

function TList.IndexOf(aItem: Pointer): Integer;
var
  I : Integer;
begin
  for I := 0 to FCount - 1 do
    if FItems[i] = aItem then
    begin
      Result := I;
      Exit;
    end;
  Result := -1;
end;

function TList.Add(aItem: Pointer): Integer;
begin
  if FCount mod FCapacity = 0 then
    SetLength(FItems, Length(FItems) + FCapacity);
  FItems[FCount] := aItem;
  Result := FCount;
  Inc(FCount);
end;

function TList.Delete(aIndex: Integer): Pointer;
begin
  Result := nil;
  if OutOfBounds(aIndex) then Exit;
  Result := FItems[aIndex];
  Dec(FCount);
  if aIndex < FCount then
    Move(FItems[aIndex + 1], FItems[aIndex], (FCount - aIndex) * SizeOf(FItems[0]));
  if Length(FItems) - FCount > FCapacity then
    SetLength(FItems, Length(FItems) - FCapacity);
end;

procedure TList.Insert(aIndex: Integer; aItem: Pointer);
begin
  if OutOfBounds(aIndex) then Exit;
  Add(nil);
  Move(FItems[aIndex], FItems[aIndex + 1], (FCount - aIndex) * SizeOf(FItems[0]));
  FItems[aIndex] := aItem;
end;

procedure TList.Sort(aCompareFunc: TListCompareFunc);
  procedure SortFragment(L, R: LongInt);
  var
    i, j : Integer;
    P, T : Pointer;
  begin
    repeat
      i := L;
      j := R;
      P := FItems[(L + R) div 2];
      repeat
        while aCompareFunc(FItems[i], P) < 0 do
          Inc(i);
        while aCompareFunc(FItems[j], P) > 0 do
          Dec(j);
        if i <= j then
        begin
          T := FItems[i];
          FItems[i] := FItems[j];
          FItems[j] := T;
          Inc(i);
          Dec(j);
        end;
      until i > j;
      if L < j then
        SortFragment(L, j);
      L := i;
    until i >= R;
  end;

begin
  if FCount > 1 then
    SortFragment(0, FCount - 1);
end;

{ TStringList }
function TStringList.OutOfBounds(aIndex: Integer): Boolean;
begin
  if (aIndex < 0) or (aIndex >= FCount) then
    Result := True
  else
    Result := False;
end;

function TStringList.GetItem(aIndex: Integer): string;
begin
  Result := '';
  if OutOfBounds(aIndex) then Exit;
  Result := FItems[aIndex];
end;

procedure TStringList.SetItem(aIndex: Integer; aValue: string);
begin
  if OutOfBounds(aIndex) then Exit;
  FItems[aIndex] := aValue;
end;

constructor TStringList.Create;
begin
  inherited;
  Init;
end;

destructor TStringList.Destroy;
begin
  Clear;
  inherited;
end;

procedure TStringList.Init(aCapacity: Integer);
begin
  FItems := nil;
  FCount := 0;
  FCapacity := aCapacity;
end;

procedure TStringList.Clear;
begin
  FItems := nil;
  FCount := 0;
end;

function TStringList.IndexOf(aItem: string): Integer;
var
  I : Integer;
begin
  for I := 0 to FCount - 1 do
    if FItems[i] = aItem then
    begin
      Result := I;
      Exit;
    end;
  Result := -1;
end;

function TStringList.Add(aItem: string): Integer;
begin
  if FCount mod FCapacity = 0 then
    SetLength(FItems, Length(FItems) + FCapacity);
  FItems[FCount] := aItem;
  Result := FCount;
  Inc(FCount);
end;

function TStringList.Delete(aIndex: Integer): string;
begin
  Result := '';
  if OutOfBounds(aIndex) then Exit;
  Result := FItems[aIndex];
  Finalize(FItems[aIndex]);
  Dec(FCount);
  if aIndex < FCount then
    Move(FItems[aIndex + 1], FItems[aIndex], (FCount - aIndex) * SizeOf(FItems[0]));
  if Length(FItems) - FCount > FCapacity then
    SetLength(FItems, Length(FItems) - FCapacity);
end;

procedure TStringList.Insert(aIndex: Integer; aItem: string);
begin
  if OutOfBounds(aIndex) then Exit;
  Add('');
  Move(FItems[aIndex], FItems[aIndex + 1], (FCount - aIndex) * SizeOf(FItems[0]));
  FItems[aIndex] := aItem;
end;

procedure TStringList.Sort(aCompareFunc: TStringListCompareFunc);
  procedure SortFragment(L, R: LongInt);
  var
    i, j : Integer;
    P, T : string;
  begin
    repeat
      i := L;
      j := R;
      P := FItems[(L + R) div 2];
      repeat
        while aCompareFunc(FItems[i], P) < 0 do
          Inc(i);
        while aCompareFunc(FItems[j], P) > 0 do
          Dec(j);
        if i <= j then
        begin
          T := FItems[i];
          FItems[i] := FItems[j];
          FItems[j] := T;
          Inc(i);
          Dec(j);
        end;
      until i > j;
      if L < j then
        SortFragment(L, j);
      L := i;
    until i >= R;
  end;

begin
  if FCount > 1 then
    SortFragment(0, FCount - 1);
end;

function TStringList.AddPair(const aName, aValue: string): TStringList;
begin
  Add(aName + '=' + aValue);
  Result := Self;
end;

function TStringList.GetKey(aIndex: Integer): string;
var
  P: Integer;
begin
  Result := '';
  if OutOfBounds(aIndex) then Exit;
  Result := GetItem(aIndex);
  P := Pos('=', Result);
  if P <> 0 then
    SetLength(Result, P-1);
end;

function TStringList.GetValue(aIndex: Integer): string;
var
  P: Integer;
begin
  Result := '';
  if OutOfBounds(aIndex) then Exit;
  Result := GetItem(aIndex);
  P := Pos('=', Result);
  if P > 0 then
    System.Delete(Result, 1, P);
end;

{ TStream }
procedure TStream.SetPos(aValue: Integer);
begin
  FPos := aValue;
  if FType = stFile then
    Seek(FFile, FPos);
end;

constructor TStream.Create;
begin
  inherited;
end;

destructor TStream.Destroy;
begin
  if FType = stFile then CloseFile(FFile);
  inherited;
end;

function TStream.Open(aMemory: Pointer; aMemSize: Integer): Boolean;
begin
  Result := False;

  if not Assigned(aMemory) then Exit;
  if aMemSize <=0 then Exit;

  FType := stMemory;
  FMem   := aMemory;
  FSize := aMemSize;
  FPos  := 0;
end;

function TStream.Open(const aFilename: string; aCreate: Boolean = False): Boolean;
begin
  Result := False;

  if not aCreate then
    if not FileExist(aFilename) then Exit;

  AssignFile(FFile, aFilename);

  if aCreate then
    Rewrite(FFile, 1)
  else
    Reset(FFile, 1);

  FType := stFile;
  FSize := FileSize(FFile);
  FPos := 0;
  FMem := nil;
end;

procedure TStream.Close;
begin
  if FType = stFile then
    CloseFile(FFile);
  FType := stClosed;
  FSize := 0;
  FPos := 0;
  FMem := nil;
end;

procedure TStream.CopyFrom(const aStream: TStream);
var
  P : Pointer;
  LPos : LongInt;
begin
  P := GetMemory(aStream.Size);
  LPos := aStream.Pos;
  aStream.Pos := 0;
  aStream.Read(P^, aStream.Size);
  aStream.Pos := LPos;
  Write(P^, aStream.Size);
  FreeMemory(P);
end;

function TStream.Read(out aBuf; aBufSize: Integer): Integer;
begin
  if FType = stMemory then
  begin
    Result := Min(FPos + aBufSize, FSize) - FPos;
    Move(FMem^, aBuf, Result);
  end else
    BlockRead(FFile, aBuf, aBufSize, Result);
  Inc(FPos, Result);
end;

function TStream.Write(const aBuf; aBufSize: Integer): Integer;
begin
  if FType = stMemory then
  begin
    Result := Min(FPos + aBufSize, FSize) - FPos;
    Move(aBuf, FMem^, Result);
  end else
    BlockWrite(FFile, aBuf, aBufSize, Result);
  Inc(FPos, Result);
  Inc(FSize, Max(0, FPos - FSize));
end;

function TStream.ReadAnsiString: AnsiString;
var
  LLen : Integer;
begin
  Read(LLen, SizeOf(LLen));
  if LLen > 0 then
  begin
    SetLength(Result, LLen);
    Read(Result[1], LLen);
  end else
    Result := '';
end;

procedure TStream.WriteAnsiString(const aValue: AnsiString);
var
  LLen : Integer;
begin
  LLen := Length(aValue);
  Write(LLen, SizeOf(LLen));
  if LLen > 0 then
    Write(aValue[1], LLen);
end;

function TStream.ReadString: string;
var
  LLen : Integer;
begin
  Read(LLen, SizeOf(LLen));
  if LLen > 0 then
  begin
    SetLength(Result, LLen);
    Read(Result[1], LLen * SizeOf(Char));
  end;
end;

procedure TStream.WriteString(const aValue: string);
var
  LLen : Integer;
begin
  LLen := Length(aValue);
  Write(LLen, SizeOf(LLen));
  if LLen > 0 then Write(aValue[1], LLen * SizeOf(Char));
end;

class function TStream.Init(aMemory: Pointer; aMemSize: Integer): TStream;
begin
  Result := TStream.Create;
  Result.Open(aMemory, aMemSize);
end;

class function TStream.Init(const aFilename: string; aCreate: Boolean): TStream;
begin
  Result := TStream.Create;
  Result.Open(aFilename, aCreate);
end;

{ Routines }
procedure FreeNilObject(var aObject);
var
  LObject: TObject;
begin
  LObject := TObject(aObject);
  if Assigned(LObject) then LObject.Free;
  Pointer(aObject) := nil;
end;

function GetTempPath: string;
var
  Tmp: array[0..MAX_PATH] of Char;
  Len: Integer;
begin
  Len := GetTempPathW(MAX_PATH, Tmp);
  if Len <> 0 then
  begin
    Len := GetLongPathNameW(Tmp, nil, 0);
    SetLength(Result, Len - 1);
    GetLongPathNameW(Tmp, PChar(Result), Len);
  end
  else
    Result := '';
end;

function GetTempFileName: string;
var
  TempPath: string;
  ErrCode: UINT;
begin
  TempPath := GetTempPath;
  SetLength(Result, MAX_PATH);
  ErrCode := GetTempFileNameW(PChar(TempPath), 'tmp', 0, PChar(Result));
  if ErrCode = 0 then Exit;
  SetLength(Result, Length(PChar(Result)));
end;

procedure ProcessMessages;
var
  LMsg: TMsg;
begin
  while Integer(PeekMessageW(LMsg, 0, 0, 0, PM_REMOVE)) <> 0 do
  begin
    TranslateMessage(LMsg);
    DispatchMessageW(LMsg);
  end;
end;

function NumToStr(aValue: Int64): string;
var
  LResult: ShortString;
begin
  Str(aValue, LResult);
  Result := string(LResult);
end;

function  NumToStr(aValue: UInt64): string;
var
  LResult: ShortString;
begin
  Str(aValue, LResult);
  Result := string(LResult);
end;

function  NumToStr(aValue: Double; aWidth: Integer; aDecimals: Integer): string;
var
  LResult: ShortString;
begin
  if aWidth = 0 then
    begin
      Str(aValue:16:aDecimals, LResult);
      Result := TrimStr(string(LResult));
      Exit;
    end
  else
    Str(aValue:aWidth:aDecimals, LResult);
  Result := string(LResult);
end;

function  NumToStr(aValue: Extended; aWidth: Integer; aDecimals: Integer): string;
var
  LResult: ShortString;
begin
  if aWidth = 0 then
    begin
      Str(aValue:16:aDecimals, LResult);
      Result := TrimStr(string(LResult));
      Exit;
    end
  else
    Str(aValue:aWidth:aDecimals, LResult);
  Result := string(LResult);
end;

function TrimChars(const aValue: string; Chars: TSysCharSet): string;
var
  i, j : LongInt;
begin
  j := Length(aValue);
  i := 1;
  while (i <= j) and (AnsiChar(aValue[i]) in Chars) do
    Inc(i);
  if i <= j then
  begin
    while AnsiChar(aValue[j]) in Chars do
      Dec(j);
    Result := Copy(aValue, i, j - i + 1);
  end else
    Result := '';
end;

function  TrimStr(aValue: string): string;
begin
  Result := TrimChars(aValue, [#9, #10, #13, #32, #34, #39]);
end;

function DeleteChars(const Str: string; Chars: TSysCharSet): string;
var
  i, j : LongInt;
begin
  j := 0;
  SetLength(Result, Length(Str));
  for i := 1 to Length(Str) do
    if not (AnsiChar(Str[i]) in Chars) then
    begin
      Inc(j);
      Result[j] := Str[i];
    end;
  SetLength(Result, j);
end;

function  StrToInt(aValue: string): Int64;
var
  LCode: Integer;
begin
  Val(aValue, Result, LCode);
end;

function  StrToUInt(aValue: string): UInt64;
var
  LCode: Integer;
begin
  Val(aValue, Result, LCode);
end;

function  StrToFloat(aValue: string): Double;
var
  LCode: Integer;
begin
  Val(aValue, Result, LCode);
end;

function StuffStr(const aText: string; aStart, aLength: Cardinal; const aSubText: string): string;
begin
  Result := Copy(aText, 1, aStart - 1) +
            aSubText +
            Copy(aText, aStart + aLength, MaxInt);
end;

function UpperCase(const S: string): string;
var
  I, Len: Integer;
  DstP, SrcP: PChar;
  Ch: Char;
begin
  Len := Length(S);
  SetLength(Result, Len);
  if Len > 0 then
  begin
    DstP := PChar(Pointer(Result));
    SrcP := PChar(Pointer(S));
    for I := Len downto 1 do
    begin
      Ch := SrcP^;
      case Ch of
        'a'..'z':
          Ch := Char(Word(Ch) xor $0020);
      end;
      DstP^ := Ch;
      Inc(DstP);
      Inc(SrcP);
    end;
  end;
end;

function SameText(A, B: string): Boolean;
begin
  Result := Boolean(UpperCase(A) = UpperCase(B));
end;

function LastDelimiter(const aText: string; const Delims: TSysCharSet): Integer;
var
  PSt, P: PChar;
begin
  PSt := Pointer(aText);
  if Assigned(PSt) then
  begin
    P := PSt + Length(aText) - 1;
    while P >= PSt do
    begin
      if AnsiChar(P^) in Delims then
        Exit(P - PSt);
      Dec(P);
    end;
  end;
  Result := -1;
end;

function ChangeFileExt(const aFilename, aExtension: string): string;
var
  I: Integer;
begin
  I := LastDelimiter(aFilename, ['.', PathDelim , DriveDelim]);
  if (I < 0) or (aFilename[I+1] <> '.') then
    Result := aFilename + aExtension
  else
  begin
    SetLength(Result, I + Length(aExtension));
    Move(aFilename[1], Result[1], I * SizeOf(Char));
    if Length(aExtension) > 0 then
      Move(aExtension[1], Result[1 + I], Length(aExtension) * SizeOf(Char));
  end;
end;

(*
function  TSysUtils.FileExist(const aFilename: string): Boolean;
var
  FFileSandBoxed: Boolean;
begin
  Result := False;
  if aFilename = '' then Exit;
  FFileSandBoxed := GetFileSandBoxed;
  if FFileSandBoxed then SetFileSandBoxed(False);
  Result := al_filename_exists(PAnsiChar(AnsiString(aFilename)));
  SetFileSandBoxed(FFileSandBoxed);
end;
*)

function  FileExist(const aFilename: string): Boolean;
var
  LAttrib: DWORD;
begin
  Result := False;
  LAttrib := GetFileAttributesW(PChar(aFilename));
  if LAttrib = INVALID_FILE_ATTRIBUTES then Exit;
  if LAttrib = FILE_ATTRIBUTE_DIRECTORY then Exit;
  Result := True;
end;

function DirExist(const aDir: string): Boolean;
var
  LAttrib: DWORD;
begin
  Result := False;
  LAttrib := GetFileAttributesW(PChar(aDir));
  if LAttrib = INVALID_FILE_ATTRIBUTES then Exit;
  Result := (LAttrib and FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY;
end;

function  GetFiles(const aPath: string; aRecursive: Boolean): TStringArray;
const
  CWildCard = '\*';
var
  LData: TFindDataW;
  LFind: THandle;
  LCount: Integer;
  LFilename: string;
  LPath: string;
  LSubFiles: TStringArray;
begin
  Result := nil;
  if aPath = '' then Exit;
  LPath := aPath + CWildCard;
  LCount := 0;
  LFind := FindFirstFileW(PChar(LPath), LData);
  if LFind = INVALID_HANDLE_VALUE then Exit;
  if GetLastError = ERROR_FILE_NOT_FOUND then
  begin
    FindClose(LFind);
    Exit;
  end;
  repeat
    LFilename := string(LData.cFileName);
    if (LFilename = '..') or (LFilename = '.') then continue;
    if LData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY then
    begin
      if aRecursive then
      begin
        LSubFiles := GetFiles(aPath + '\' + LFilename, aRecursive);
        for LFilename in LSubFiles do
        begin
          Inc(LCount);
          SetLength(Result, LCount);
          Result[LCount-1] := LFilename;
        end;
        continue;
      end;
    end;

    Inc(LCount);
    SetLength(Result, LCount);
    Result[LCount-1] := aPath + '\' + LFilename;
  until not FindNextFileW(LFind, LData);

  FindClose(LFind);
end;

function  FileCount(const aPath: string; const aMask: string): Int64;
var
  LData: TFindDataW;
  LFind: THandle;
  LCount: Integer;
  LFilename: string;
  LPath: string;
begin
  Result := 0;
  if aPath = '' then Exit;
  LPath := aPath + '\' + aMask;
  LCount := 0;
  LFind := FindFirstFileW(PChar(LPath), LData);
  if LFind = INVALID_HANDLE_VALUE then Exit;
  if GetLastError = ERROR_FILE_NOT_FOUND then
  begin
    FindClose(LFind);
    Exit;
  end;
  repeat
    LFilename := string(LData.cFileName);
    if (LFilename = '..') or (LFilename = '.') then continue;
    if LData.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY then
      continue;

    Inc(LCount);
  until not FindNextFileW(LFind, LData);

  FindClose(LFind);

  Result := LCount;
end;

function GetBit(const aValue: Cardinal; const Bit: Byte): Boolean;
begin
  Result := (aValue and (1 shl Bit)) <> 0;
end;

function SetBit(const aValue: Cardinal; const Bit: Byte): Cardinal;
begin
  Result := aValue or (1 shl Bit);
end;

function ClearBit(const aValue: Cardinal; const Bit: Byte): Cardinal;
begin
  Result := aValue and not (1 shl Bit);
end;

function EnableBit(const aValue: Cardinal; const Bit: Byte; const Flag: Boolean): Cardinal;
begin
  Result := (aValue or (1 shl Bit)) xor (Cardinal(not Flag) shl Bit);
end;

function StrScan(const aText: PWideChar; Chr: WideChar): PWideChar;
begin
  Result := aText;
  while Result^ <> #0 do
  begin
    if Result^ = Chr then
      Exit;
    Inc(Result);
  end;
  if Chr <> #0 then
    Result := nil;
end;

function StrEnd(const aText: PWideChar): PWideChar;
begin
  Result := aText;
  while Result^ <> #0 do
    Inc(Result);
end;

function ExtractQuotedStr(var aText: PWideChar; Quote: WideChar): UnicodeString;
var
  P, Dest: PWideChar;
  DropCount: Integer;
  EndSuffix: Integer;
begin
  Result := '';
  if (not Assigned(aText)) or (aText^ <> Quote) then Exit;
  Inc(aText);
  DropCount := 1;
  P := aText;
  aText := StrScan(aText, Quote);
  while Assigned(aText) do   // count adjacent pairs of quote chars
  begin
    Inc(aText);
    if aText^ <> Quote then Break;
    Inc(aText);
    Inc(DropCount);
    aText := StrScan(aText, Quote);
  end;
  EndSuffix := Ord(aText = nil); // Has an ending quoatation mark?
  if not Assigned(aText) then aText := StrEnd(P);
  if (aText - P - 1 + EndSuffix <= 0) or (aText - P - DropCount + EndSuffix <= 0) then Exit;
  if DropCount = 1 then
    SetString(Result, P, aText - P - 1 + EndSuffix)
  else
  begin
    SetLength(Result, aText - P - DropCount + EndSuffix);
    Dest := PWideChar(Result);
    aText := StrScan(P, Quote);
    while Assigned(aText) do
    begin
      Inc(aText);
      if aText^ <> Quote then Break;
      Move(P^, Dest^, (aText - P) * SizeOf(Char));
      Inc(Dest, aText - P);
      Inc(aText);
      P := aText;
      aText := StrScan(aText, Quote);
    end;
    if not Assigned(aText) then aText := StrEnd(P);
    Move(P^, Dest^, (aText - P - 1 + EndSuffix) * SizeOf(Char));
  end;
end;

function DequotedStr(const aText: string; aQuote: Char): string;
var
  LText: PChar;
begin
  LText := PChar(aText);
  Result := ExtractQuotedStr(LText, aQuote);
  if ((Result = '') or (LText^ = #0)) and
     (Length(aText) > 0) and ((aText[Low(aText)] <> aQuote) or (aText[High(aText)] <> aQuote)) then
    Result := aText;
end;

function  RemoveQuotes(const aText: string): string;
var
  LText: string;
begin
  LText := DequotedStr(aText, '"');
  Result := DequotedStr(LText, '''');
end;

function  FormatStr(const aMsg: string; const aArgs: array of const): string;
var
  LText: string;
  LMsg: PChar;
  LArgIndex: Integer;
  LArgCount: Integer;
  LChar: Char;
  LNum: Integer;
  LStr: string;
begin
  Result := '';
  if aMsg = '' then Exit;
  LMsg := PChar(aMsg);
  LArgCount := High(aArgs)+1;
  LArgIndex := 0;
  repeat
    if (LMsg^ = '#') and  ((LArgCount >= 1) and (LArgIndex <= LArgCount-1))  then
    begin
      Inc(LMsg);
      case LMsg^ of
        // string
        's', 'S':
        begin
          case aArgs[LArgIndex].VType of
            vtString       : LText := LText + string(aArgs[LArgIndex].VString);
            vtWideString   : LText := LText + string(aArgs[LArgIndex].VWideString);
            vtUnicodeString: LText := LText + string(aArgs[LArgIndex].VUnicodeString);
          end;
          Inc(LMsg);
          Inc(LArgIndex);
          continue;
        end;
        'i', 'I':
        begin
          // check for leading zeros #I:n where n = leading zero count
          LNum := 0;
          LStr := '';
          Inc(LMsg);
          LChar := LMsg^;
          if LChar = ':' then
            begin
              Inc(LMsg);
              LChar := LMsg^;
              if AnsiChar(LChar) in ['0' .. '9'] then
              begin
                LNum := StrToInt(LChar);
              end;
            end
          else
            Dec(LMsg);

          case aArgs[LArgIndex].VType of
            vtInteger: LStr := NumToStr(aArgs[LArgIndex].VInteger);
            vtInt64  : LStr := NumToStr(aArgs[LArgIndex].VInt64^);
          end;

          LText := LText + PadLeftStr(LStr, LNum, '0');

          Inc(LMsg);
          Inc(LArgIndex);
          continue;
        end;
        'f', 'F':
        begin
          case aArgs[LArgIndex].VType of
            vtExtended: LText := LText +  NumToStr(aArgs[LArgIndex].VExtended^);
          end;
          Inc(LMsg);
          Inc(LArgIndex);
          continue;
        end;
      end;
    end;

    LText := LText + LMsg^;
    Inc(LMsg);
  until LMsg^ = #0;
  LText := LText;

  Result := LText;
end;

function PadRightStr(const aText: string; aTotalWidth: Integer; aPaddingChar: Char): string;
begin
  aTotalWidth := aTotalWidth - Length(aText);
  if aTotalWidth > 0 then
    Result := aText + System.StringOfChar(aPaddingChar, aTotalWidth)
  else
    Result := aText;
end;

function PadLeftStr(const aText: string; aTotalWidth: Integer; aPaddingChar: Char): string;
begin
  aTotalWidth := aTotalWidth - Length(aText);
  if aTotalWidth > 0 then
    Result := System.StringOfChar(aPaddingChar, aTotalWidth) + aText
  else
    Result := aText;
end;

function ExtractStrings(Separators, WhiteSpace: TSysCharSet; Content: PChar; Strings: TStringList): Integer;
var
  Head, Tail: PChar;
  EOS, InQuote: Boolean;
  QuoteChar: Char;
  Item: string;
begin

  Result := 0;
  if (not Assigned(Content)) or (Content^ = #0) or (not Assigned(Strings)) then Exit;
  Tail := Content;
  InQuote := False;
  QuoteChar := #0;
  Include(WhiteSpace, #13);
  Include(WhiteSpace, #10);

  Include(Separators, #0);
  Include(Separators, #13);
  Include(Separators, #10);
  Include(Separators, '''');
  Include(Separators, '"');
  repeat
    while (AnsiChar(Tail^) in WhiteSpace) do Inc(Tail);
    Head := Tail;
    while True do
    begin
      while (InQuote and not ((Tail^ = #0) or (Tail^ = QuoteChar))) or
        not (AnsiChar(Tail^) in Separators) do
          Inc(Tail);
      if (AnsiChar(Tail^) in ['''', '"']) then
      begin
        if (QuoteChar <> #0) and (QuoteChar = Tail^) then
          QuoteChar := #0
        else if QuoteChar = #0 then
          QuoteChar := Tail^;
        InQuote := QuoteChar <> #0;
        Inc(Tail);
      end else Break;
    end;
    EOS := Tail^ = #0;
    if (Head <> Tail) and (Head^ <> #0) then
    begin
      if Assigned(Strings) then
      begin
        SetString(Item, Head, Tail - Head);
        Strings.Add(Item);
      end;
      Inc(Result);
    end;
    Inc(Tail);
  until EOS;
end;

function  GetFilename(const aPath: string): string;
var
  LPath: PALLEGRO_PATH;
begin
  Result := '';
  if aPath ='' then Exit;
  LPath := al_create_path(PAnsiChar(AnsiString(aPath)));
  Result := string(al_get_path_filename(LPath));
  al_destroy_path(LPath);
end;

function  HasConsoleOutput: Boolean;
var
  LStdout: THandle;
begin
  Result := False;
  LStdout := GetStdHandle(STD_OUTPUT_HANDLE);
  if LStdout = Invalid_Handle_Value then Exit;
  Result := Boolean(LStdout <> 0);
end;

procedure Print(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  Write(FormatStr(aMsg, aArgs));
end;

procedure PrintLn(const aMsg: string; const aArgs: array of const);
begin
  if not HasConsoleOutput then Exit;
  WriteLn(FormatStr(aMsg, aArgs));
end;

function ExcludeTrailingPathDelimiter(const S: string): string;
begin
  Result := S;
  if Result[High(Result)] = PathDelim then
    SetLength(Result, Length(Result)-1);
end;

function ExpandFileName(const FileName: string): string;
var
  FName: PChar;
  Buffer: array[0..MAX_PATH - 1] of Char;
  Len: Integer;
begin
  Len := GetFullPathNameW(PChar(FileName), Length(Buffer), Buffer, FName);
  if Len <= Length(Buffer) then
    SetString(Result, Buffer, Len)
  else if Len > 0 then
  begin
    SetLength(Result, Len);
    Len := GetFullPathNameW(PChar(FileName), Len, PChar(Result), FName);
    if Len < Length(Result) then
      SetLength(Result, Len);
  end;
end;

function ExtractFilePath(const FileName: string): string;
var
  I: Integer;
begin
  I :=  LastDelimiter(Filename, [PathDelim , DriveDelim]);
  Result := Copy(FileName, 1, I + 1);
end;

function CreateDir(const Dir: string): Boolean;
begin
  Result := CreateDirectoryW(PChar(Dir), nil);
end;

function ForceDirectories(Dir: string): Boolean;
begin
  Result := True;
  if Dir = '' then Exit;

  Dir := ExcludeTrailingPathDelimiter(Dir);
  if DirExist(Dir) then  Exit;

  if (Length(Dir) < 3) or (ExtractFilePath(Dir) = Dir) then
    Result := CreateDir(Dir)
  else
    Result := ForceDirectories(ExtractFilePath(Dir)) and CreateDir(Dir);
end;


{$ENDREGION}

{$REGION 'Spark.System'}
{ TLog }
constructor TLog.Create;
begin
  inherited;
  Open;
end;

destructor TLog.Destroy;
begin
  Close;
  inherited;
end;

procedure TLog.Open(const aFilename: string; aOverwrite: Boolean);
var
  LFilename: string;
begin
  LFilename := aFilename;
  if LFilename = '' then LFilename := ParamStr(0);
  LFilename := ChangeFileExt(LFilename, cLogExt);

  Close;

  FillChar(FBuffer, SizeOf(FBuffer), 0);
  FOpen := False;
  FGlobalWriteToConsole := LogToConsole;

  AssignFile(FText, LFilename);
  if aOverwrite then
    ReWrite(FText)
  else
    if FileExist(LFilename) then
      Reset(FText)
    else
      ReWrite(FText);
  SetTextBuf(FText, FBuffer);
  FOpen := True;
  FFilename := LFilename;
end;

procedure TLog.Close;
begin
  if not FOpen then Exit;
  CloseFile(FText);
  FOpen := False;
end;

function TLog.Add(const aMsg: string; const aArgs: array of const; aWriteToConsole: Boolean): string;
var
  LLine: string;
begin
  if not FOpen then Exit;

  // get line
  LLine := FormatStr(aMsg, aArgs);

  // write to console
  if FGlobalWriteToConsole then
    PrintLn(LLine, [])
  else
    if aWriteToConsole then
      PrintLn(LLine, []);

  // write to logfile
  {$I-}
  Writeln(FText, LLine);
  Flush(FText);
  {$I+}
end;

{ TConfigFile }
constructor TConfigFile.Create;
begin
  inherited;
end;

destructor TConfigFile.Destroy;
begin
  Close;
  Clear;
  inherited;
end;

procedure TConfigFile.Open(const aFilename: string);
begin
  if aFilename = '' then
    begin
      FFilename := ParamStr(0);
      FFilename := ChangeFileExt(FFilename, cIniExt);
    end
  else
    FFilename := aFilename;
  if FileExist(aFilename) then
    Load(FFilename);
end;

procedure TConfigFile.Close;
begin
  Save(FFilename);
end;

procedure TConfigFile.Clear;
begin
  FData := nil;
end;

procedure TConfigFile.Load(const aFilename: string);
var
  AnsiText : string;
  Text, Category, Line : string;
  CatId : LongInt;
  Stream : TStream;
  i, BeginPos : LongInt;
begin
  FData := nil;
  CatId := -1;
  Stream := TStream.Init(aFilename);
  SetLength(AnsiText, Stream.Size);
  Stream.Read(AnsiText[1], Length(AnsiText)*SizeOf(Char));
  Stream.Free;
  Text := string(AnsiText);
  BeginPos := 1;
  while BeginPos < Length(Text) do
  begin
    for i := BeginPos to Length(Text) do
      if (Text[i] = #13) or (i = Length(Text)) then
      begin
        Line := Copy(Text, BeginPos, i - BeginPos + 1);
        BeginPos := i + 1;
        break;
      end;
    Line := TrimStr(Line);

    if Line <> '' then
      if Line[1] <> '[' then
      begin
        if (Line[1] <> ';') and (CatId >= 0) then
        begin
          SetLength(FData[CatId].Params, Length(FData[CatId].Params) + 1);
          with FData[CatId], Params[Length(Params) - 1] do
          begin
            Name  := TrimStr(Copy(Line, 1, Pos('=', Line) - 1));
            Value := TrimStr(Copy(Line, Pos('=', Line) + 1, Length(Line)));
          end;
        end;
      end else
      begin
        Category := TrimStr(DeleteChars(Line, ['[', ']']));
        CatId := Length(FData);
        SetLength(FData, CatId + 1);
        FData[CatId].Category := Category;
      end;
  end;
end;

procedure TConfigFile.Save(const aFilename: string);
var
  LStream : TStream;
  LText   : string;
  I, J : Integer;
begin
  LText := '';
  for I := 0 to Length(FData) - 1 do
  begin
    LText := LText + '[' + FData[I].Category + ']' + CRLF;
    for J := 0 to Length(FData[I].Params) - 1 do
      LText := LText + FData[I].Params[J].Name + ' = ' + FData[I].Params[J].Value + CRLF;
    LText := LText + CRLF;
  end;
  LStream := TStream.Init(aFilename, True);
  LStream.Write(LText[1], Length(LText)*SizeOf(Char));
  LStream.Free;
end;

procedure TConfigFile.Write(const aCategory, aName, aValue: string);
var
  i, j : Integer;
begin
  for i := 0 to Length(FData) - 1 do
    if aCategory = FData[i].Category then
      with FData[i] do
      begin
        for j := 0 to Length(Params) - 1 do
          if Params[j].Name = aName then
          begin
            Params[j].Value := aValue;
            Exit;
          end;
      // Add new param
        SetLength(Params, Length(Params) + 1);
        Params[Length(Params) - 1].Name  := aName;
        Params[Length(Params) - 1].Value := aValue;
        Exit;
      end;
// Add new category
  SetLength(FData, Length(FData) + 1);
  with FData[Length(FData) - 1] do
  begin
    Category := aCategory;
    SetLength(Params, 1);
    Params[0].Name  := aName;
    Params[0].Value := aValue;
  end;
end;

procedure TConfigFile.Write(const aCategory, aName: string; aValue: Int64);
begin
  Write(aCategory, aName, NumToStr(aValue));
end;

procedure TConfigFile.Write(const aCategory, aName: string; aValue: Single);
begin
  Write(aCategory, aName, NumToStr(aValue));
end;

procedure TConfigFile.Write(const aCategory, aName: string; aValue: Boolean);
begin
  if aValue then
    Write(aCategory, aName, 'TRUE')
  else
    Write(aCategory, aName, 'FALSE');
end;

function TConfigFile.Read(const aCategory, aName: string; const Default: string): string;
var
  I, J : Integer;
begin
  Result := Default;
  for I := 0 to Length(FData) - 1 do
    if aCategory = FData[I].Category then
      for J := 0 to Length(FData[I].Params) - 1 do
        if FData[I].Params[J].Name = aName then
        begin
          Result := FData[I].Params[J].Value;
          Exit;
        end;
end;

function TConfigFile.Read(const aCategory, aName: string; aDefault: Int64): Int64;
var
  LValue: string;
begin
  LValue := Read(aCategory, aName, '');
  if LValue = '' then
    Result := aDefault
  else
  Result := StrToInt(LValue);
end;

function TConfigFile.Read(const aCategory, aName: string; aDefault: Single): Single;
var
  LValue: string;
begin
  LValue := Read(aCategory, aName, '');
  if LValue = '' then
    Result := aDefault
  else
  Result := StrToInt(LValue);
end;

function TConfigFile.Read(const aCategory, aName: string; aDefault: Boolean = False): Boolean;
var
  LValue: string;
begin
  LValue := Read(aCategory, aName, '');
  if LValue = '' then
    Result := aDefault
  else
    if SameText(LValue, 'TRUE') then
      Result := True
    else
    if SameText(LValue, 'FALSE') then
      Result := False
    else
      Result := aDefault;
end;

function TConfigFile.CategoryName(aIndex: Integer): string;
begin
  if (aIndex >= 0) and (aIndex < Length(FData)) then
    Result := FData[aIndex].Category
  else
    Result := '';
end;

{ TArchive }
constructor TArchive.Create;
begin
  inherited;
end;

destructor TArchive.Destroy;
begin
  Close;
  inherited;
end;

function TArchive.IsOpen: Boolean;
begin
  Result := FIsOpen;
end;

function TArchive.Open(const aPassword: string; const aFilename: string): Boolean;
begin
  Result := False;
  if FIsOpen then Exit;
  if not FileExist(aFilename) then Exit;
  Result := Boolean(PHYSFS_mount(PAnsiChar(AnsiString(aFilename)), nil, 1) <> 0);
  if Result then
  begin
    FPassword := aPassword;
    FFilename := aFilename;
    FPasswordFilename := '';
    FIsOpen := True;
  end;
end;

function TArchive.Close: Boolean;
begin
  Result := False;
  if not FIsOpen then Exit;
  Result := Boolean(PHYSFS_unmount(PAnsiChar(AnsiString(FFilename))) <> 0);
  if Result then
  begin
    FIsOpen := False;
    FFilename := '';
    FPassword := '';
    FPasswordFilename := '';
  end;
end;

function TArchive.FileInside(const aFilename: string): Boolean;
var
  LSandBoxed: Boolean;
begin
  LSandBoxed := SGT.GetFileSandBoxed;
  SGT.SetFileSandBoxed(True);
  Result := al_filename_exists(PAnsiChar(AnsiString(aFilename)));
  SGT.SetFileSandBoxed(LSandBoxed);
end;

function TArchive.GetPasswordFilename(const aFilename: string): PAnsiChar;
begin
  if FPassword = '' then
    FPasswordFilename := aFilename
  else
    FPasswordFilename := aFilename + '$' + FPassword;
  Result := PAnsiChar(AnsiString(FPasswordFilename));
end;

function TArchive.GetCRC32(aStream: PALLEGRO_FILE): Cardinal;
var
  LBytesRead: NativeUInt;
  LBuffer: array of Byte;
  LSandboxed: Boolean;
begin
  SetLength(LBuffer, 65521);
  LSandboxed := SGT.GetFileSandBoxed;
  SGT.SetFileSandBoxed(False);

  Result := Crc32(0, nil, 0);
  repeat
    LBytesRead := al_fread(aStream, @LBuffer[0], Length(LBuffer));
    Result := Crc32(Result, @LBuffer[0], LBytesRead);
  until al_feof(aStream);
  SGT.SetFileSandBoxed(LSandboxed);

  LBuffer := nil;
end;

function TArchive.Build(const aPassword: string; const aFilename: string; const aDirectory: string; aOnProgress: TArchiveBuildProgressEvent): Boolean;
var
  LFileList: TStringArray;
  LFilename: string;
  LZipFile: zipFile;
  LZipFileInfo: zip_fileinfo;
  LFile: PALLEGRO_FILE;
  LCrc: Cardinal;
  LBytesRead: Integer;
  LBuffer: array of Byte;
  LFileSize: Int64;
  LProgress: Single;
  LNewFile: Boolean;
  LSandboxed: Boolean;
begin
  Result := False;

  // check if directory exists
  if not DirExist(aDirectory) then Exit;

  LSandboxed := SGT.GetFileSandBoxed;
  SGT.SetFileSandBoxed(False);

  // init variabls
  SetLength(LBuffer, 1024*4);
  FillChar(LZipFileInfo, SizeOf(LZipFileInfo), 0);

  // scan folder and build file list
  //LFileList := TDirectory.GetFiles(aDirectory, '*', TSearchOption.soAllDirectories);
  LFileList := GetFiles(aDirectory, True);

  // create a zip file
  LZipFile := zipOpen(PAnsiChar(AnsiString(aFilename)), APPEND_STATUS_CREATE);

  // process zip file
  if Assigned(LZipFile) then
  begin
    // loop through all files in list
    for LFilename in LFileList do
    begin
      // open file
      //LFile := TFile.OpenRead(LFilename);
      LFile := al_fopen(PAnsiChar(AnsiString(LFilename)), 'rb');

      // get file size
      //LFileSize := LFile.Size;
      LFileSize := al_fsize(LFile);

      // get file crc
      LCrc := GetCRC32(LFile);

      // open new file in zip
      if ZipOpenNewFileInZip3(LZipFile, PAnsiChar(AnsiString(LFilename)),
        @LZipFileInfo, nil, 0, nil, 0, '',  Z_DEFLATED, 9, 0, 15, 9,
        Z_DEFAULT_STRATEGY, PAnsiChar(AnsiString(aPassword)), LCrc) = Z_OK then
      begin
        // make sure we start at star of stream
        //LFile.Position := 0;
        al_fseek(LFile, 0, ALLEGRO_SEEK_SET);

        // this is a new file
        LNewFile := True;

        // read through file
        repeat
          // read in a buffer length of file
          //LBytesRead := LFile.Read(LBuffer[0], Length(LBuffer));
          LBytesRead := al_fread(LFile, @LBuffer[0], Length(LBuffer));

          // write buffer out to zip file
          zipWriteInFileInZip(LZipFile, @LBuffer[0], LBytesRead);

          // calc file progress percentage
          //LProgress := 100.0 * (LFile.Position / LFileSize);
          LProgress := 100.0 * (al_ftell(LFile) / LFileSize);
          // show progress
          if Assigned(aOnProgress) then
            aOnProgress(LFilename, Round(LProgress), LNewFile);

          // reset new file flag
          LNewFile := False;
        until LBytesRead = 0;

        // close file in zip
        zipCloseFileInZip(LZipFile);

        // free file stream
        //FreeAndNil(LFile);
        al_fclose(LFile);
      end;
    end;

    // close zip file
    zipClose(LZipFile, '');
  end;

  // return true if new zip file exits
  Result := FileExist(aFilename);

  SGT.SetFileSandBoxed(LSandboxed);
end;


{$ENDREGION}

{$REGION 'Spark.Graphics'}
const
  cDefaultFontResName = 'f6eab4cd6d2a41bd986d72e59a3f1942';

{ TColor }
function TColor.FromByte(aRed: Byte; aGreen: Byte; aBlue: Byte; aAlpha: Byte): TColor;
var
  LColor: ALLEGRO_COLOR;
begin
  LColor := al_map_rgba(aRed, aGreen, aBlue, aAlpha);
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TColor.FromFloat(aRed: Single; aGreen: Single; aBlue: Single; aAlpha: Single): TColor;
var
  LColor: ALLEGRO_COLOR;
begin
  LColor := al_map_rgba_f(aRed, aGreen, aBlue, aAlpha);
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TColor.FromName(const aName: string): TColor;
var
  LColor: ALLEGRO_COLOR absolute Result;
begin
  LColor := al_color_name(PAnsiChar(AnsiString(aName)));
  Red := LColor.r;
  Green := LColor.g;
  Blue := LColor.b;
  Alpha := LColor.a;
  Result := Self;
end;

function TColor.Fade(aTo: TColor; aPos: Single): TColor;
var
  LColor: TColor;
begin
  // clip to ranage 0.0 - 1.0
  if aPos < 0 then
    aPos := 0
  else if aPos > 1.0 then
    aPos := 1.0;

  // fade colors
  LColor.Alpha := Alpha + ((aTo.Alpha - Alpha) * aPos);
  LColor.Blue := Blue + ((aTo.Blue - Blue) * aPos);
  LColor.Green := Green + ((aTo.Green - Green) * aPos);
  LColor.Red := Red + ((aTo.Red - Red) * aPos);
  Result := FromFloat(LColor.Red, LColor.Green, LColor.Blue, LColor.Alpha);
end;

function TColor.Equal(aColor: TColor): Boolean;
begin
  if (Red = aColor.Red) and (Green = aColor.Green) and
    (Blue = aColor.Blue) and (Alpha = aColor.Alpha) then
    Result := True
  else
    Result := False;
end;

{ TFont }
constructor TFont.Create;
begin
  inherited;
  FHandle := nil;
  FFilename := '';
  FSize := 0;
  LoadBuiltIn;
end;

destructor TFont.Destroy;
begin
  Unload;
  inherited;
end;

function TFont.LoadBuiltIn: Boolean;
var
  LHandle: PALLEGRO_FONT;
begin
  Result := False;
  if Assigned(FHandle) then Exit;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LHandle := al_create_builtin_font;
  if not Assigned(LHandle) then Exit;

  Unload;
  FHandle := LHandle;
  FFilename := '';
  FSize := 8;

  Result := True;
end;

function TFont.LoadDefault(aSize: Cardinal): Boolean;
var
  LMemFile: PALLEGRO_FILE;
  LHandle: PALLEGRO_FONT;
  LHResInfo: THandle;
  LHGlobal: THandle;
  LBuff: Pointer;
  LSize: DWORD;
begin
  Result := False;
  if aSize = 0 then Exit;

  LHResInfo := FindResource(HInstance, cDefaultFontResName, RT_RCDATA);
  if LHResInfo = 0 then Exit;
  LHGlobal := LoadResource(HInstance, LHResInfo);
  if LHGlobal = 0 then Exit;
  LBuff := LockResource(LHGlobal);
  LSize := SizeOfResource(HInstance, LHResInfo);

  LMemFile := al_open_memfile(LBuff, LSize, 'rb');
  if not Assigned(LMemFile) then
  begin
    FreeResource(LHGlobal);
    Exit;
  end;

  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LHandle := al_load_ttf_font_f(LMemFile, '', -aSize, 0);
  if not Assigned(LHandle) then
  begin
    al_fclose(LMemFile);
    FreeResource(LHGlobal);
    Exit;
  end;
  FreeResource(LHGlobal);

  Unload;
  FHandle := LHandle;
  FFilename := '';
  FSize := aSize;

end;

function TFont.Load(aArchive: TArchive; aSize: Cardinal; aFilename: string): Boolean;
var
  LFilename: string;
  LHandle: PALLEGRO_FONT;
  LSandBoxed: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  if aFilename = '' then Exit;
  if aSize = 0 then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then
      begin
        SGT.Log.Add('Failed to load font file: #s', [aFilename]);
        Exit;
      end;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not FileExist(aFilename) then
      begin
        SGT.Log.Add('Failed to load font file: #s', [aFilename]);
        Exit;
      end;
      LFilename := aFilename;
    end;

  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LSandBoxed := SGT.GetFileSandBoxed;
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
  LHandle := al_load_ttf_font(PAnsiChar(AnsiString(LFilename)), -aSize, 0);
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);
  if not Assigned(LHandle) then
  begin
    Exit;
    SGT.Log.Add('Failed to load font file: #s', [aFilename]);
  end;

  Unload;
  SGT.Log.Add('Sucessfully loaded texture file: "#s"', [aFilename]);
  FHandle := LHandle;
  FFilename := aFilename;
  FSize := aSize;
end;

function TFont.Unload: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  al_destroy_font(FHandle);
  if FFilename <> '' then
    SGT.Log.Add('Unloaded font file: "#s"', [FFilename]);
  FHandle := nil;
  FFilename := '';
  FSize := 0;
  Result := True;
end;

procedure TFont.PrintText(aX: Single; aY: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LColor: ALLEGRO_COLOR absolute aColor;
  LText: string;
begin
  if not Assigned(FHandle) then Exit;
  if aMsg = '' then Exit;
  LText := FormatStr(aMsg, aArgs);
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  //al_draw_ustr(FHandle, LColor, aX, aY, Ord(aAlign) or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_draw_ustr(FHandle, LColor, aX, aY, Ord(aAlign), LUstr);
  al_ustr_free(LUstr);
end;

procedure TFont.PrintText(aX: Single; var aY: Single; aLineSpace: Single; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
begin
  if not Assigned(FHandle) then Exit;
  PrintText(aX, aY, aColor, aAlign, aMsg, aArgs);
  aY := aY + GetLineHeight + aLineSpace;
end;

procedure TFont.PrintText(aX: Single; aY: Single; aColor: TColor; aAngle: Single; const aMsg: string; const aArgs: array of const);
var
  LUstr: PALLEGRO_USTR;
  LFX, LFY: Single;
  LTR: ALLEGRO_TRANSFORM;
  LColor: ALLEGRO_COLOR absolute aColor;
  LTrans: ALLEGRO_TRANSFORM;
  LText: string;
begin
  if not Assigned(FHandle) then Exit;
  if aMsg = '' then Exit;
  LText := FormatStr(aMsg, aArgs);
  LFX := GetTextWidth(LText, []) / 2;
  LFY := GetLineHeight / 2;
  al_identity_transform(@LTR);
  al_translate_transform(@LTR, -LFX, -LFY);
  al_rotate_transform(@LTR, aAngle * DEG2RAD);
  AngleRotatePos(aAngle, LFX, LFY);
  al_translate_transform(@LTR, aX + LFX, aY + LFY);
  LTrans := SGT.Window.Transform;
  al_compose_transform(@LTR, @LTrans);
  al_use_transform(@LTR);
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  al_draw_ustr(FHandle, LColor, 0, 0, ALLEGRO_ALIGN_LEFT or ALLEGRO_ALIGN_INTEGER, LUstr);
  al_ustr_free(LUstr);
  LTrans := SGT.Window.Transform;
  al_use_transform(@LTrans);
end;


function  TFont.GetTextWidth(const aMsg: string; const aArgs: array of const): Single;
var
  LUstr: PALLEGRO_USTR;
  LText: string;
begin
  Result := 0;
  if not Assigned(FHandle) then Exit;
  if aMsg = '' then Exit;
  LText := FormatStr(aMsg, aArgs);
  LUstr := al_ustr_new_from_utf16(PUInt16(PChar(LText)));
  Result := al_get_ustr_width(FHandle, LUstr);
  al_ustr_free(LUstr);
end;

function  TFont.GetLineHeight: Single;
begin
  Result := 0;
  if not Assigned(FHandle) then Exit;
  Result := al_get_font_line_height(FHandle);
end;

{ TTexture }
constructor TTexture.Create;
begin
  inherited;
end;

destructor TTexture.Destroy;
begin
  Unload;
  inherited;
end;

function  TTexture.Allocate(aWidth: Integer; aHeight: Integer): Boolean;
var
  LHandle: PALLEGRO_BITMAP;
begin
  Result := False;
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR or ALLEGRO_MIPMAP or ALLEGRO_VIDEO_BITMAP);
  LHandle := al_create_bitmap(aWidth, aHeight);
  if not Assigned(LHandle) then Exit;
  Unload;
  FHandle := LHandle;
  FWidth := al_get_bitmap_width(FHandle);
  FHeight := al_get_bitmap_height(FHandle);
  FFilename := '';
  SGT.Log.Add('Sucessfully allocated texture (#i:#i)', [Round(FWidth), Round(FHeight)]);
  Result := True;
end;

function  TTexture.Load(aArchive: TArchive; const aFilename: string; aColorKey: PColor): Boolean;
var
  LHandle: PALLEGRO_BITMAP;
  LFilename: string;
  LColorKey: PALLEGRO_COLOR absolute aColorKey;
  LSandboxed: Boolean;
begin
  Result := False;
  if aFilename = '' then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not FileExist(aFilename) then Exit;
      LFilename := aFilename;
    end;
  LSandBoxed := SGT.GetFileSandBoxed;
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
  LHandle := al_load_bitmap(PAnsiChar(AnsiString(LFilename)));
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);
  if not Assigned(LHandle) then
  begin
    SGT.Log.Add('Failed to load texture file: #s', [aFilename]);
    Exit;
  end;

  Unload;
  FHandle := LHandle;
  FWidth := al_get_bitmap_width(FHandle);
  FHeight := al_get_bitmap_height(FHandle);
  FFilename := aFilename;

  if Assigned(aColorKey) then
    al_convert_mask_to_alpha(FHandle, LColorKey^);

  SGT.Log.Add('Sucessfully loaded texture file: "#s"', [aFilename]);

  Result := True;
end;

function TTexture.Unload: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  al_destroy_bitmap(FHandle);
  if FFilename = '' then
    SGT.Log.Add('Unloaded allocated texture (#i:#i)', [Round(FWidth), Round(FHeight)])
  else
    SGT.Log.Add('Unloaded texture file: "#s"', [FFilename]);
  FHandle := nil;
  FWidth := 0;
  FHeight := 0;
  FLocked := False;
  FFilename := '';
end;

function TTexture.Lock(aRegion: PRectangle; aData: PTextureData): Boolean;
var
  LLock: PALLEGRO_LOCKED_REGION;
begin
  Result := False;

  if FLocked then Exit;
  if not Assigned(FHandle) then Exit;

  LLock := nil;
  if not FLocked then
  begin
    if Assigned(aRegion) then
      begin
        LLock := al_lock_bitmap_region(FHandle, Round(aRegion.X), Round(aRegion.Y), Round(aRegion.Width), Round(aRegion.Height), ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        if not Assigned(LLock) then Exit;
        FLockedRegion.X := aRegion.X;
        FLockedRegion.Y := aRegion.Y;
        FLockedRegion.Width := aRegion.Width;
        FLockedRegion.Height := aRegion.Height;
      end
    else
      begin
        LLock := al_lock_bitmap(FHandle, ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READWRITE);
        if not Assigned(LLock) then Exit;
        FLockedRegion.X := 0;
        FLockedRegion.Y := 0;
        FLockedRegion.Width := FWidth;
        FLockedRegion.Height := FHeight;
      end;
    FLocked := True;
  end;

  if Assigned(LLock) then
  begin
    if Assigned(aData) then
    begin
      aData.Memory := LLock.data;
      aData.Format := LLock.format;
      aData.Pitch := LLock.pitch;
      aData.PixelSize := LLock.pixel_size;
    end;
  end;

  Result := True;
end;

function TTexture.Unlock: Boolean;
begin
  Result := False;
  if not FLocked then Exit;
  if not Assigned(FHandle) then Exit;

  al_unlock_bitmap(FHandle);
  FLocked := False;
  FLockedRegion.X := 0;
  FLockedRegion.Y := 0;
  FLockedRegion.Width := 0;
  FLockedRegion.Height := 0;

  Result := True;
end;

function  TTexture.GetPixel(aX: Integer; aY: Integer): TColor;
var
  LX,LY: Integer;
  LResult: ALLEGRO_COLOR absolute Result;
begin
  Result := BLANK;
  if not Assigned(FHandle) then Exit;
  LX := Round(aX + FLockedRegion.X);
  LY := Round(aY + FlockedRegion.Y);
  LResult := al_get_pixel(FHandle, LX, LY);
end;

procedure TTexture.SetPixel(aX: Integer; aY: Integer; aColor: TColor);
var
  LX,LY: Integer;
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  LX := Round(aX + FLockedRegion.X);
  LY := Round(aY + FlockedRegion.Y);
  al_put_pixel(LX, LY, LColor);
end;

procedure TTexture.Draw(aX, aY: Single; aRegion: PRectangle; aCenter: PVector;  aScale: PVector; aAngle: Single; aColor: TColor; aHFlip: Boolean; aVFlip: Boolean);
var
  LA: Single;
  LRG: TRectangle;
  LCP: TVector;
  LSC: TVector;
  LC: ALLEGRO_COLOR absolute aColor;
  LFlags: Integer;
begin
  if not Assigned(FHandle) then Exit;

  // angle
  LA := aAngle * DEG2RAD;
  LA := EnsureRange(LA, 0, 359);

  // region
  if Assigned(aRegion) then
    begin
      LRG.X := aRegion.X;
      LRG.Y := aRegion.Y;
      LRG.Width := aRegion.Width;
      LRG.Height := aRegion.Height;
    end
  else
    begin
      LRG.X := 0;
      LRG.Y := 0;
      LRG.Width := FWidth;
      LRG.Height := FHeight;
    end;

  if LRG.X < 0 then
    LRG.X := 0;
  if LRG.X > FWidth - 1 then
    LRG.X := FWidth - 1;

  if LRG.Y < 0 then
    LRG.Y := 0;
  if LRG.Y > FHeight - 1 then
    LRG.Y := FHeight - 1;

  if LRG.Width < 0 then
    LRG.Width := 0;
  if LRG.Width > FWidth then
    LRG.Width := LRG.Width;

  if LRG.Height < 0 then
    LRG.Height := 0;
  if LRG.Height > FHeight then
    LRG.Height := LRG.Height;

  // center
  if Assigned(aCenter) then
    begin
      LCP.X := (LRG.Width * aCenter.X);
      LCP.Y := (LRG.Height * aCenter.Y);
    end
  else
    begin
      LCP.X := 0;
      LCP.Y := 0;
    end;

  // scale
  if Assigned(aScale) then
    begin
      LSC.X := aScale.X;
      LSC.Y := aScale.Y;
    end
  else
    begin
      LSC.X := 1;
      LSC.Y := 1;
    end;

  // flags
  LFlags := 0;
  if aHFlip then LFlags := LFlags or ALLEGRO_FLIP_HORIZONTAL;
  if aVFlip then LFlags := LFlags or ALLEGRO_FLIP_VERTICAL;

  // render
  al_draw_tinted_scaled_rotated_bitmap_region(FHandle, LRG.X, LRG.Y, LRG.Width, LRG.Height, LC, LCP.X, LCP.Y, aX, aY, LSC.X, LSC.Y, LA, LFlags);
end;

procedure TTexture.Draw(aX, aY, aScale, aAngle: Single; aColor: TColor; aHAlign: THAlign; aVAlign: TVAlign; aHFlip: Boolean; aVFlip: Boolean);
var
  LCenter: TVector;
  LScale: TVector;
begin
  if not Assigned(FHandle) then Exit;

  LCenter.X := 0;
  LCenter.Y := 0;

  LScale.X := aScale;
  LScale.Y := aScale;

  case aHAlign of
    haLeft  : LCenter.X := 0;
    haCenter: LCenter.X := 0.5;
    haRight : LCenter.X := 1;
  end;

  case aVAlign of
    vaTop   : LCenter.Y := 0;
    vaCenter: LCenter.Y := 0.5;
    vaBottom: LCenter.Y := 1;
  end;

  Draw(aX, aY, nil, @LCenter, @LScale, aAngle, aColor, aHFlip, aVFlip);
end;

procedure TTexture.DrawTiled(aDeltaX: Single; aDeltaY: Single);
var
  LW,LH    : Integer;
  LOX,LOY  : Integer;
  LPX,LPY  : Single;
  LFX,LFY  : Single;
  LTX,LTY  : Integer;
  LVP      : TRectangle;
  LVR,LVB  : Integer;
  LIX,LIY  : Integer;
begin
  if not Assigned(FHandle) then Exit;

  SGT.Window.GetViewportSize(LVP);

  LW := Round(FWidth);
  LH := Round(FHeight);

  LOX := -LW+1;
  LOY := -LH+1;

  LPX := aDeltaX;
  LPY := aDeltaY;

  LFX := LPX-Floor(LPX);
  LFY := LPY-Floor(LPY);

  LTX := Floor(LPX)-LOX;
  LTY := Floor(LPY)-LOY;

  if (LTX>=0) then LTX := LTX mod LW + LOX else LTX := LW - -LTX mod LW + LOX;
  if (LTY>=0) then LTY := LTY mod LH + LOY else LTY := LH - -LTY mod LH + LOY;

  LVR := Round(LVP.Width);
  LVB := Round(LVP.Height);
  LIY := LTY;

  while LIY<LVB do
  begin
    LIX := LTX;
    while LIX<LVR do
    begin
      al_draw_bitmap(FHandle, LIX+LFX, LIY+LFY, 0);
      LIX := LIX+LW;
    end;
   LIY := LIY+LH;
  end;
end;

{ TRenderTarget }
constructor TRenderTarget.Create;
begin
  inherited;
  FTexture := TTexture.Create;
end;

destructor TRenderTarget.Destroy;
begin
  FreeNilObject(FTexture);
  inherited;
end;

procedure TRenderTarget.Init(aX, aY, aWidth, aHeight: Integer);
begin
  FTexture.Allocate(aWidth, aHeight);
  FPosition.Assign(aX, aY);
  FRegion.Assign(0, 0, FTexture.Width, FTexture.Height);
  FAngle := 0;
  FCenter.Assign(0.5, 0.5);
end;

function  TRenderTarget.GetActive: Boolean;
begin
  Result := FActive;
end;

procedure TRenderTarget.SetActive(aActive: Boolean);
begin
  if not Assigned(FTexture.Handle) then Exit;
  if aActive then
    begin
      al_set_target_bitmap(FTexture.Handle);
      SGT.Window.SetRenderTarget(Self);
      FActive := True;
    end
  else
    begin
      al_set_target_backbuffer(SGT.Window.Handle);
      SGT.Window.SetRenderTarget(nil);
      FActive := False;
    end;
end;

procedure TRenderTarget.SetPosition(aX: Single; aY: Single);
begin
  FPosition.Assign(aX, aY);
end;

procedure TRenderTarget.GetPosition(var aPosition: TVector);
begin
  FPosition.Assign(0, 0);
  if not Assigned(FTexture.Handle) then Exit;
  aPosition := FPosition;
end;

procedure TRenderTarget.GetSize(var aSize: TRectangle);
begin
  aSize.Assign(0, 0, 0, 0);
  if not Assigned(FTexture.Handle) then Exit;
  aSize.Assign(FPosition.X, FPosition.Y, FTexture.Width, FTexture.Height);
end;

procedure TRenderTarget.SetRegion(aX: Single; aY: Single; aWidth: Single; aHeight: Single);
begin
  if not Assigned(FTexture.Handle) then Exit;
  FRegion.Assign(aX, aY, aWidth, aHeight);
end;

procedure TRenderTarget.GetRegion(var aRegion: TRectangle);
begin
  aRegion.Assign(0, 0, 0, 0);
  if not Assigned(FTexture.Handle) then Exit;
  aRegion := FRegion;
end;

procedure TRenderTarget.SetAngle(aAngle: Single);
begin
  FAngle := aAngle;
  if FAngle > 359 then
    begin
      while FAngle > 359 do
      begin
        FAngle := FAngle - 359;
      end;
    end
  else
  if FAngle < 0 then
    begin
      while FAngle < 0 do
      begin
        FAngle := FAngle + 359;
      end;
    end;
end;

function  TRenderTarget.GetAngle: Single;
begin
  Result := FAngle;
end;

procedure TRenderTarget.Show;
begin
  if FActive then
    al_set_target_backbuffer(SGT.Window.Handle);
  FTexture.Draw(FPosition.X+(FTexture.Width/2), FPosition.Y+(FTexture.Height/2), @FRegion, @FCenter, nil, FAngle, WHITE);
  if FActive then
    al_set_target_bitmap(FTexture.Handle);
end;

{ TShader }
constructor TShader.Create;
begin
  inherited;
  FHandle := al_create_shader(ALLEGRO_SHADER_GLSL);
  Clear;
end;

destructor TShader.Destroy;
begin
  Clear;
  if Assigned(FHandle) then al_destroy_shader(FHandle);
  FHandle := nil;
  inherited;
end;

procedure TShader.Clear;
begin
  if not Assigned(FHandle) then Exit;
  al_use_shader(nil);
  al_attach_shader_source(FHandle, ALLEGRO_VERTEX_SHADER, nil);
  al_attach_shader_source(FHandle, ALLEGRO_PIXEL_SHADER, nil);

  al_attach_shader_source(FHandle, ALLEGRO_VERTEX_SHADER,
    al_get_default_shader_source(ALLEGRO_SHADER_GLSL, ALLEGRO_VERTEX_SHADER));

  al_attach_shader_source(FHandle, ALLEGRO_PIXEL_SHADER,
    al_get_default_shader_source(ALLEGRO_SHADER_GLSL, ALLEGRO_PIXEL_SHADER));
end;

function TShader.Load(aType: TShaderType; const aSource: string): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  if aSource = '' then Exit;
  al_attach_shader_source(FHandle, Ord(aType), nil);
  Result := al_attach_shader_source(FHandle, Ord(aType), PAnsiChar(AnsiString(aSource)));
  if Result then
    SGT.Log.Add('Sucessfully attached shader source', [])
  else
    SGT.Log.Add('Failed to attached shader source', []);
end;

function TShader.Load(aArchive: TArchive; aType: TShaderType; const aFilename: string): Boolean;
var
  LSandBoxed: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  if aFilename = '' then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then Exit;
      al_attach_shader_source(FHandle, Ord(aType), nil);
      if not al_attach_shader_source_file(FHandle, Ord(aType), aArchive.GetPasswordFilename(aFilename)) then
      begin
        SGT.Log.Add('Failed to attached shader file: #s', [aFilename]);
        Exit;
      end;
    end
  else
    begin   //ALLEGRO_PIXEL_SHADER
      if not FileExist(aFilename) then Exit;
      LSandBoxed := SGT.GetFileSandBoxed;
      if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
      if not al_attach_shader_source_file(FHandle, Ord(aType), PAnsiChar(AnsiString(aFilename))) then
      begin
        SGT.Log.Add('Failed to attached shader file: #s', [aFilename]);
        Exit;
      end;
      if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);
    end;

  SGT.Log.Add('Sucessfully attached shader file: "#s"', [aFilename]);
  Result := True;
end;

function TShader.Build: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := al_build_shader(FHandle);
end;

function TShader.Enable(aEnable: Boolean): Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  if aEnable then
    Result := al_use_shader(FHandle)
  else
    Result := al_use_shader(nil);
end;

function TShader.Log: string;
begin
  Result := '';
  if not Assigned(FHandle) then Exit;
  Result := string(al_get_shader_log(FHandle));
end;

function TShader.SetIntUniform(const aName: string; aValue: Integer): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  Result := al_set_shader_int(PAnsiChar(AnsiString(aName)), aValue);
end;

function TShader.SetIntUniform(const aName: string; aNumComponents: Integer; aValue: PInteger; aNumElements: Integer): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  Result := al_set_shader_int_vector(PAnsiChar(AnsiString(aName)), aNumComponents, aValue, aNumElements);
end;

function TShader.SetFloatUniform(const aName: string; aValue: Single): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  Result := al_set_shader_float(PAnsiChar(AnsiString(aName)), aValue);
end;

function TShader.SetFloatUniform(const aName: string; aNumComponents: Integer; aValue: System.PSingle; aNumElements: Integer): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  Result := al_set_shader_float_vector(PAnsiChar(AnsiString(aName)), aNumComponents, aValue, aNumElements);
end;

function TShader.SetBoolUniform(const aName: string; aValue: Boolean): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  Result := al_set_shader_bool(PAnsiChar(AnsiString(aName)), aValue);
end;

function TShader.SetTextureUniform(const aName: string; aTexture: TTexture): Boolean;
begin
  Result := False;
  if aName = '' then Exit;
  if not Assigned(FHandle) then Exit;
  if not Assigned(aTexture) then Exit;
  Result := al_set_shader_sampler(PAnsiChar(AnsiString(aName)), aTexture.Handle, 1);
end;

function TShader.SetVec2Uniform(const aName: string; aValue: TVector): Boolean;
var
  LVec2: array[0..1] of Single;
begin
  LVec2[0] := aValue.X;
  LVec2[1] := aValue.Y;
  Result := SetFloatUniform(aName, 2, @LVec2, 1);
end;

function TShader.SetVec2Uniform(const aName: string; aX: Single; aY: Single): Boolean;
var
  LVec2: array[0..1] of Single;
begin
  LVec2[0] := aX;
  LVec2[1] := aY;
  Result := SetFloatUniform(aName, 2, @LVec2, 1);
end;

{ TCmdConsole }
function TCmdConsole.ProcessCmd(aName: string; var aWasInternalCmd: Boolean): Boolean;
var
  LAction: PAction;
  LMaxLen: Integer;
  I: Integer;
  LList: TStringList;
begin
  Result := False;

  FCmdParams.Clear;

  ExtractStrings([#32], [#32], PChar(aName), FCmdParams);

  // check internal commands
  if SameText('cls', FCmdParams.Items[0]) then
    begin
      FTextLines.Clear;
      aWasInternalCmd := True;
      Result := True;
      Exit;
    end
  else
  if SameText('help', FCmdParams.Items[0]) then
    begin
      AddTextLine('', []);
      AddTextLine('Options:', []);
      LList := TStringList.Create;
      LList.AddPair('up/down', 'Console history');
      LList.AddPair('cls', 'Clear console window');
      LList.AddPair('help', 'Display list of commands');

      for I := 0 to FCmdActionList.Count-1 do
      begin
        LAction := FCmdActionList.Items[I];
        LList.AddPair(LAction.Name, LAction.Discription);
      end;

      LMaxLen := 0;
      for I := 0 to LList.Count-1 do
      begin
        if Length(LList.GetKey(I)) > LMaxLen then
          LMaxLen := Length(LList.GetKey(I));
      end;

      for I := 0 to LList.Count-1 do
      begin
        AddTextLine('  #s - #s', [PadRightStr(LList.GetKey(I), LMaxLen, ' '), LList.GetValue(I)]);
      end;

      FreeNilObject(LList);
      aWasInternalCmd := True;
      Result := True;
      Exit;
    end;

  // check external commands
  for I := 0 to FCmdActionList.Count-1 do
  begin
    LAction := FCmdActionList.Items[I];
    if SameText(FCmdParams.Items[0], LAction.Name) then
    begin
      if Assigned(LAction.Handler) then
      begin
        FCmdParams.Delete(0);
        LAction.Handler;
        FCmdParams.Clear;
        Result := True;
      end;
      Break;
    end;
  end;
end;

procedure TCmdConsole.AddTextLine(const aMsg: string; const aArgs: array of const);
begin
  if aMsg = '' then Exit;

  FMaxTextLinesCount := Round(FSize.Height / FFontHeight);
  if FTextLines.Count = FMaxTextLinesCount then
  begin
    FTextLines.Delete(0);
  end;

  FTextLines.Add(FormatStr(aMsg, aArgs));;
end;

procedure TCmdConsole.Setup;
begin
  FActive := False;
  FState := stInactive;
  FEnabled := False;
  FTextLines := TStringList.Create;
  FCmdHistory := TStringList.Create;
  FCmdParams := TStringList.Create;
  FCmdActionList := TList.Create;
  SGT.Log.Add('Initialized #s Subsystem', ['CmdConsole']);
end;

procedure TCmdConsole.Shutdown;
begin
  Close;
  FreeNilObject(FCmdActionList);
  FreeNilObject(FCmdParams);
  FreeNilObject(FCmdHistory);
  FreeNilObject(FTextLines);
  SGT.Log.Add('Shutdown #s Subsystem', ['CmdConsole']);
end;

procedure TCmdConsole.Open;
begin
  FActive := False;
  FState := stInactive;
  FFont := TFont.Create;
  FFont.LoadDefault(18);
  FFontHeight := FFont.GetLineHeight;
  FToggleKey :=  KEY_TILDE;
  FSlideSpeed := cDefaultSlideSpeed;
  FCmdLine := '';
  FLastChar := 0;
  FCmdCurPos := 0;
  FCurFlashTimer := 0;
  FCurFlash := True;
  FTextLines.Clear;
  FCmdHistory.Clear;
  FCmdParams.Clear;
  FCmdHistoryIndex := 0;
  FMaxCmdHistoryCount := cDefaultMaxCmdHistoryCount;
  FMaxTextLinesCount := cDefaultMaxTextLinesCount;
  FEnabled := True;
  FSlider := 1;
end;

procedure TCmdConsole.Close;
begin
  FreeNilObject(FFont);
  FTextLines.Clear;
  FCmdHistory.Clear;
  FCmdParams.Clear;
  ClearCommands;
  FCmdActionList.Clear;
  FActive := False;
  FState := stInactive;
  FEnabled := False;
end;

procedure TCmdConsole.Render;
var
  LPos: TVector;
  LFormat: string;
  LIndex: Integer;
begin
  //if not FActive then Exit;
  if not FEnabled then Exit;
  if FState = stInactive then Exit;

  SGT.Window.DrawFilledRectangle(FPos.X, FPos.Y, FSize.Width, FSize.Height, OVERLAY1);
  SGT.Window.DrawRectangle(FPos.X, FPos.Y, FSize.Width, FSize.Height, cDefaultFrameWidth, DIMGRAY);
  SGT.Window.DrawFilledRectangle(FPos.X+(cDefaultFrameWidth div 2), (FPos.Y+(cDefaultFrameWidth div 2)), FSize.Width-cDefaultFrameWidth, FFontHeight, DIMWHITE);
  FFont.PrintText(FSize.Width/2, (FPos.Y+(cDefaultFrameWidth div 2)-cDefaultMargins), YELLOW, haCenter, '>>> Command Console <<<', []);
  SGT.Window.DrawFilledRectangle(FPos.X+(cDefaultFrameWidth div 2), (FPos.Y+FSize.Height)-FFontHeight+(cDefaultFrameWidth div 2), FSize.Width-cDefaultFrameWidth, FFontHeight, DIMWHITE);

  // draw input
  LFormat := '>#s';
  LPos.X := FPos.X+(cDefaultFrameWidth div 2) + cDefaultMargins;
  LPos.Y := (FPos.Y+FSize.Height)-FFontHeight+(cDefaultFrameWidth div 2)-2;
  FFont.PrintText(LPos.X, LPos.Y, WHITE, haLeft, LFormat, [FCmdLine]);
  LPos.X := LPos.X + FFont.GetTextWidth(LFormat, [FCmdLine]) + cDefaultMargins;
  if Game.FrameElapsed(FCurFlashTimer, 15) then FCurFlash := not FCurFlash;
  if FCurFlash then SGT.Window.DrawFilledRectangle(LPos.X, LPos.Y+4, 6, FFontHeight-6, WHITE);

  // draw text line
  LPos.X := FPos.X+(cDefaultFrameWidth div 2) + cDefaultMargins;
  LPos.Y := LPos.Y - FFontHeight;
  for LIndex := FTextLines.Count-1 downto 0 do
  begin
    if LPos.Y < (FPos.Y+(cDefaultFrameWidth div 2)+FFontHeight) then continue;
    FFont.PrintText(LPos.X, LPos.Y, WHITE, haLeft, FTextLines[LIndex], []);
    LPos.Y := LPos.Y - FFontHeight;
  end;
end;

function TCmdConsole.Toggle: Boolean;
begin
  Result := False;
  if FState = stInactive then
  begin
    SGT.Window.GetViewportSize(FSize);
    FSize.Height := FSize.Height * cCmdConsoleViewPrecentage;
    FPos.X := FSize.X;
    FPos.Y := FSize.Y - FSize.Height;
    FState := stSlideDown;
    FSlider := 1;
    Result := True;
  end
  else
  if FState = stSlideDown then
  begin
    FState := stSlideUp;
    FSlider := 1;
    SGT.Window.GetViewportSize(FSize);
    FSize.Height := FSize.Height * cCmdConsoleViewPrecentage;
    Result := True;
  end;

  if Result then
  begin
    SGT.Input.Clear;
  end;
end;

procedure TCmdConsole.Update(aDeltaTime: Double);
var
  LChar: Integer;
  LWasInternalCmd: Boolean;
begin
  if not FEnabled then Exit;

  if SGT.Input.KeyPressed(FToggleKey) then
  begin
    SGT.Input.Clear;
    if Toggle then Exit;
  end;

  if FState = stInactive then Exit;
  FSlider := EasePosition(1, 100, FSlider, etLinearTween);
  if FState = stSlideDown then
    begin
      FPos.Y := (FSize.Y - FSize.Height) + (FSize.Height*(FSlider/100.00));
      if FPos.Y >= FSize.Y then
      begin
        FPos.Y := FSize.Y;
        if not FActive then SGT.EmitCmdConActiveEvent;
        if FTextLines.Count = 0 then AddTextLine('Type Help for list of commands', []);
        FActive := True;
      end;
    end
  else
  if FState = stSlideUp then
  begin
    FPos.Y := FSize.Y - (FSize.Height*(FSlider/100.00));
    if FPos.Y <= (FSize.Y - FSize.Height) then
    begin
      FState := stInactive;
      FActive := False;
      SGT.EmitCmdConInactiveEvent;
      Exit;
    end;
  end;
  FSlider := FSlider + (FSlideSpeed * aDeltaTime);

  // process input
  LChar := SGT.Input.KeyCode;
  if not SGT.Input.KeyCodeRepeat then
  begin
    if LChar <> FLastChar then
      FLastChar := LChar
    else
      LChar := 0;
  end;

  // process input
  if (LChar = 8) then
    begin
      if Length(FCmdLine) >= 1 then
      begin
        //FCmdLine := FCmdLine.Remove(FCmdLine.Length-1, 1);
        Delete(FCmdLine,  Length(FCmdLine), 1);
        FCurFlash := True;
      end;
    end
  else
  if (LChar = 13) then
    begin
      //FCmdLine := FCmdLine.Trim;
      FCmdLine := TrimStr(FCmdLine);

      if FCmdLine <> '' then
      begin
        AddTextLine(FCmdLine, []);
        LWasInternalCmd := False;
        if ProcessCmd(FCmdLine, LWasInternalCmd) then
        begin

          // check to trim to maxium allowed
          if FCmdHistory.Count = FMaxCmdHistoryCount then
          begin
            FCmdHistory.Delete(0);
          end;
          FCmdHistory.Add(FCmdLine);
        end
        else
        begin
          FTextLines.Add('Error: Unknown command!');
        end;

        FCmdLine := '';
        FCurFlash := True;
      end;

    end
  else
  //ascii char
  if (LChar >= 32) and
     (LChar <= 127) then
    begin
      FCmdLine := FCmdLine + Chr(LChar);
      FCurFlash := True;
    end
  else
  begin
    // process extended keys
    if SGT.Input.KeyPressed(KEY_UP) then
      begin
        if FCmdHistoryIndex > 0 then
        begin
          Dec(FCmdHistoryIndex);
          FCmdLine := FCmdHistory[FCmdHistoryIndex];
          FCurFlash := True;
        end;
      end
    else
    if SGT.Input.KeyPressed(KEY_DOWN) then
    begin
      if FCmdHistoryIndex < FCmdHistory.Count-1 then
      begin
        Inc(FCmdHistoryIndex);
        FCmdLine := FCmdHistory[FCmdHistoryIndex];
        FCurFlash := True;
      end;

    end;
  end;
end;

constructor TCmdConsole.Create;
begin
  inherited;

  Setup;
end;

destructor TCmdConsole.Destroy;
begin
  Shutdown;

  inherited;
end;

function  TCmdConsole.GetActive: Boolean;
begin
  Result := FActive;
end;

procedure TCmdConsole.LoadFont(aArchive: TArchive; aSize: Cardinal; const aFilename: string);
begin
  FFont.Load(aArchive, aSize, aFilename);
  FFontHeight := FFont.GetLineHeight;
end;

procedure TCmdConsole.SetToggleKey(aKey: Integer);
begin
  FToggleKey := aKey;
  if (FToggleKey < KEY_A) and
     (FToggleKey >= KEY_MAX) then
    FToggleKey := KEY_TILDE;
end;

procedure TCmdConsole.SetSlideSpeed(aSpeed: Single);
begin
  FSlideSpeed := aSpeed;
  if (FSlideSpeed < 0) then
    FSlideSpeed := cDefaultSlideSpeed;
end;

procedure TCmdConsole.ClearCommands;
var
  LAction: PAction;
  I: Integer;
begin

  for I := 0 to FCmdActionList.Count-1 do
  begin
    LAction := FCmdActionList.Items[I];
    Dispose(LAction);
  end;

  FCmdActionList.Clear;
end;

procedure TCmdConsole.AddCommand(const aName: string; const aDiscription: string; aAction: TCmdConsoleActionEvent);
var
  LAction: PAction;
  I: Integer;
begin
  if aName = '' then Exit;
  if not Assigned(aAction) then Exit;

  for I := 0 to FCmdActionList.Count-1 do
  begin
    LAction := FCmdActionList.Items[I];
    if SameText(aName, LAction.Name) then Exit;
  end;

  New(LAction);
  LAction.Name := aName;
  LAction.Discription := aDiscription;
  LAction.Handler := aAction;
  FCmdActionList.Add(LAction);
end;

procedure TCmdConsole.Enable(aEnable: Boolean);
begin
  FEnabled := aEnable;
end;

function  TCmdConsole.ParamCount: Integer;
begin
  Result := FCmdParams.Count;
end;

function  TCmdConsole.ParamStr(aIndex: Integer): string;
begin
  Result := '';
  if (aIndex < 0) then Exit;
  if (aIndex > FCmdParams.Count-1) then Exit;
  Result := FCmdParams[aIndex];
end;

{ TVideo }
procedure TVideo.OnFinished(aHandle: PALLEGRO_VIDEO);
begin
  if FHandle <> aHandle then Exit;

  Rewind;
  if FLoop then
    begin
      if not FPaused then
        SetPlaying(True);
    end
  else
    begin
      Game.OnVideoState(vsFinished, FFilename);
    end;
end;
procedure TVideo.Play(aLoop: Boolean; aVolume: Single);
begin
  if not Assigned(FHandle) then Exit;
  al_start_video(FHandle, FMixer);
  al_set_mixer_gain(FMixer, aVolume);
  al_set_video_playing(FHandle, True);
  FLoop := aLoop;
  FPlaying := True;
  FPaused := False;
  Game.OnVideoState(vsPlaying, FFilename);
end;

constructor TVideo.Create;
begin
  inherited;
end;

destructor TVideo.Destroy;
begin
  Unload;
  inherited;
end;

function  TVideo.Load(aArchive: TArchive; const aFilename: string): Boolean;
var
  LFilename: string;
  LHandle: PALLEGRO_VIDEO;
  LSandBoxed: Boolean;
begin
  Result := False;
  if aFilename = '' then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then
      begin
        SGT.Log.Add('Failed to load video file: #s', [aFilename]);
        Exit;
      end;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not FileExist(aFilename) then
      begin
        SGT.Log.Add('Failed to load video file: #s', [aFilename]);
        Exit;
      end;
      LFilename := aFilename;
    end;

  Unload;

  LSandBoxed := SGT.GetFileSandBoxed;
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
  LHandle := al_open_video(PAnsiChar(AnsiString(LFilename)));
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);

  if not Assigned(LHandle) then Exit;

  if al_is_audio_installed then
  begin
    if not Assigned(FVoice) then
    begin
      FVoice := al_create_voice(44100, ALLEGRO_AUDIO_DEPTH_INT16, ALLEGRO_CHANNEL_CONF_2);
      FMixer := al_create_mixer(44100, ALLEGRO_AUDIO_DEPTH_FLOAT32, ALLEGRO_CHANNEL_CONF_2);
      al_attach_mixer_to_voice(FMixer, FVoice);
    end;
  end;

  al_register_event_source(SGT.Queue, al_get_video_event_source(LHandle));
  al_set_video_playing(LHandle, False);

  FHandle := LHandle;
  FFilename := aFilename;
  FLoop := False;
  FPlaying := False;
  FPaused := False;
  Game.OnVideoState(vsLoad, FFilename);
  SGT.Log.Add('Sucessfully loaded video: "#s"', [aFilename]);
  Result := True;
end;

function  TVideo.Unload: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Game.OnVideoState(vsUnload, FFilename);
  al_set_video_playing(FHandle, False);
  al_unregister_event_source(SGT.Queue, al_get_video_event_source(FHandle));
  al_close_video(FHandle);

  if al_is_audio_installed then
  begin
    al_detach_mixer(FMixer);
    al_destroy_mixer(FMixer);
    al_destroy_voice(FVoice);
  end;

  SGT.Log.Add('Unloaded video "#s"', [FFilename]);

  FHandle := nil;
  FMixer := nil;
  FVoice := nil;
  FFilename := '';
  FLoop := False;
  FPlaying := False;
  FPaused := False;

end;

function  TVideo.GetPause: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := FPaused;
end;

procedure TVideo.SetPause(aPause: Boolean);
begin
  if not Assigned(FHandle) then Exit;

  // if trying to pause and video is not playing, just exit
  if (aPause = True) then
  begin
    if not al_is_video_playing(FHandle) then
    Exit;
  end;

  // if trying to unpause without first being paused, just exit
  if (aPause = False) then
  begin
    if FPaused = False then
      Exit;
  end;

  al_set_video_playing(FHandle, not aPause);
  FPaused := aPause;
  if FPaused then
    Game.OnVideoState(vsPaused, FFilename)
  else
    Game.OnVideoState(vsPlaying, FFilename);
end;

function  TVideo.GetLooping:  Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := FLoop;
end;

procedure TVideo.SetLoping(aLoop: Boolean);
begin
  if not Assigned(FHandle) then Exit;
  FLoop := aLoop;
end;

function  TVideo.GetPlaying: Boolean;
begin
  Result := False;
  if not Assigned(FHandle) then Exit;
  Result := al_is_video_playing(FHandle);
end;

procedure TVideo.SetPlaying(aPlay: Boolean);
begin
  if not Assigned(FHandle) then Exit;
  if FPaused then Exit;
  al_set_video_playing(FHandle, aPlay);
  FPlaying := aPlay;
  FPaused := False;
  Game.OnVideoState(vsPlaying, FFilename);
end;

function  TVideo.GetFilename: string;
begin
  Result := '';
  if not Assigned(FHandle) then Exit;
  Result := FFilename;
end;

procedure TVideo.Play(aArchive: TArchive; const aFilename: string; aLoop: Boolean; aVolume: Single);
begin
  if not Load(aArchive, aFilename) then Exit;
  Play(aLoop, aVolume);
end;

procedure TVideo.Draw(aX: Single; aY: Single; aScale: Single);
var
  LFrame: PALLEGRO_BITMAP;
  LSize: TVector;
  LScaled: TVector;
  LViewportSize: TRectangle;
  LScale: Single;
begin
  if not Assigned(FHandle) then Exit;
  if aScale <= 0 then Exit;
  LScale := aScale;

  if (not GetPlaying) and (not FPaused) then Exit;

  LFrame := al_get_video_frame(FHandle);
  if Assigned(LFrame) then
  begin
    SGT.Window.GetViewportSize(LViewportSize);
    LSize.X := al_get_bitmap_width(LFrame);
    LSize.Y := al_get_bitmap_height(LFrame);
    LScaled.X := al_get_video_scaled_width(FHandle);
    LScaled.Y := al_get_video_scaled_height(FHandle);

    al_draw_scaled_bitmap(LFrame, 0, 0,
      LSize.X,
      LSize.Y,
      aX, aY,
      LScaled.X*LScale,
      LScaled.Y*LScale,
      0);
  end;
end;

procedure TVideo.GetSize(aWidth: System.PSingle; aHeight: System.PSingle);
begin
  if not Assigned(FHandle) then
  begin
    if Assigned(aWidth) then
      aWidth^ := 0;
    if Assigned(aHeight) then
      aHeight^ := 0;
    Exit;
  end;
  if Assigned(aWidth) then
    aWidth^ := al_get_video_scaled_width(FHandle);
  if Assigned(aHeight) then
    aHeight^ := al_get_video_scaled_height(FHandle);
end;

procedure TVideo.Seek(aSeconds: Single);
begin
  if not Assigned(FHandle) then Exit;
  al_seek_video(FHandle, aSeconds);
end;

procedure TVideo.Rewind;
begin
  if not Assigned(FHandle) then Exit;
  al_seek_video(FHandle, 0);
end;

{ TAScreenshake }
constructor TAScreenshake.Create(aDuration: Single; aMagnitude: Single);
begin
  inherited Create;

  FActive := True;
  FDuration := aDuration;
  FMagnitude := aMagnitude;
  FTimer := 0;
  FPos.x := 0;
  FPos.y := 0;
end;

destructor TAScreenshake.Destroy;
begin
  inherited;
end;

procedure TAScreenshake.Process(aSpeed: Single; aDeltaTime: Double);
begin
  if not FActive then Exit;

  FDuration := FDuration - (aSpeed * aDeltaTime);
  if FDuration <= 0 then
  begin
    SGT.Window.SetTransformPos(-FPos.x, -FPos.y);
    FActive := False;
    Exit;
  end;

  if Round(FDuration) <> Round(FTimer) then
  begin
    SGT.Window.SetTransformPos(-FPos.x, -FPos.y);

    FPos.x := Round(RandomRange(-FMagnitude, FMagnitude));
    FPos.y := Round(RandomRange(-FMagnitude, FMagnitude));

    SGT.Window.SetTransformPos(FPos.x, FPos.y);

    FTimer := FDuration;
  end;
end;

{ TScreenshake }
procedure TScreenshake.Process(aSpeed: Single; aDeltaTime: Double);
var
  LShake: TAScreenshake;
  I: Integer;
begin
  // process shakes
  for I := FList.Count-1 downto 0 do
  begin
    LShake := FList.Items[I];

    if LShake.Active then
      LShake.Process(aSpeed, aDeltaTime)
    else
      begin
        FreeNilObject(LShake);
        FList.Delete(I);
      end;
  end;
end;

constructor TScreenshake.Create;
begin
  inherited;
  FList := TList.Create;
  al_identity_transform(@FTrans);
end;

destructor TScreenshake.Destroy;
begin
  Clear;
  FreeNilObject(FList);
  inherited;
end;

procedure TScreenshake.Start(aDuration: Single; aMagnitude: Single);
var
  LShake: TAScreenshake;
begin
  LShake := TAScreenshake.Create(aDuration, aMagnitude);
  FList.Add(LShake);
end;

procedure TScreenshake.Clear;
var
  I: Integer;
  LShake: TAScreenshake;
begin
  for I := 0 to FList.Count-1 do
  begin
    LShake := FList.Items[I];
    FreeNilObject(LShake);
  end;

  FList.Clear;
end;

function TScreenshake.Active: Boolean;
begin
  Result := Boolean(FList.Count > 0);
end;

{ TScreenshot }
procedure TScreenshot.Process;
var
  LC: Integer;
  LF, LD, LB: string;
begin
  if SGT.Screenshake.Active then Exit;
  if not FFlag then Exit;

  FFlag := False;

  // directory
  LD := ExpandFilename(FDir);
  ForceDirectories(LD);

  // base name
  LB := FBaseFilename;

  // search file maks
  LF := LB + '*.png';

  // file count
  LC := FileCount(LD, LF);

  // screenshot file mask
  LF := FormatStr('#s\#s (#i:6).png', [LD, LB, LC]);
  FFilename := LF;

  // save screenshot
  SGT.Window.Save(LF);

  // call event handler
  if FileExist(LF) then
    Game.OnScreenshot(LF);
end;

constructor TScreenshot.Create;
begin
  inherited;
  Init;
end;

destructor TScreenshot.Destroy;
begin
  inherited;
end;

procedure TScreenshot.Init(const aDir: string; const aBaseFilename: string);
begin

  FFilename := '';
  FFlag := False;

  if aDir = '' then
    FDir := 'Screenshots'
  else
    FDir := aDir;

  if aBaseFilename = '' then
    FBaseFilename := 'Screen';

  ChangeFileExt(FBaseFilename, '');
end;

procedure TScreenshot.Take;
begin
  FFlag := True;
end;

{ TStarfield }
procedure TStarfield.TransformDrawPoint(aX, aY, aZ: Single; aVPX, aVPY, aVPW, aVPH: Integer);
var
  LX, LY: Single;
  LSize: Single;
  LOOZ: Single;
  LCV: byte;
  LColor: TColor;

  function IsVisible(vx, vy, vw, vh: Single): Boolean;
  begin
    Result := False;
    if ((vx - vw) < 0) then Exit;
    if (vx > (aVPW - 1)) then Exit;
    if ((vy - vh) < 0) then Exit;
    if (vy > (aVPH - 1)) then Exit;
    Result := True;
  end;

begin
  FViewScaleRatio := aVPW / aVPH;
  FCenter.X := (aVPW / 2) + aVPX;
  FCenter.Y := (aVPH / 2) + aVPY;

  LOOZ := ((1.0 / aZ) * FViewScale);
  LX := (FCenter.X - aVPX) - (aX * LOOZ) * FViewScaleRatio;
  LY := (FCenter.Y - aVPY) + (aY * LOOZ) * FViewScaleRatio;
  LSize := (1.0 * LOOZ);
  if LSize < 2 then LSize := 2;

  LX := LX - FVirtualPos.X;
  LY := LY - FVirtualPos.Y;
  if not IsVisible(LX, LY, LSize, LSize) then Exit;

  LCV := round(255.0 - (((1.0 / FMax.Z) / (1.0 / aZ)) * 255.0));
  LColor.FromByte(LCV, LCV, LCV, LCV);

  SGT.Window.DrawFilledRectangle(LX, LY, LSize, LSize, LColor);
end;

constructor TStarfield.Create;
begin
  inherited;
  Init(250, -1000, -1000, 10, 1000, 1000, 1000, 120);
end;

destructor TStarfield.Destroy;
begin
  Done;
  inherited;
end;

procedure TStarfield.Init(aStarCount: Cardinal; aMinX, aMinY, aMinZ, aMaxX, aMaxY, aMaxZ, aViewScale: Single);
var
  LVPX, LVPY: Integer;
  LVPW, LVPH: Integer;
  LI: Integer;
  LSize: TRectangle;
begin
  Done;

  FStarCount := aStarCount;
  SetLength(FStar, FStarCount);
  SGT.Window.GetViewportSize(LSize);
  LVPX := Round(LSize.X);
  LVPY := Round(LSize.Y);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);

  FViewScale := aViewScale;
  FViewScaleRatio := LVPW / LVPH;
  FCenter.X := (LVPW / 2) + LVPX;
  FCenter.Y := (LVPH / 2) + LVPY;
  FCenter.Z := 0;

  FMin.X := aMinX;
  FMin.Y := aMinY;
  FMin.Z := aMinZ;
  FMax.X := aMaxX;
  FMax.Y := aMaxY;
  FMax.Z := aMaxZ;

  for LI := 0 to FStarCount - 1 do
  begin
    FStar[LI].X := RandomRange(FMin.X, FMax.X);
    FStar[LI].Y := RandomRange(FMin.Y, FMax.Y);
    FStar[LI].Z := RandomRange(FMin.Z, FMax.Z);
  end;

  SetXSpeed(0.0);
  SetYSpeed(0.0);
  SetZSpeed(-60*3);
  SetVirtualPos(0, 0);
end;

procedure TStarfield.Done;
begin
  FStar := nil;
end;

procedure TStarfield.SetVirtualPos(aX, aY: Single);
begin
  FVirtualPos.X := aX;
  FVirtualPos.Y := aY;
  FVirtualPos.Z := 0;
end;

procedure TStarfield.GetVirtualPos(var aX: Single; var aY: Single);
begin
  aX := FVirtualPos.X;
  aY := FVirtualPos.Y;
end;

procedure TStarfield.SetXSpeed(aSpeed: Single);
begin
  FSpeed.X := aSpeed;
end;

procedure TStarfield.SetYSpeed(aSpeed: Single);
begin
  FSpeed.Y := aSpeed;
end;

procedure TStarfield.SetZSpeed(aSpeed: Single);
begin
  FSpeed.Z := aSpeed;
end;

procedure TStarfield.Update(aDeltaTime: Single);
var
  LI: Integer;

  procedure SetRandomPos(aIndex: Integer);
  begin
    FStar[aIndex].X := RandomRange(FMin.X, FMax.X);
    FStar[aIndex].Y := RandomRange(FMin.Y, FMax.Y);
    FStar[aIndex].Z := RandomRange(FMin.Z, FMax.Z);
  end;

begin

  for LI := 0 to FStarCount - 1 do
  begin
    FStar[LI].X := FStar[LI].X + (FSpeed.X * aDeltaTime);
    FStar[LI].Y := FStar[LI].Y + (FSpeed.Y * aDeltaTime);
    FStar[LI].Z := FStar[LI].Z + (FSpeed.Z * aDeltaTime);

    if FStar[LI].X < FMin.X then
    begin
      SetRandomPos(LI);
      FStar[LI].X := FMax.X;
    end;

    if FStar[LI].X > FMax.X then
    begin
      SetRandomPos(LI);
      FStar[LI].X := FMin.X;
    end;

    if FStar[LI].Y < FMin.Y then
    begin
      SetRandomPos(LI);
      FStar[LI].Y := FMax.Y;
    end;

    if FStar[LI].Y > FMax.Y then
    begin
      SetRandomPos(LI);
      FStar[LI].Y := FMin.Y;
    end;

    if FStar[LI].Z < FMin.Z then
    begin
      SetRandomPos(LI);
      FStar[LI].Z := FMax.Z;
    end;

    if FStar[LI].Z > FMax.Z then
    begin
      SetRandomPos(LI);
      FStar[LI].Z := FMin.Z;
    end;

  end;
end;

procedure TStarfield.Render;
var
  LI: Integer;
  LVPX, LVPY, LVPW, LVPH: Integer;
  LSize: TRectangle;
begin
  SGT.Window.GetViewportSize(LSize);
  LVPX := Round(LSize.X);
  LVPY := Round(LSize.Y);
  LVPW := Round(LSize.Width);
  LVPH := Round(LSize.Height);
  for LI := 0 to FStarCount - 1 do
  begin
    TransformDrawPoint(FStar[LI].X, FStar[LI].Y, FStar[LI].Z, LVPX, LVPY, LVPW, LVPH);
  end;
end;

{$ENDREGION}

{$REGION 'Spark.Window'}
{ TWindow }
procedure TWindow.ScaleWindowToDPI;
var
  LDpi: Integer;
  LSX,LSY: Integer;
  LWX,LWY: Integer;
  LDW,LDH: Integer;
begin
  if not Assigned(FHandle) then Exit;

  LDW := al_get_display_width(FHandle);
  LDH := al_get_display_height(FHandle);

  al_identity_transform(@FTransform);
  al_use_transform(@FTransform);
  al_set_clipping_rectangle(0, 0, LDW, LDH);

  LDpi := al_get_monitor_dpi(al_get_new_display_adapter);
  LSX := MulDiv(Round(FWidth), LDPI, DISPLAY_DEFAULT_DPI);
  LSY := MulDiv(Round(FHeight), LDpi, DISPLAY_DEFAULT_DPI);

  LWX := (GetSystemMetrics(SM_CXFULLSCREEN) - LSX) div 2;
  LWY := (GetSystemMetrics(SM_CYFULLSCREEN) - LSY) div 2;
  al_set_window_position(FHandle, LWX, LWY);
  al_resize_display(FHandle, LSX, LSY);

  FScale := Min(LSX / FWidth, LSY / FHeight);
  al_set_clipping_rectangle(0, 0, LSX, LSY);
  al_build_transform(@FTransform, 0, 0, FScale, FScale, 0);
  al_use_transform(@FTransform);

  al_set_window_constraints(FHandle, LSX, LSY, LSX, LSY);
  al_apply_window_constraints(FHandle, True);
end;

constructor TWindow.Create;
begin
  inherited;
end;

destructor TWindow.Destroy;
begin
  Close;
  inherited;
end;

procedure TWindow.Open(aWidth, aHeight: Integer; const aTitle: string);
var
  LHandle: PALLEGRO_DISPLAY;
  LHWnd: HWND;
begin
  if Assigned(FHandle) then Exit;
  if al_get_num_video_adapters < 1 then Exit;
  al_set_new_display_adapter(0);
  al_set_new_display_flags(ALLEGRO_OPENGL_3_0 or ALLEGRO_RESIZABLE or ALLEGRO_PROGRAMMABLE_PIPELINE);
  al_set_new_display_option(ALLEGRO_COMPATIBLE_DISPLAY, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_VSYNC, 2, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_CAN_DRAW_INTO_BITMAP, 1, ALLEGRO_REQUIRE);
  al_set_new_display_option(ALLEGRO_SAMPLE_BUFFERS, 1, ALLEGRO_SUGGEST);
  al_set_new_display_option(ALLEGRO_SAMPLES, 8, ALLEGRO_SUGGEST);
  al_set_new_window_title(PAnsiChar(AnsiString(aTitle)));
  LHandle := al_create_display(aWidth, aHeight);
  if not Assigned(LHandle) then Exit;
  LHWnd := al_get_win_window_handle(FHandle);
  SetWindowLongPtrW(LHwnd, GWL_STYLE, GetWindowLongPtrW(LHWnd, GWL_STYLE) and (not WS_MAXIMIZEBOX));
  FHandle := LHandle;
  FHWnd := LHWnd;
  FWidth := aWidth;
  FHeight := aHeight;
  FScale := 1;
  FDpi := al_get_monitor_dpi(al_get_new_display_adapter);
  FRenderTarget := nil;
  al_register_event_source(SGT.Queue, al_get_display_event_source(FHandle));
  ScaleWindowToDPI;
end;

procedure TWindow.Close;
begin
  if not Assigned(FHandle) then Exit;
  if al_is_event_source_registered(SGT.Queue, al_get_display_event_source(FHandle)) then
    al_unregister_event_source(SGT.Queue, al_get_display_event_source(FHandle));
  al_destroy_display(FHandle);
  FHandle := nil;
end;

procedure TWindow.SetTitle(aTitle: string);
begin
  if not Assigned(FHandle) then Exit;
  al_set_window_title(FHandle, PAnsiChar(AnsiString(aTitle)));
end;

function  TWindow.IsOpen: Boolean;
begin
  Result := Assigned(FHandle);
end;

procedure TWindow.Clear(aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_clear_to_color(LColor);
end;

procedure TWindow.Show;
begin
  if not Assigned(FHandle) then Exit;
  al_flip_display;
end;

procedure TWindow.ResetTransform;
begin
  if not Assigned(FHandle) then Exit;
  al_use_transform(@FTransform);
end;

procedure TWindow.Save(const aFilename: string);
var
  LBackbuffer: PALLEGRO_BITMAP;
  LScreenshot: PALLEGRO_BITMAP;
  LVX, LVY, LVW, LVH: Integer;
  LFilename: string;
  LSize: TRectangle;
begin
  if not Assigned(FHandle) then Exit;

  // get viewport size
  GetViewportSize(LSize);
  LVX := Round(LSize.X);
  LVY := Round(LSize.Y);
  LVW := Round(LSize.Width*FScale);
  LVH := Round(LSize.Height*FScale);

  // create LScreenshot bitmpat
  al_set_new_bitmap_flags(ALLEGRO_MIN_LINEAR or ALLEGRO_MAG_LINEAR);
  LScreenshot := al_create_bitmap(LVW, LVH);

  // exit if failed to create LScreenshot bitmap
  if not Assigned(LScreenshot) then Exit;

  // get LBackbuffer
  LBackbuffer := al_get_backbuffer(FHandle);

  // set target to LScreenshot bitmap
  al_set_target_bitmap(LScreenshot);

  // draw viewport area of LBackbuffer to LScreenshot bitmap
  al_draw_bitmap_region(LBackbuffer, LVX, LVY, LVW, LVH, 0, 0, 0);

  // restore LBackbuffer target
  al_set_target_bitmap(LBackbuffer);

  // make sure filename is a PNG file
  LFilename := aFilename;
  LFilename := ChangeFileExt(LFilename, cPngExt);

  // save screen bitmap to PNG filename
  SGT.SetFileSandBoxed(False);
  if not al_save_bitmap(PAnsiChar(AnsiString(LFilename)), LScreenshot) then
  SGT.SetFileSandBoxed(True);

  // destroy LScreenshot bitmap
  al_destroy_bitmap(LScreenshot);
end;

procedure TWindow.GetViewportSize(var aSize: TRectangle);
begin
  if not Assigned(FRenderTarget) then
    aSize.Assign(0, 0, FWidth, FHeight)
  else
    FRenderTarget.GetSize(aSize);
end;

procedure  TWindow.SetRenderTarget(aRenderTarget: TRenderTarget);
begin
  FRenderTarget := aRenderTarget;
end;

procedure TWindow.SetTransformPos(aX: Single; aY: Single);
var
  LTransform: ALLEGRO_TRANSFORM;
begin
  if not Assigned(FHandle) then Exit;
   al_copy_transform(@LTransform,  al_get_current_transform);
   al_translate_transform(@LTransform, aX, aY);
   al_use_transform(@LTransform);
end;

// --- Blending -------------------------------------------------------------
procedure TWindow.SetBlender(aOperation: Integer; aSource: Integer; aDestination: Integer);
begin
  if not Assigned(FHandle) then Exit;
  al_set_blender(aOperation, aSource, aDestination);
end;

procedure TWindow.GetBlender(aOperation: PInteger; aSource: PInteger; aDestination: PInteger);
begin
  if not Assigned(FHandle) then Exit;
  al_get_blender(aOperation, aSource, aDestination);
end;

procedure TWindow.SetBlendColor(aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_set_blend_color(LColor);
end;

function  TWindow.GetBlendColor: TColor;
var
  LResult: ALLEGRO_COLOR absolute Result;
begin
  Result := BLANK;
  if not Assigned(FHandle) then Exit;
  LResult := al_get_blend_color;
end;

procedure TWindow.SetBlendMode(aMode: TBlendMode);
begin
  if not Assigned(FHandle) then Exit;
  case aMode of
    bmPreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
      end;
    bmNonPreMultipliedAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA);
      end;
    bmAdditiveAlpha:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ONE);
      end;
    bmCopySrcToDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_ZERO);
      end;
    bmMultiplySrcAndDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_DEST_COLOR, ALLEGRO_ZERO);
      end;
  end;
end;

procedure TWindow.SetBlendModeColor(aMode: TBlendModeColor; aColor: TColor);
begin
  if not Assigned(FHandle) then Exit;
  case aMode of
    bmcNormal:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_ONE);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
    bmcAvgSrcDest:
      begin
        al_set_blender(ALLEGRO_ADD, ALLEGRO_CONST_COLOR, ALLEGRO_CONST_COLOR);
        al_set_blend_color(al_map_rgba_f(aColor.red, aColor.green, aColor.blue, aColor.alpha));
      end;
  end;
end;

procedure TWindow.RestoreDefaultBlendMode;
begin
  if not Assigned(FHandle) then Exit;
  al_set_blender(ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);
  al_set_blend_color(al_map_rgba(255, 255, 255, 255));
end;

// --- Primitives -----------------------------------------------------------
procedure TWindow.DrawLine(aX1, aY1, aX2, aY2, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_line(aX1, aY1, aX2, aY2, LColor, aThickness);
end;

procedure TWindow.DrawRectangle(aX, aY, aWidth, aHeight, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_rectangle(aX, aY, aX + (aWidth-1), aY + (aHeight-1), LColor, aThickness);
end;

procedure TWindow.DrawFilledRectangle(aX, aY, aWidth, aHeight: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_filled_rectangle(aX, aY, aX + (aWidth-1), aY + (aHeight-1), LColor);
end;

procedure TWindow.DrawCircle(aX, aY, aRadius, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_circle(aX, aY, aRadius, LColor, aThickness);
end;

procedure TWindow.DrawFilledCircle(aX, aY, aRadius: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_filled_circle(aX, aY, aRadius, LColor);
end;

procedure TWindow.DrawTriangle(aX1, aY1, aX2, aY2, aX3, aY3, aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_triangle(aX1, aY1, aX2, aY2, aX3, aY3, LColor, aThickness);
end;

procedure TWindow.DrawFilledTriangle(aX1, aY1, aX2, aY2, aX3, aY3: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_filled_triangle(aX1, aY1, aX2, aY2, aX3, aY3, LColor);
end;

procedure TWindow.DrawPolygon(aVertices: System.PSingle; aVertexCount: Integer; aThickness: Single; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_polygon(aVertices, aVertexCount, ALLEGRO_LINE_JOIN_ROUND, LColor, aThickness, 1.0);
end;

procedure TWindow.DrawFilledPolygon(aVertices: System.PSingle; aVertexCount: Integer; aColor: TColor);
var
  LColor: ALLEGRO_COLOR absolute aColor;
begin
  if not Assigned(FHandle) then Exit;
  al_draw_filled_polygon(aVertices, aVertexCount, LColor);
end;

{ TJoystick }
procedure TJoystick.Setup(aNum: Integer);
var
  LJoyCount: Integer;
  LJoy: PALLEGRO_JOYSTICK;
  LJoyState: ALLEGRO_JOYSTICK_STATE;
  LI, LJ: Integer;
begin
  LJoyCount := al_get_num_joysticks;
  if (aNum < 0) or (aNum > LJoyCount - 1) then
    Exit;

  LJoy := al_get_joystick(aNum);
  if not Assigned(LJoy) then
  begin
    Sticks := 0;
    Buttons := 0;
    Exit;
  end;

  Name := string(al_get_joystick_name(LJoy));

  al_get_joystick_state(LJoy, @LJoyState);

  Sticks := al_get_joystick_num_sticks(LJoy);
  if (Sticks > MAX_STICKS) then
    Sticks := MAX_STICKS;

  for LI := 0 to Sticks - 1 do
  begin
    StickName[LI] := string(al_get_joystick_stick_name(LJoy, LI));
    Axes[LI] := al_get_joystick_num_axes(LJoy, LI);
    for LJ := 0 to Axes[LI] - 1 do
    begin
      Pos[LI, LJ] := LJoyState.stick[LI].axis[LJ];
      AxesName[LI, LJ] := string(al_get_joystick_axis_name(LJoy, LI, LJ));
    end;
  end;

  Buttons := al_get_joystick_num_buttons(LJoy);
  if (Buttons > MAX_BUTTONS) then
    Buttons := MAX_BUTTONS;

  for LI := 0 to Buttons - 1 do
  begin
    ButtonName[LI] := string(al_get_joystick_button_name(LJoy, LI));
    Button[0, LI] := Boolean(LJoyState.Button[LI] >= 16384);
  end
end;

function TJoystick.GetPos(aStick: Integer; aAxes: Integer): Single;
begin
  Result := Pos[aStick, aAxes];
end;

function TJoystick.GetButton(aButton: Integer): Boolean;
begin
  Result := Button[0, aButton];
end;

procedure TJoystick.Clear;
begin
  FillChar(Button, SizeOf(Button), False);
  FillChar(Pos, SizeOf(Pos), 0);
end;

{ TInput }
constructor TInput.Create;
begin
  inherited;
  Clear;
  FJoyStick.Setup(0);
end;

destructor TInput.Destroy;
begin
  inherited;
end;

procedure TInput.Clear;
begin
  FKeyCode := 0;
  FKeyCodeRepeat := False;
  FillChar(FMouseButtons, SizeOf(FMouseButtons), False);
  FillChar(FKeyButtons, SizeOf(FKeyButtons), False);
  FJoystick.Clear;

  if Assigned(SGT.Window.Handle) then
  begin
    al_clear_keyboard_state(SGT.Window.Handle);
  end;
end;

procedure TInput.Update;
begin
  FKeyCode := 0;

  case SGT.Event.type_ of
    ALLEGRO_EVENT_KEY_CHAR:
    begin
      FKeyCode := SGT.Event.keyboard.unichar;
      FKeyCodeRepeat := SGT.Event.keyboard.repeat_;
    end;

    ALLEGRO_EVENT_JOYSTICK_AXIS:
    begin
      if (SGT.Event.Joystick.stick < MAX_STICKS) and
        (SGT.Event.Joystick.axis < MAX_AXES) then
      begin
        FJoystick.Pos[SGT.Event.Joystick.stick][SGT.Event.Joystick.axis] :=
          SGT.Event.Joystick.Pos;
      end;
    end;

    ALLEGRO_EVENT_KEY_DOWN:
    begin
      FKeyButtons[0, SGT.Event.keyboard.keycode] := True;
    end;

    ALLEGRO_EVENT_KEY_UP:
    begin
      FKeyButtons[0, SGT.Event.keyboard.keycode] := False;
    end;

    ALLEGRO_EVENT_MOUSE_BUTTON_DOWN:
    begin
      FMouseButtons[0, SGT.Event.mouse.button] := True;
    end;

    ALLEGRO_EVENT_MOUSE_BUTTON_UP:
    begin
      FMouseButtons[0, SGT.Event.mouse.button] := False;
    end;

    ALLEGRO_EVENT_MOUSE_AXES:
    begin
      FMouse.Postion.X := Round(SGT.Event.mouse.x / SGT.Window.Scale);
      FMouse.Postion.Y := Round(SGT.Event.mouse.y / SGT.Window.Scale);
      FMouse.Postion.Z := SGT.Event.mouse.z;
      FMouse.Postion.W := SGT.Event.mouse.w;

      FMouse.Delta.X := SGT.Event.mouse.dx;
      FMouse.Delta.Y := SGT.Event.mouse.dy;
      FMouse.Delta.Z := SGT.Event.mouse.dz;
      FMouse.Delta.W := SGT.Event.mouse.dw;

      FMouse.Pressure := SGT.Event.mouse.pressure;
    end;

    ALLEGRO_EVENT_JOYSTICK_BUTTON_DOWN:
    begin
      FJoystick.Button[0, SGT.Event.Joystick.Button] := True;
    end;

    ALLEGRO_EVENT_JOYSTICK_BUTTON_UP:
    begin
      FJoystick.Button[0, SGT.Event.Joystick.Button] := False;
    end;

    ALLEGRO_EVENT_JOYSTICK_CONFIGURATION:
    begin
      al_reconfigure_joysticks;
      FJoystick.Setup(0);
    end;
  end;
end;
function  TInput.KeyDown(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then  Exit;
  Result := FKeyButtons[0, aKey];
end;

function  TInput.KeyPressed(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then  Exit;
  if KeyDown(aKey) and (not FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := True;
    Result := True;
  end
  else if (not KeyDown(aKey)) and (FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := False;
    Result := False;
  end;
end;

function  TInput.KeyReleased(aKey: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aKey, 0, 255) then Exit;
  if KeyDown(aKey) and (not FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := True;
    Result := False;
  end
  else if (not KeyDown(aKey)) and (FKeyButtons[1, aKey]) then
  begin
    FKeyButtons[1, aKey] := False;
    Result := True;
  end;
end;

function  TInput.MouseDown(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;
  Result := FMouseButtons[0, aButton];
end;

function  TInput.MousePressed(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := True;
    Result := True;
  end
  else if (not MouseDown(aButton)) and (FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := False;
    Result := False;
  end;
end;

function  TInput.MouseReleased(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, MOUSE_BUTTON_LEFT, MOUSE_BUTTON_MIDDLE) then Exit;

  if MouseDown(aButton) and (not FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := True;
    Result := False;
  end
  else if (not MouseDown(aButton)) and (FMouseButtons[1, aButton]) then
  begin
    FMouseButtons[1, aButton] := False;
    Result := True;
  end;
end;

procedure TInput.MouseSetPos(aX: Integer; aY: Integer);
var
  LX, LY: Integer;
begin
  LX := Round(aX * SGT.Window.Scale);
  LY := Round(aY * SGT.Window.Scale);
  al_set_mouse_xy(SGT.Window.Handle, LX, LY);
end;

procedure TInput.GetMouseInfo(aPosition: PVector; aDelta: PVector; aPressure: System.PSingle);
begin
  if Assigned(aPosition) then
    aPosition^ := FMouse.Postion;
  if Assigned(aDelta) then
    aDelta^ := FMouse.Delta;
  if Assigned(aPressure) then
    aPressure^ := FMouse.Pressure;
end;

function  TInput.JoystickDown(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;
  Result := FJoystick.Button[0, aButton];
end;

function  TInput.JoystickPressed(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;

  if JoystickDown(aButton) and (not FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := True;
    Result := True;
  end
  else if (not JoystickDown(aButton)) and (FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := False;
    Result := False;
  end;
end;

function  TInput.JoystickReleased(aButton: Cardinal): Boolean;
begin
  Result := False;
  if not InRange(aButton, 0, MAX_BUTTONS-1) then Exit;

  if JoystickDown(aButton) and (not FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := True;
    Result := False;
  end
  else if (not JoystickDown(aButton)) and (FJoystick.Button[1, aButton]) then
  begin
    FJoystick.Button[1, aButton] := False;
    Result := True;
  end;
end;

function  TInput.JoystickPosition(aStick: Integer; aAxes: Integer): Single;
begin
  Result := 0;
  if not InRange(aStick, 0, MAX_STICKS-1) then Exit;
  if not InRange(aAxes, 0, MAX_AXES-1) then Exit;
  Result := FJoystick.Pos[aStick, aAxes];
end;

{$ENDREGION}

{$REGION 'Spark.Audio'}
{ TAudio }
constructor TAudio.Create;
begin
  inherited;
end;

destructor TAudio.Destroy;
begin
  inherited;
end;

procedure TAudio.Pause(aPause: Boolean);
begin
  if not al_is_audio_installed then Exit;
  al_set_mixer_playing(SGT.Mixer, not aPause);
end;

procedure TAudio.Clear;
begin
  UnloadMusic;
  StopAllSamples;
end;

procedure TAudio.LoadMusic(aArchive: TArchive; const aFilename: string);
var
  LSandBoxed: Boolean;
  LFilename: string;
  LHandle: PALLEGRO_AUDIO_STREAM;
begin
  if not al_is_audio_installed then Exit;
  if aFilename = '' then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not FileExist(aFilename) then Exit;
      LFilename := aFilename;
    end;

  LSandBoxed := SGT.GetFileSandBoxed;
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
  LHandle := al_load_audio_stream(PAnsiChar(AnsiString(LFilename)), 4, 2048);
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);
  if not Assigned(LHandle) then
  begin
    SGT.Log.Add('Failed to load music file: #s', [aFilename]);
    Exit;
  end;

  UnloadMusic;
  al_set_audio_stream_playmode(LHandle, ALLEGRO_PLAYMODE_ONCE);
  al_attach_audio_stream_to_mixer(LHandle, SGT.Mixer);
  al_set_audio_stream_playing(LHandle, False);
  FMusic := LHandle;
  FMusicFilename := aFilename;
  SGT.Log.Add('Loaded music file: #s', [aFilename]);
end;

procedure TAudio.UnloadMusic;
begin
  if not al_is_audio_installed then Exit;
  if Assigned(FMusic) then
  begin
    al_set_audio_stream_playing(FMusic, False);
    al_drain_audio_stream(FMusic);
    al_detach_audio_stream(FMusic);
    al_destroy_audio_stream(FMusic);
    SGT.Log.Add('Unloaded music file: #s', [FMusicFilename]);
    FMusic := nil;
    FMusicFilename := '';
  end;
end;

procedure TAudio.PlayMusic(aVolume: Single; aLoop: Boolean);
begin
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;
  StopMusic;
  SetMusicLooping(aLoop);
  SetMusicVolume(aVolume);
  al_rewind_audio_stream(FMusic);
  SetMusicPlaying(True);
end;

procedure TAudio.PlayMusic(aArchive: TArchive; const aFilename: string; aVolume: Single; aLoop: Boolean);
begin
  if not al_is_audio_installed then Exit;
  LoadMusic(aArchive, aFilename);
  PlayMusic(aVolume, aLoop);
end;

procedure TAudio.StopMusic;
begin
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;
  al_set_audio_stream_playing(FMusic, False);
  al_rewind_audio_stream(FMusic);
end;

function  TAudio.GetMusicLooping: Boolean;
var
  LMode: ALLEGRO_PLAYMODE;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;

  LMode := al_get_audio_stream_playmode(FMusic);
  if (LMode = ALLEGRO_PLAYMODE_LOOP) or
     (LMode = _ALLEGRO_PLAYMODE_STREAM_ONEDIR) then
  begin
    Result := True;
  end;
end;

procedure TAudio.SetMusicLooping(aLoop: Boolean);
var
  LMode: ALLEGRO_PLAYMODE;
begin
  if not al_is_audio_installed then Exit;
  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;
  al_set_audio_stream_playmode(FMusic, LMode);
end;

function  TAudio.GetMusicPlaying: Boolean;
begin
  Result := False;
  if not al_is_audio_installed then Exit;
  Result := al_get_audio_stream_playing(FMusic);
end;

procedure TAudio.SetMusicPlaying(aPlay: Boolean);
begin
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;
  al_set_audio_stream_playing(FMusic, aPlay);
end;

procedure TAudio.SetMusicVolume(aVolume: Single);
begin
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;
  al_set_audio_stream_gain(FMusic, aVolume);
end;

function  TAudio.GetMusicVolume: Single;
begin
  Result := 0;
  if not al_is_audio_installed then Exit;
  if not Assigned(FMusic) then Exit;
  Result := al_get_audio_stream_gain(FMusic);
end;

procedure TAudio.SeekMusic(aTime: Single);
begin
  if not Assigned(FMusic) then Exit;
  if not al_is_audio_installed then Exit;
  al_seek_audio_stream_secs(FMusic, aTime);
end;

procedure TAudio.RewindMusic(aTime: Single);
begin
  if not Assigned(FMusic) then Exit;
  if not al_is_audio_installed then Exit;
  al_rewind_audio_stream(FMusic);
end;

function  TAudio.ReserveSampleChannels(aCount: Integer): Boolean;
begin
  Result := al_reserve_samples(aCount);
end;

function  TAudio.LoadSample(aArchive: TArchive; const aFilename: string): TSample;
var
  LSandBoxed: Boolean;
  LFilename: string;
  LSample: TSample;
begin
  Result := nil;
  if not al_is_audio_installed then Exit;
  if aFilename = '' then Exit;

  if Assigned(aArchive) then
    begin
      if not aArchive.IsOpen then Exit;
      if not aArchive.FileInside(aFilename) then Exit;
      LFilename := string(aArchive.GetPasswordFilename(aFilename));
    end
  else
    begin
      if not FileExist(aFilename) then Exit;
      LFilename := aFilename;
    end;

  LSandBoxed := SGT.GetFileSandBoxed;
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(False);
  LSample := al_load_sample(PAnsiChar(AnsiString(LFilename)));
  if not Assigned(aArchive) then SGT.SetFileSandBoxed(LSandBoxed);
  if not Assigned(LSample) then
  begin
    SGT.Log.Add('Failed to load sample file: #s', [aFilename]);
    Exit;
  end;
  Result := LSample;
  SGT.Log.Add('Loaded sample file: #s', [aFilename]);
end;

procedure TAudio.UnloadSample(var aSample: TSample);
begin
  if not al_is_audio_installed then Exit;
  al_destroy_sample(aSample);
  aSample := nil;
end;

procedure TAudio.PlaySample(aSample: TSample; aVolume: Single; aPan: Single; aSpeed: Single; aLoop: Boolean; aId: PSampleID);
var
  LMode: ALLEGRO_PLAYMODE;
  LID: ALLEGRO_SAMPLE_ID;
begin
  if not Assigned(aSample) then Exit;

  if Assigned(aId) then
  begin
    aId.Index := -1;
    aId.Id := -1;
  end;

  if aLoop then
    LMode := ALLEGRO_PLAYMODE_LOOP
  else
    LMode := ALLEGRO_PLAYMODE_ONCE;

  if al_play_sample(aSample, aVolume, aPan, aSpeed, LMode, @LID) then
  begin
    if Assigned(aId) then
    begin
      aId.Index := LID._index;
      aId.Id := LID._id;
    end;
  end;
end;

procedure TAudio.StopSample(aID: TSampleID);
var
  LID: ALLEGRO_SAMPLE_ID;
begin
  if GetSamplePlaying(aID) then
  begin
    LID._index := aID.Index;
    LID._id := aID.Id;
    al_stop_sample(@LID);
  end;
end;

procedure TAudio.StopAllSamples;
begin
  al_stop_samples;
end;

function  TAudio.GetSamplePlaying(aID: TSampleID): Boolean;
var
  LInstance: PALLEGRO_SAMPLE_INSTANCE;
  LID: ALLEGRO_SAMPLE_ID;
begin
  Result := False;
  LID._index := aID.Index;
  LID._id := aID.Id;
  LInstance := al_lock_sample_id(@LID);
  if Assigned(LInstance) then
  begin
    Result := al_get_sample_instance_playing(LInstance);
    al_unlock_sample_id(@LID);
  end;
end;


{$ENDREGION}

{$REGION 'Spark.Game'}
procedure RunGame(aGame: TCustomGameClass);
var
  LGame: TCustomGame;
begin
  if Assigned(SGT) then Exit;
  SGT := TSGT.Create;
  LGame := aGame.Create;
  LGame.OnInit;
  LGame.OnRun;
  LGame.OnDone;
  LGame.Free;
  FreeNilObject(SGT);
end;

constructor TCustomGame.Create;
begin
  inherited;
end;

destructor TCustomGame.Destroy;
begin
  inherited;
end;

procedure TCustomGame.OnInit;
begin
end;

procedure TCustomGame.OnDone;
begin
end;

procedure TCustomGame.OnRun;
begin
end;

{ TGame }
constructor TGame.Create;
begin
  inherited;
  Game := Self;
  ResetTiming(60.0, 1.0);
end;

destructor TGame.Destroy;
begin
  Game := nil;
  inherited;
end;

procedure TGame.OnInit;
begin
  inherited;
end;

procedure TGame.OnDone;
begin
  inherited;
end;

procedure TGame.OnStartup;
begin
  inherited;
end;

procedure TGame.OnShutdown;
begin
  inherited;
end;

procedure TGame.OnSetSettings(var aSettings: TGameSettings);
begin
  // Window
  aSettings.WindowWidth := 960;
  aSettings.WindowHeight := 540;
  aSettings.WindowTitle := 'Spark Game Toolkit';
  aSettings.WindowClearColor := DARKSLATEBROWN;

  // ConfigFile
  aSettings.ConfigFilename := '';

  // Archive
  aSettings.ArchivePassword := '';
  aSettings.ArchiveFilename := '';

  // Font
  aSettings.FontSize := 16;
  aSettings.FontFilename := '';

  // Hud
  aSettings.HudTextItemPadWidth := 10;
  aSettings.HudPosX := 3;
  aSettings.HudPosY := 3;
  aSettings.HudLineSpace := 0;
end;

procedure TGame.OnApplySettings;
begin
  // ConfigFile
  FConfigFile := TConfigFile.Create;
  FConfigFile.Open(FSettings.ConfigFilename);

  // Window
  SGT.Window.Open(FSettings.WindowWidth, FSettings.WindowHeight, FSettings.WindowTitle);

  // Archive
  FArchive := TArchive.Create;
  if FileExist(FSettings.ArchiveFilename) then
  begin
    FArchive.Open(FSettings.ArchivePassword, FSettings.ArchiveFilename);
  end;

  // Font
  FFont := TFont.Create;
  if FArchive.IsOpen and (FSettings.FontFilename <> '') then
    FFont.Load(FArchive, FSettings.FontSize, FSettings.FontFilename)
  else
    if FileExist(FSettings.FontFilename) then
      FFont.Load(nil, FSettings.FontSize, FSettings.FontFilename)
    else
      FFont.LoadDefault(FSettings.FontSize);

  // Hud
  SetHudPos(FSettings.HudPosX, FSettings.HudPosY);
  SetHudLineSpace(FSettings.HudLineSpace);
  SetHudTextItemPadWidth(FSettings.HudTextItemPadWidth);
end;

procedure TGame.OnUnapplySettings;
begin
  FreeNilObject(FFont);
  FreeNilObject(FArchive);
  SGT.Window.Close;;
  FreeNilObject(FConfigFile);
end;

procedure TGame.OnRun;
var
  LCurrentTransform: ALLEGRO_TRANSFORM;
begin
  inherited;

  SGT.Log.Add('Entering game loop', []);

  SGT.Log.Add('Get settings...', []);
  OnSetSettings(FSettings);

  SGT.Log.Add('Apply settings...', []);
  OnApplySettings;

  SGT.Log.Add('Starting up...', []);
  OnStartup;

  SGT.Input.Clear;
  SGT.CmdConsole.Open;
  FTerminate := False;
  FReady := True;

  SGT.Log.Add('Processing gameloop...', []);

  while not FTerminate do
  begin
    repeat
      Sleep(0);
      ProcessMessages;
      if al_get_next_event(SGT.Queue, @SGT.Event) then
      begin

        case SGT.Event.type_ of
          EVENT_CMDCON_ACTIVE:
          begin
            SGT.Audio.Pause(True);
            SGT.Video.SetPause(True);
            OnCmdConsoleState(ccOpen);
          end;

          EVENT_CMDCON_INACTIVE:
          begin
            SGT.Audio.Pause(False);
            SGT.Video.SetPause(False);
            OnCmdConsoleState(ccClose);
          end;

          ALLEGRO_EVENT_DISPLAY_CLOSE:
          begin
            FTerminate := True;
          end;

          ALLEGRO_EVENT_DISPLAY_RESIZE:
          begin
          end;

          ALLEGRO_EVENT_DISPLAY_DISCONNECTED,
          ALLEGRO_EVENT_DISPLAY_HALT_DRAWING,
          ALLEGRO_EVENT_DISPLAY_LOST,
          ALLEGRO_EVENT_DISPLAY_SWITCH_OUT:
          begin
            if not SGT.CmdConsole.GetActive then
            begin
              if SGT.Event.type_ = ALLEGRO_EVENT_DISPLAY_SWITCH_OUT then SGT.Input.Clear;;
              SGT.Audio.Pause(True);
              SGT.Video.SetPause(True);
              FReady := False;
              OnReady(FReady);
            end;
          end;

          ALLEGRO_EVENT_DISPLAY_CONNECTED,
          ALLEGRO_EVENT_DISPLAY_RESUME_DRAWING,
          ALLEGRO_EVENT_DISPLAY_FOUND,
          ALLEGRO_EVENT_DISPLAY_SWITCH_IN:
          begin
            if not SGT.CmdConsole.GetActive then
            begin
              ResetTiming;
              SGT.Audio.Pause(False);
              SGT.Video.SetPause(False);
              FReady := True;
              OnReady(FReady);
            end;
          end;

          ALLEGRO_EVENT_VIDEO_FINISHED:
          begin
            SGT.Video.OnFinished(PALLEGRO_VIDEO(SGT.Event.user.data1));
          end;
        end;

        SGT.Input.Update;
        SGT.Input.GetMouseInfo(@FMousePos, @FMouseDelta, @FMousePressure);
      end;

    until  al_is_event_queue_empty(SGT.Queue);

    if FReady then
      begin
        //Async.Process;
        UpdateTiming;
        OnClearWindow;
        OnRender;
        LCurrentTransform := al_get_current_transform^;
        SGT.Window.ResetTransform;
        OnRenderHUD;
        SGT.CmdConsole.Render;
        al_use_transform(@LCurrentTransform);
        SGT.Screenshot.Process;
        OnPreShowWindow;
        OnShowWindow;
        OnPostShowWindow;
      end
    else
      begin
        Sleep(1);
      end;
  end;

  SGT.CmdConsole.Close;

  SGT.Log.Add('Shutting down...', []);
  OnShutdown;

  SGT.Log.Add('Unapply settings...', []);
  OnUnapplySettings;

  SGT.Log.Add('Exting game loop', []);
end;

procedure TGame.OnReady(aReady: Boolean);
begin
end;

procedure TGame.OnUpdate(aDeltaTime: Double);
begin
  if SGT.Input.KeyPressed(KEY_ESCAPE) then
    Terminate := True;
end;

procedure TGame.OnFixedUpdate;
begin
end;

procedure TGame.OnClearWindow;
begin
  SGT.Window.Clear(FSettings.WindowClearColor);
end;

procedure TGame.OnShowWindow;
begin
  SGT.Window.Show;
end;

procedure TGame.OnRender;
begin
end;

procedure TGame.OnRenderHUD;
begin
  ResetHudPos;
  HudText(FFont, WHITE, haLeft, 'fps #I', [GetFrameRate]);
  HudText(FFont, GREEN, haLeft, HudTextItem('ESC', 'Quit'), []);
end;

procedure TGame.OnPreShowWindow;
begin
end;

procedure TGame.OnPostShowWindow;
begin
end;

procedure TGame.OnCmdConsoleState(aState: TCmdConsoleState);
begin
end;

procedure TGame.OnVideoState(aState: TVideoState; aFilename: string);
begin
end;

procedure TGame.OnScreenshot(const aFilename: string);
begin
end;

procedure TGame.UpdateTiming;
begin
  FTimer.LNow := GetTime;
  FTimer.Passed := FTimer.LNow - FTimer.Last;
  FTimer.Last := FTimer.LNow;

  // process framerate
  Inc(FTimer.FrameCount);
  FTimer.FrameAccumulator := FTimer.FrameAccumulator + FTimer.Passed + EPSILON;
  if FTimer.FrameAccumulator >= 1 then
  begin
    FTimer.FrameAccumulator := 0;
    FTimer.FrameRate := FTimer.FrameCount;
    FTimer.FrameCount := 0;
  end;

  // process variable update
  FTimer.Accumulator := FTimer.Accumulator + FTimer.Passed;
  while (FTimer.Accumulator >= FTimer.DeltaTime) do
  begin
    // update only if command console is not active
    if not SGT.CmdConsole.GetActive then
    begin
      // process screen shakes
      SGT.Screenshake.Process(FTimer.UpdateSpeed, FTimer.DeltaTime);

      // call herited update frame
      OnUpdate(FTimer.DeltaTime);

      // call herited fixed update frame
      if FrameSpeed(FTimer.FixedUpdateTimer, FTimer.FixedUpdateSpeed) then OnFixedUpdate;
    end;

    // update command console
    SGT.CmdConsole.Update(FTimer.DeltaTime);

    // update accumulator
    FTimer.Accumulator := FTimer.Accumulator - FTimer.DeltaTime;
  end;
end;

function  TGame.GetTime: Double;
begin
  Result := al_get_time;
end;

procedure TGame.ResetTiming(aSpeed: Single; aFixedSpeed: Single);
begin
  FTimer.LNow := 0;
  FTimer.Passed := 0;
  FTimer.Last := 0;

  FTimer.Accumulator := 0;
  FTimer.FrameAccumulator := 0;

  FTimer.DeltaTime := 0;

  FTimer.FrameCount := 0;
  FTimer.FrameRate := 0;

  if aSpeed > 0 then
    SetUpdateSpeed(aSpeed)
  else
    SetUpdateSpeed(FTimer.UpdateSpeed);

  if aFixedSpeed > 0 then
    SetFixedUpdateSpeed(aFixedSpeed)
  else
    SetFixedUpdateSpeed(FTimer.FixedUpdateSpeed);

  FTimer.Last := GetTime;
end;

procedure TGame.SetUpdateSpeed(aSpeed: Single);
begin
  FTimer.UpdateSpeed := aSpeed;
  FTimer.DeltaTime := 1.0 / FTimer.UpdateSpeed;
end;

function  TGame.GetUpdateSpeed: Single;
begin
   Result := FTimer.UpdateSpeed;
end;

procedure TGame.SetFixedUpdateSpeed(aSpeed: Single);
begin
  FTimer.FixedUpdateSpeed := aSpeed;
  FTimer.FixedUpdateTimer := 0;
end;

function  TGame.GetFixedUpdateSpeed: Single;
begin
  Result := FTimer.FixedUpdateSpeed;
end;

function  TGame.GetDeltaTime: Double;
begin
  Result := FTimer.DeltaTime;
end;

function  TGame.GetFrameRate: Cardinal;
begin
  Result := FTimer.FrameRate;
end;

function  TGame.FrameSpeed(var aTimer: Single; aSpeed: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + (aSpeed / FTimer.UpdateSpeed);
  if aTimer >= 1.0 then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

function  TGame.FrameElapsed(var aTimer: Single; aFrames: Single): Boolean;
begin
  Result := False;
  aTimer := aTimer + FTimer.DeltaTime;
  if aTimer > aFrames then
  begin
    aTimer := 0;
    Result := True;
  end;
end;

procedure TGame.ResetHudPos;
begin
  SetHudPos(FSettings.HudPosX, FSettings.HudPosY);
end;

procedure TGame.SetHudPos(aX: Integer; aY: Integer);
begin
  FHud.Pos.Assign(aX, aY);
end;

procedure TGame.SetHudLineSpace(aLineSpace: Integer);
begin
  FHud.Pos.Z := aLineSpace;
end;

procedure TGame.SetHudTextItemPadWidth(aWidth: Integer);
begin
  FHud.TextItemPadWidth := aWidth;
end;

procedure TGame.HudText(aFont: TFont; aColor: TColor; aAlign: THAlign; const aMsg: string; const aArgs: array of const);
begin
  aFont.PrintText(FHud.Pos.X, FHud.Pos.Y, FHud.Pos.Z, aColor, aAlign, aMsg, aArgs);
end;

function  TGame.HudTextItem(const aKey: string; const aValue: string; const aSeperator: string='-'): string;
begin
  Result := FormatStr('#S #S #S', [PadRightStr(aKey, FHud.TextItemPadWidth, ' '), aSeperator, aValue]);
end;

{$ENDREGION}

{$REGION 'Spark.Core'}
{$R Spark.res}

{ TSGT }
procedure TSGT.Startup;
var
  LOk: Boolean;
begin
  if al_is_system_installed then Exit;

  // init allegro
  LOk := al_install_system(ALLEGRO_VERSION_INT, nil);
  if LOk then SGT.Log.Add('Initialized Allegro v#s', [ALLEGRO_VERSION_STR]) else SGT.Log.Add('Failed to initialize Allegro', []);

  // init devices
  LOk := al_install_joystick;
  if LOk then SGT.Log.Add('Initialized Allegro joystick support', []) else SGT.Log.Add('Failed to initialize Allegro joystick support', []);

  LOk := al_install_keyboard;
  if LOk then SGT.Log.Add('Initialized Allegro keyboard support', []) else SGT.Log.Add('Failed to initialize Allegro keyboard', []);

  LOk := al_install_mouse;
  if LOk then SGT.Log.Add('Initialized Allegro mouse support', []) else SGT.Log.Add('Failed to initialize Allegro mouse support', []);

  LOk := al_install_touch_input;
  if LOk then SGT.Log.Add('Initialized Allegro touch input', []) else SGT.Log.Add('Failed to initialize Allegro touch input support', []);

  LOk := al_install_audio;
  if LOk then SGT.Log.Add('Initialized Allegro audio support', []) else SGT.Log.Add('Failed to initialize Allegro audio support', []);

  // init addons
  LOk := al_init_acodec_addon;
  if LOk then SGT.Log.Add('Initialized Allegro audio codecs', []) else SGT.Log.Add('Failed to initialize Allegro audio codecs', []);

  LOk := al_init_font_addon;
  if LOk then SGT.Log.Add('Initialized Allegro font support', []) else SGT.Log.Add('Failed to initialize Allegro font support', []);

  LOk := al_init_image_addon;
  if LOk then SGT.Log.Add('Initialized Allegro image support', []) else SGT.Log.Add('Failed to initialize Allegro image support', []);

  LOk := al_init_native_dialog_addon;
  if LOk then SGT.Log.Add('Initialized Allegro native dialog support', []) else SGT.Log.Add('Failed to initialize Allegro native dialog support', []);

  LOk := al_init_primitives_addon;
  if LOk then SGT.Log.Add('Initialized Allegro primitives', []) else SGT.Log.Add('Failed to initialize Allegro primitives', []);

  LOk := al_init_ttf_addon;
  if LOk then SGT.Log.Add('Initialized Allegro ttf support', []) else SGT.Log.Add('Failed to initialize Allegro ttf support', []);

  LOk := al_init_video_addon;
  if LOk then SGT.Log.Add('Initialized Allegro video support', []) else SGT.Log.Add('Failed to initialize Allegro video support', []);

  // int user event source
  al_init_user_event_source(@FUserEventSrc);

  // init event queues
  FQueue := al_create_event_queue;
  al_register_event_source(FQueue, al_get_joystick_event_source);
  al_register_event_source(FQueue, al_get_keyboard_event_source);
  al_register_event_source(FQueue, al_get_mouse_event_source);
  al_register_event_source(FQueue, al_get_touch_input_event_source);
  al_register_event_source(FQueue, al_get_touch_input_mouse_emulation_event_source);
  al_register_event_source(FQueue , @FUserEventSrc);
  SGT.Log.Add('Initialized Allegro event queues', []);

  FCmdConActive.type_ := EVENT_CMDCON_ACTIVE;
  FCmdConInactive.type_ := EVENT_CMDCON_INACTIVE;

  // init audio
  if al_is_audio_installed then
  begin
    FVoice := al_create_voice(44100, ALLEGRO_AUDIO_DEPTH_INT16,  ALLEGRO_CHANNEL_CONF_2);
    FMixer := al_create_mixer(44100, ALLEGRO_AUDIO_DEPTH_FLOAT32,  ALLEGRO_CHANNEL_CONF_2);
    al_set_default_mixer(FMixer);
    al_attach_mixer_to_voice(FMixer, FVoice);
    al_reserve_samples(AUDIO_CHANNEL_COUNT);
    SGT.Log.Add('Setup Allegro audio', []);
  end;

  // init physfs
  FFileInterface[False] := al_get_new_file_interface;
  al_store_state(@FFileState[False], ALLEGRO_STATE_NEW_FILE_INTERFACE);
  LOk := Boolean(PHYSFS_init(nil) <> 0);
  if LOk then SGT.Log.Add('Initialized Allegro PHYSFS support', []) else SGT.Log.Add('Failed to initialize Allegro PHYSFS support', []);

  al_set_physfs_file_interface;
  FFileInterface[True] := al_get_new_file_interface;
  al_store_state(@FFileState[True], ALLEGRO_STATE_NEW_FILE_INTERFACE);
end;

procedure TSGT.Shutdown;
var
  LOk: Boolean;
begin
  if not al_is_system_installed then Exit;

  // shutdown physfs
  al_set_standard_file_interface;
  LOk :=  Boolean(PHYSFS_deinit <> 0);
  if LOk then SGT.Log.Add('Shutdown Allegro PHYSFS support', []) else SGT.Log.Add('Failed to shutdown Allegro PHYSFS support', []);

  // shutdown audio
  if al_is_audio_installed then
  begin
    al_stop_samples;
    al_detach_mixer(FMixer);
    al_destroy_mixer(FMixer);
    al_destroy_voice(FVoice);
    al_uninstall_audio;
    SGT.Log.Add('Shutdown Allegro audio support', []);
  end;

  // shutdown event queues
  al_destroy_event_queue(FQueue);
  SGT.Log.Add('Shutdown Allegro event queues', []);

  // shutdown addon
  if al_is_video_addon_initialized then
  begin
    al_shutdown_video_addon;
    SGT.Log.Add('Shutdown Allegro video addon', []);
  end;

  if al_is_ttf_addon_initialized then
  begin
    al_shutdown_ttf_addon;
    SGT.Log.Add('Shutdown Allegro ttf addon', []);
  end;

  if al_is_primitives_addon_initialized then
  begin
    al_shutdown_primitives_addon;
    SGT.Log.Add('Shutdown Allegro primitives addon', []);
  end;

  if al_is_native_dialog_addon_initialized then
  begin
    al_shutdown_native_dialog_addon;
    SGT.Log.Add('Shutdown Allegro native dialog addon', []);
  end;

  if al_is_image_addon_initialized then
  begin
    al_shutdown_image_addon;
    SGT.Log.Add('Shutdown Allegro image addon', []);
  end;

  if al_is_font_addon_initialized then
  begin
    al_shutdown_font_addon;
    SGT.Log.Add('Shutdown Allegro font addon', []);
  end;

  if al_is_acodec_addon_initialized then
  begin
    //
    SGT.Log.Add('Shutdown Allegro acodec addon', []);
  end;

  // shutdown devices
  if al_is_touch_input_installed then
  begin
    al_uninstall_touch_input;
    SGT.Log.Add('Uinstalled Allegro touch input support', []);
  end;

  if al_is_mouse_installed then
  begin
    al_uninstall_mouse;
    SGT.Log.Add('Uinstalled Allegro mouse support', []);
  end;

  if al_is_keyboard_installed then
  begin
    al_uninstall_keyboard;
    SGT.Log.Add('Uinstalled Allegro keyboard support', []);
  end;

  if al_is_joystick_installed then
  begin
    al_uninstall_joystick;
    SGT.Log.Add('Uinstalled Allegro joystick support', []);
  end;

  if al_is_system_installed then
  begin
    al_uninstall_system;
    SGT.Log.Add('Uinstalled Allegro', []);
  end;
end;

constructor TSGT.Create;
begin
  inherited;
  SGT := Self;
  FCodePage := GetConsoleOutputCP;
  SetConsoleOutputCP(CP_UTF8);
  FLog := TLog.Create;
  FLog.Add('Starting up Spark Game Toolkit v#s', [SPARK_VERSION]);
  Startup;
  FWindow := TWindow.Create;
  FInput := TInput.Create;
  FCmdConsole := TCmdConsole.Create;
  FAudio := TAudio.Create;
  FVideo := TVideo.Create;
  FScreenshake := TScreenshake.Create;
  FScreenshot := TScreenshot.Create;
  FLog.Add('Spark Game Toolkit ready!', [SPARK_VERSION]);
end;

destructor TSGT.Destroy;
begin
  FreeNilObject(FScreenshot);
  FreeNilObject(FScreenshake);
  FreeNilObject(FVideo);
  FreeNilObject(FAudio);
  FreeNilObject(FCmdConsole);
  FreeNilObject(FInput);
  FreeNilObject(FWindow);
  Shutdown;
  FLog.Add('Shutdown Spark Game Toolkit', []);
  FreeNilObject(FLog);
  SetConsoleOutputCP(FCodePage);
  SGT := nil;
  inherited;
end;

procedure TSGT.SetFileSandBoxed(aEnable: Boolean);
begin
  al_restore_state(@FFileState[aEnable]);
end;

function  TSGT.GetFileSandBoxed: Boolean;
begin
  Result := Boolean(al_get_new_file_interface = FFileInterface[True]);
end;

procedure TSGT.SetFileSandboxWriteDir(aPath: string);
begin
  PHYSFS_setWriteDir(PAnsiChar(AnsiString(aPath)));
end;

function  TSGT.GetFileSandboxWriteDir: string;
begin
  Result := string(PHYSFS_getWriteDir);
end;

procedure TSGT.EmitCmdConInactiveEvent;
begin
  al_emit_user_event(@FUserEventSrc , @FCmdConInactive , nil);
end;

procedure TSGT.EmitCmdConActiveEvent;
begin
  al_emit_user_event(@FUserEventSrc , @FCmdConActive , nil);
end;

procedure TSGT.RunGame(aGame: TCustomGameClass);
var
  LGame: TCustomGame;
begin
  if not Assigned(SGT) then Exit;
  LGame := aGame.Create;
  LGame.OnInit;
  LGame.OnRun;
  LGame.OnDone;
  FreeNilObject(LGame);
end;


{$ENDREGION}


initialization
  ReportMemoryLeaksOnShutdown := True;
  Startup;

finalization
  Shutdown;

end.
